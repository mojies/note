<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title>V4L2</title>
</head>
<body style="font-family: Courier New, Arial, Microsoft YaHei, sans-serif;" >
<style id="style_area" >
a{
    text-decoration:none;
}
p{
    line-height: 1.4em;
    /* text-indent:2em; */
    margin-top: 0;
    margin-bottom: 0;
    padding: 0.3em 0;
}
li{
    padding: 0.3em 0;
}
.gray-line{
    color:#F77;
    font-weight: 100;
    font-style: oblique;
    font-size: 0.8em;
}
code{
    line-height: 24px;
    border-bottom: rgb(253, 191, 186) solid 2px;
    margin: 3px 0.5em;
    padding: 2px;

    font-weight: 400;
    font-size: 13px;
    font-style: oblique;
    border-radius: 3px;
    backdrop-filter: blur(2px);
    color: rgb(227, 103, 90);
}
/* code{
    line-height: 20px;
    margin: 3px;
    padding: 2px;
    border-radius: 3px;
    color: #eb3f2f;
    font-weight: bold;
    font-size: 12px;
    margin: 3px;
    background-color:#f0f0f0;
    border-right: 1px solid #a9a9a9;
    border-bottom: 1px solid #a9a9a9;
    backdrop-filter: blur(2px);
} */
pre{
    border-radius: 4px;
    background-color: rgb(247,247,247,0.3);
    border: 1px solid #aaa;
    line-height: 1.182em;
    overflow: auto;
    font-size: 11px;
    padding: 16px;
    margin: 10px;
}
img{
    opacity:1;
    margin: 10px;
}
table, th, td {
    font-size: 12px;
    border: 1px solid #aaa;
    padding: 2px 0.5em;
    border-collapse: collapse;
}
th{
    font-size: 16px;
}

.ps{
    margin: 2px;
    font-size: 11px;
    font-style: italic;
}
.breadboard{
    box-shadow: 0 1px 4px 0 rgba(0,0,0,0.37);
    margin: 5px 2% 45px;
    padding: 10px;
}

.head_index{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: center;
}
.head_1{
    color: #133152;
    font-size: 32px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 4px #133152 solid;
    width: 99%;
    margin-top: 1.5em;
}
.head_2{
    color: #163a60;
    font-size: 28px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 2px #163a60 solid;
    width: 99%;
    margin-top: 1.25em;
}
.head_3{
    color: #1a426e;
    font-size: 24px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}
.head_4{
    color: #1d4a7bc2;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}
.head_5{
    color: #0d4886d2;
    font-size: 16px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.div_2{
    margin: 5px 2% 45px;
    padding: 40px;
    height: 100px;
    text-align: center;

}

.img_center{
    text-align: center;
}
.img_left{
    text-align: left;
    margin-left: 4em;
}
.note_msg{
    color: #eb3f2f;
    font-weight: 600;
}

.offset_1em{margin-left: 1em;}
.offset_2em{margin-left: 2em;}
.offset_3em{margin-left: 3em;}
.offset_4em{margin-left: 4em;}
.offset_5em{margin-left: 5em;}
.offset_6em{margin-left: 6em;}
.offset_7em{margin-left: 7em;}
.offset_8em{margin-left: 8em;}
.offset_9em{margin-left: 9em;}
.offset_10em{margin-left: 10em;}

.green_t{
    color: green;
}
.red_t{
    color: red;
}
.blue_t{
    color: blue;
}
.purple_t{
    color: purple;
}

.limit_window_size{
    /* overflow:auto; */
    max-height:30em;
    overflow-y:auto;
    word-wrap:break-word;
    word-break: normal;
    white-space: pre-wrap;
    margin:10px;
}

.child_red2_key li strong{
    color: red;
}
.child_red1_key li strong{
    color: red;
}
.child_red2_key li strong{
    color: #F77;
}
.child_red3_key li strong{
    color: #Faa;
}
.foot_panel{
    position:fixed;
    right:3em;
    bottom: 3em;
    width:6em;
    height:30px;
    padding:15px 5px 5px 15px;
    background-color:rgb( 157, 157, 157, 0.618 );
    border-radius: 8px;
}
/* .latex_str{
} */
#foot_panel_top{
    display: inline;
    border-right: 5px solid #eee;
}
#foot_panel_top a{
    width:4em;
}
#foot_panel_bottom {
    display: inline;
    margin-left: 5px;
}
#foot_panel_top a{
    width:4em;
}

#main_index li{
    line-height: 17px;
    font-size: 16px;
}
</style>




<div class="breadboard">
<div class="head_index">目录</div>
<div><ol id="main_index">
</ol></div>
</div>












<div class="breadboard">
<div class="head head_1">简介</div>
<p>
    Linux 媒体子系统包括以下几种不同类型设备的支持：
</p>
<ul>
    <li>Audio 和 Video 的采集</li>
    <li>PC 和 laptop 自带 Camera</li>
    <li>嵌入式的复杂的 Camera 设备</li>
    <li>模拟和数字 TV</li>
    <li>多点触控输入设备</li>
    <li>远程控制设备</li>
    <li>Media 的编解码器</li>
</ul>

<p>
    因此 Linux 为这些不同的设备提供了一些不同的 API：
</p>
<li>
    <li>Remote Controller API;</li>
    <li>HDMI CEC API;</li>
    <li>Video4Linux API;</li>
    <li>Media controller API;</li>
    <li>Video4Linux Request API (experimental);</li>
    <li>Digital TV API (also known as DVB API).</li>

</li>

<p>
    下文我们将着重对 V4L2 的相关部分来进行介绍。
</p>

</div>











<div class="breadboard">
<div class="head head_1">API</div>
<p>
    下面我们将着重针对 V4L2 的 Camera 部分，流捕获输出设备，编解码，编解码器和遥控器部分进行详细说明。
</p>

<div class="head head_2">视频捕获和输出、相机、模拟电视设备和编解码器</div>



<div class="head head_2">远程控制器</div>

<div class="head head_2">媒体控制器</div>

<div class="head head_2">CEC( 消费电子控制 )</div>
<p>
    HDMI 连接器提供一个供消 CEC 使用的引脚。该协议允许通过 HDMI 电缆连接的不同设备进行通信。
    CEC 1.4 版的协议在 HDMI 1.4a ( HDMI ) 规范的补充 1 (CEC) 和 2( HEAC 或 HDMI 以太网和音频回传通道 ) 的支持。
    并将这些特性添加到了 CEC 2.0 的扩展在第 11 章中定义HDMI 2.0 ( HDMI2 ) 规范中。
</p>
<p>
    实际上它的 Bitrate 特别慢（实际上每秒不超过 36 字节），并且基于旧 SCART 连接器中使用的古老 AV.link 协议。
    该协议非常类似于一个疯狂的 Rube Goldberg 装置，是低级和高级消息的邪恶组合。
    分层在 CEC 之上的 HEAC 协议的那部分，需要由内核处理，其他消息可以由内核或用户空间处理。
</p>
<p>
    此外，CEC 还可以在支持 HDMI TX / HIDMI RX 的 USB 中实现。
</p>
<p>
    支持 CEC 的驱动程序将创建一个 CEC 设备节点 ( <code>/dev/cecX</code> ) 以授予用户空间访问 CEC 适配器的权限。
    <code>ioctl CEC_ADAP_G_CAPS</code> 将 告诉用户空间它被允许做什么。
</p>
<p>
    为了检查支持和测试它，建议下载 <code>v4l-utils</code> 包。它提供了三种处理 CEC 的工具：
</p>
<ul>
<li><strong>cec-ctl</strong>:
    CEC的瑞士军刀。允许您配置、传输和监控 CEC 消息。
</li>
<li><strong>cec-compliance</strong>:
    对远程 CEC 设备进行 CEC 合规性测试，以确定 CEC 实施的合规性。
</li>
<li><strong>cec-follower</strong>:
    模拟 CEC 追随者。
</li>
</ul>

<p>
    操作 CEC 主要有以下 API：
</p>
<ul>
<li><code>open()</code></li>
<li><code>close()</code></li>
<li><code>ioctl()</code></li>
<li><code>poll()</code></li>
<li><code>ioctl CEC_ADAP_G_CAPS</code></li>
<li><code>ioctls CEC_ADAP_G_LOG_ADDRS and CEC_ADAP_S_LOG_ADDRS</code></li>
<li><code>ioctls CEC_ADAP_G_PHYS_ADDR and CEC_ADAP_S_PHYS_ADDR</code></li>
<li><code>ioctl CEC_ADAP_G_CONNECTOR_INFO</code></li>
<li><code>ioctl CEC_DQEVENT</code></li>
<li><code>ioctls CEC_G_MODE and CEC_S_MODE</code></li>
<li><code>ioctls CEC_RECEIVE and CEC_TRANSMIT</code></li>
</ul>


<div class="head head_3">int open(const char *device_name, int flags)</div>
<p>
    <code>flags</code> 必须包含 <code>O_RDWR</code>。
    当 <code>O_NONBLOCK</code> 存在的时候，如果你调用 <code>ioctl CEC_RECEIVE / CEC_DQEVENT</code>, 在没有消息和事件可用的时候， ioctl 可能会返回 <code>EAGAIN</code> 的错误信息。
    而且 <code>ioctls CEC_TRANSMIT & CEC_ADAP_S_PHYS_ADDR & CEC_ADAP_S_LOG_ADDRS</code> 将会直接返回 0。
</p>
<p>
    详细请参考：<a href="https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/cec/cec-func-open.html">https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/cec/cec-func-open.html</a>
</p>

<div class="head head_3">int close(int fd)</div>
<p>
    输入 open 之后的 fd。如果 fd 异常则会返回 <code>EBADF</code> 错误码。
</p>

<div class="head head_3">int ioctl(int fd, int request, void *argp)</div>
<p>
    ioctl 主要支持以下命令：
</p>
<ul>
<li><strong>CEC_ADAP_G_CAPS</strong>： 获取设备 CEC 能力
</li>
<li><strong>CEC_ADAP_G_LOG_ADDRS</strong> 和  <strong>CEC_ADAP_S_LOG_ADDRS</strong>:
    get 和 set 逻辑地址
</li>
<li><strong>CEC_ADAP_G_PHYS_ADDR</strong> 和 <code>CEC_ADAP_S_PHYS_ADDR</code>:
    get 和 set 物理地址
</li>
<li><strong>CEC_ADAP_G_CONNECTOR_INFO</strong>:
    获取 HDMI 的连接信息
</li>
<li><strong>CEC_DQEVENT</strong>：
    dequeue CEC 事件
</li>
<li><strong>CEC_G_MODE</strong> 和 <strong>CEC_S_MODE</strong>：
    Get 或者 set CEC adapter 的独占模式。
</li>
<li><strong>CEC_RECEIVE</strong> 和 <code>CEC_TRANSMIT</code>
    接受或者传输 CEC 的事件
</li>
</ul>

<div class="head head_3">int poll(struct pollfd *ufds, unsigned int nfds, int timeout)</div>
<p>
    <code>struct pollfd</code> 的结构如下图所示：
</p>
<pre>
struct pollfd {
    int fd;        /* 文件描述符 */
    short events; /* 等待的事件 */
    short revents; /* 实际发生了的事件 */
};
</pre>
<p>
    大体的使用方法和普通使用 poll 的方法类似，你需要准备一个 <code>struct pollfd</code> 的数组，然后你还要在数组里面天上你需要检查的描述符以及事件。
    而放检测到有匹配到等待的事件之后，会返回，返回匹配到描述符的个数。
</p>
<p>
    其中，当收到消息之后 reevent 会设置起 <code>POLLIN</code> 和 <code>POLLRDNORM</code>，如果发送队列有空间容纳新消息则会设置上 <code>POLLOUT</code> 和 <code>POLLWRNORM</code>，
    如果事件在事件队列中，那么 <code>POLLPRI</code> 将会被设置。如果没有任何事件并且超时，那么将不会设置任何标志位，并且返回 0。如果错误发生，则会返回 -1。
</p>

<div class="head head_3">ioctl CEC_ADAP_G_CAPS</div>
<p>
    使用方法：<code>int ioctl(int fd, CEC_ADAP_G_CAPS, struct cec_caps *argp)</code>
</p>
<p>
    其中 <code>struct cec_caps</code> 的数据结构如下所示：
</p>
<div class="tb_format">
    {
        "head":[ "Type", "Name", "Desc" ],
        "data": [
        [ "char", "driver[32]", "The name of the cec adapter driver" ],
        [ "char", "name[32]", "The name of this CEC adapter. The combination driver and name must be unique." ],
        [ "__u32", "available_log_addrs", "The maximum number of logical addresses that can be configured" ],
        [ "__u32", "capabilities", "The capabilities of the CEC adapter, see CEC Capabilities Flags" ],
        [ "__u32", "version", "CEC Framework API version, formatted with the KERNEL_VERSION() macro" ]
        ]
    }
</div>
</pre>

<p>
    其中 <code>capabilities</code> 字段现有如下定义：<code>其定义在 <code>uapi/linux/cec.h</code> 文件中</code>
</p>
<div class="tb_format">
    {
        "head":[ "Name", "Value", "Desc" ],
        "data": [
        [ "CEC_CAP_PHYS_ADDR", "0x00000001", "Userspace has to configure the physical address by calling ioctl CEC_ADAP_S_PHYS_ADDR. If this capability isn’t set, then setting the physical address is handled by the kernel whenever the EDID is set (for an HDMI receiver) or read (for an HDMI transmitter)." ],
        [ "CEC_CAP_LOG_ADDRS", "0x00000002", "Userspace has to configure the logical addresses by calling ioctl CEC_ADAP_S_LOG_ADDRS. If this capability isn’t set, then the kernel will have configured this." ],
        [ "CEC_CAP_TRANSMIT", "0x00000004", "Userspace can transmit CEC messages by calling ioctl CEC_TRANSMIT. This implies that userspace can be a follower as well, since being able to transmit messages is a prerequisite of becoming a follower. If this capability isn’t set, then the kernel will handle all CEC transmits and process all CEC messages it receives." ],
        [ "CEC_CAP_PASSTHROUGH", "0x00000008", "Userspace can use the passthrough mode by calling ioctl CEC_S_MODE." ],
        [ "CEC_CAP_RC", "0x00000010", "This adapter supports the remote control protocol." ],
        [ "CEC_CAP_MONITOR_ALL", "0x00000020", "The CEC hardware can monitor all messages, not just directed and broadcast messages." ],
        [ "CEC_CAP_NEEDS_HPD", "0x00000040", "The CEC hardware is only active if the HDMI Hotplug Detect pin is high. This makes it impossible to use CEC to wake up displays that set the HPD pin low when in standby mode, but keep the CEC bus alive." ],
        [ "CEC_CAP_MONITOR_PIN", "0x00000080", "The CEC hardware can monitor CEC pin changes from low to high voltage and vice versa. When in pin monitoring mode the application will receive CEC_EVENT_PIN_CEC_LOW and CEC_EVENT_PIN_CEC_HIGH events." ],
        [ "CEC_CAP_CONNECTOR_INFO", "0x00000100", "If this capability is set, then ioctl CEC_ADAP_G_CONNECTOR_INFO can be used." ]
        ]
    }
</div>

<div class="head head_3">ioctls CEC_ADAP_G_LOG_ADDRS and CEC_ADAP_S_LOG_ADDRS</div>
<p>
    使用方法： <code>int ioctl(int fd, CEC_ADAP_G_LOG_ADDRS, struct cec_log_addrs *argp)</code> and <code>int ioctl(int fd, CEC_ADAP_S_LOG_ADDRS, struct cec_log_addrs *argp)</code>
</p>
<p>
    其中 <code>struct cec_log_addrs</code> 的结构如下所示：
</p>
<pre>
struct cec_log_addrs {
    // The actual logical addresses that were claimed. This is set by the driver. If no logical address could be claimed, then it is set to CEC_LOG_ADDR_INVALID. If this adapter is Unregistered, then log_addr[0] is set to 0xf and all others to CEC_LOG_ADDR_INVALID.
    __u8 log_addr[CEC_MAX_LOG_ADDRS];

    //The bitmask of all logical addresses this adapter has claimed. If this adapter is Unregistered then log_addr_mask sets bit 15 and clears all other bits. If this adapter is not configured at all, then log_addr_mask is set to 0. Set by the driver.
    __u16 log_addr_mask;

    // The CEC version that this adapter shall use. See CEC Versions. Used to implement the CEC_MSG_CEC_VERSION and CEC_MSG_REPORT_FEATURES messages. Note that CEC_OP_CEC_VERSION_1_3A is not allowed by the CEC framework.
    __u8 cec_version;

    // Number of logical addresses to set up. Must be ≤ available_log_addrs as returned by ioctl CEC_ADAP_G_CAPS. All arrays in this structure are only filled up to index available_log_addrs-1. The remaining array elements will be ignored. Note that the CEC 2.0 standard allows for a maximum of 2 logical addresses, although some hardware has support for more. CEC_MAX_LOG_ADDRS is 4. The driver will return the actual number of logical addresses it could claim, which may be less than what was requested. If this field is set to 0, then the CEC adapter shall clear all claimed logical addresses and all other fields will be ignored.
    __u8 num_log_addrs;

    // The vendor ID is a 24-bit number that identifies the specific vendor or entity. Based on this ID vendor specific commands may be defined. If you do not want a vendor ID then set it to CEC_VENDOR_ID_NONE.
    __u32 vendor_id;

    // Flags. See Flags for struct cec_log_addrs for a list of available flags.
    __u32 flags;

    // The On-Screen Display name as is returned by the CEC_MSG_SET_OSD_NAME message.
    char osd_name[15];

    // Primary device type for each logical address. See CEC Primary Device Types for possible types.
    __u8 primary_device_type[CEC_MAX_LOG_ADDRS];

    // Logical address types. See CEC Logical Address Types for possible types. The driver will update this with the actual logical address type that it claimed (e.g. it may have to fallback to CEC_LOG_ADDR_TYPE_UNREGISTERED).
    __u8 log_addr_type[CEC_MAX_LOG_ADDRS];

    /* CEC 2.0 */
    // CEC 2.0 specific: the bit mask of all device types. See CEC All Device Types Flags. It is used in the CEC 2.0 CEC_MSG_REPORT_FEATURES message. For CEC 1.4 you can either leave this field to 0, or fill it in according to the CEC 2.0 guidelines to give the CEC framework more information about the device type, even though the framework won’t use it directly in the CEC message.
    __u8 all_device_types[CEC_MAX_LOG_ADDRS];
    // Features for each logical address. It is used in the CEC 2.0 CEC_MSG_REPORT_FEATURES message. The 12 bytes include both the RC Profile and the Device Features. For CEC 1.4 you can either leave this field to all 0, or fill it in according to the CEC 2.0 guidelines to give the CEC framework more information about the device type, even though the framework won’t use it directly in the CEC message.
    __u8 features[CEC_MAX_LOG_ADDRS][12];
};
</pre>

<p>
    <code>struct cec_log_addrs</code> 中的 <code>flags</code> 有如下释义：
</p>
<pre>
By default if no logical address of the requested type can be claimed, then it will go back to the unconfigured state. If this flag is set, then it will fallback to the Unregistered logical address. Note that if the Unregistered logical address was explicitly requested, then this flag has no effect.

#define CEC_LOG_ADDRS_FL_ALLOW_UNREG_FALLBACK   1
    
By default the CEC_MSG_USER_CONTROL_PRESSED and CEC_MSG_USER_CONTROL_RELEASED messages are only passed on to the follower(s), if any. If this flag is set, then these messages are also passed on to the remote control input subsystem and will appear as keystrokes. This features needs to be enabled explicitly. If CEC is used to enter e.g. passwords, then you may not want to enable this to avoid trivial snooping of the keystrokes.
#define CEC_LOG_ADDRS_FL_ALLOW_RC_PASSTHRU      2
    

// If this flag is set, then the device is CDC-Only. CDC-Only CEC devices are CEC devices that can only handle CDC messages.
// All other messages are ignored.    
#define CEC_LOG_ADDRS_FL_CDC_ONLY               4
</pre>

<p>
    CEC 的 Version 有：
</p>
<pre>
#define CEC_OP_CEC_VERSION_1_3A                 4

#define CEC_OP_CEC_VERSION_1_4B                 5

#define CEC_OP_CEC_VERSION_2_0                  6
</pre>

<p>
    CEC Primary Device Types
</p>
<pre>
// Use for a TV
#define CEC_OP_PRIM_DEVTYPE_TV                  0

// Use for a recording device.
#define CEC_OP_PRIM_DEVTYPE_RECORD              1

// Use for a device with a tuner.
#define CEC_OP_PRIM_DEVTYPE_TUNER               3

// Use for a playback device.
#define CEC_OP_PRIM_DEVTYPE_PLAYBACK            4

// Use for an audio system (e.g. an audio/video receiver).
#define CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM         5

// Use for a CEC switch.
#define CEC_OP_PRIM_DEVTYPE_SWITCH              6

// Use for a video processor device.
#define CEC_OP_PRIM_DEVTYPE_VIDEOPROC           7
</pre>

<p>
    CEC Logical Address Types：
</p>
<pre>
// Use for a TV.
#define CEC_LOG_ADDR_TYPE_TV   0

// Use for a recording device
#define CEC_LOG_ADDR_TYPE_RECORD   1

// Use for a tuner device
#define CEC_LOG_ADDR_TYPE_TUNER   2

// Use for a playback device
#define CEC_LOG_ADDR_TYPE_PLAYBACK   3

// Use for an audio system device
#define CEC_LOG_ADDR_TYPE_AUDIOSYSTEM   4

// Use for a second TV or for a video processor device
#define CEC_LOG_ADDR_TYPE_SPECIFIC   5

// Use this if you just want to remain unregistered. Used for pure CEC switches or CDC-only devices (CDC: Capability Discovery and Control).
#define CEC_LOG_ADDR_TYPE_UNREGISTERED   6
</pre>

<p>
    CEC All Device Types Flags
</p>
<pre>
// This supports the TV type
#define CEC_OP_ALL_DEVTYPE_TV 0x80

// This supports the Recording type.
#define CEC_OP_ALL_DEVTYPE_RECORD 0x40

// This supports the Tuner type.
#define CEC_OP_ALL_DEVTYPE_TUNER 0x20

// This supports the Playback type.
#define CEC_OP_ALL_DEVTYPE_PLAYBACK 0x10

// This supports the Audio System type
#define CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM 0x08

// This supports the CEC Switch or Video Processing type
#define CEC_OP_ALL_DEVTYPE_SWITCH 0x04
</pre>

<div class="head head_3">ioctls CEC_ADAP_G_PHYS_ADDR and CEC_ADAP_S_PHYS_ADDR</div>
<p>
    使用方法：<code>int ioctl(int fd, CEC_ADAP_G_PHYS_ADDR, __u16 *argp)</code> 和 <code>int ioctl(int fd, CEC_ADAP_S_PHYS_ADDR, __u16 *argp)</code>
</p>
<p>
    其中 <code>argp</code> 指向 CEC 的地址。
    不过仅当 <code>CEC_CAP_PHYS_ADDR </code> 被设置的时候才能设置 CEC 物理地址，因此再设置之前最好检查一下。
    而且 <code>CEC_ADAP_S_PHYS_ADDR</code> 只能再 init 模式下才能被调用，否则会返回一个 <code>EBUSY</code> 的错误信息。
</p>
<p>
    关于 init 模式，请参考： <code>see ioctls CEC_G_MODE & CEC_S_MODE</code>
</p>
<p>
    如果需要清除设置的物理地址，那么将之设置为 <code>CEC_PHYS_ADDR_INVALID</code> 即可。
</p>
<pre>
#define CEC_PHYS_ADDR_INVALID   0xffff
</pre>
<p>
    如果有逻辑地址正在定义中，那么该请求将会被阻塞，直到所有的逻辑地址都被成功声明。
    如果该 fd 被声明为非阻塞模式，那么该请求将会直接返回，返回值为 0.
</p>
<p>
    此外当你设置 PHY 地址之后，一个 <code>CEC_EVENT_STATE_CHANGE</code> 将会产生，并发送给对方设备。
</p>
<p>
    
</p>
<p>
    
A CEC_EVENT_STATE_CHANGE event is sent when the physical address changes.

The physical address is a 16-bit number where each group of 4 bits represent a digit of the physical address a.b.c.d where the most significant 4 bits represent ‘a’. The CEC root device (usually the TV) has address 0.0.0.0. Every device that is hooked up to an input of the TV has address a.0.0.0 (where ‘a’ is ≥ 1), devices hooked up to those in turn have addresses a.b.0.0, etc. So a topology of up to 5 devices deep is supported. The physical address a device shall use is stored in the EDID of the sink.

For example, the EDID for each HDMI input of the TV will have a different physical address of the form a.0.0.0 that the sources will read out and use as their physical address.
</p>

<div class="head head_3">ioctl CEC_ADAP_G_CONNECTOR_INFO</div>
<p>
    使用方法： <code>int ioctl(int fd, CEC_ADAP_G_CONNECTOR_INFO, struct cec_connector_info *argp)</code>
</p>
<p>
    使用改 ioctl 方法你可以获取到该 CEC 设备与哪个 HDMI 设备相关。调用该方法时，你的程序应该提供一个指向 <code>cec_connector_info</code> 结构体的指针，成功返回之后，内核会将该 CEC 的信息返回到该结构体中。
    当然，你再调用该方法之前，先应该减产 <code>CEC_CAP_CONNECTOR_INFO</code> 是否被标记。
</p>
<p>
    struct cec_connector_info 的结构如下所示：
</p>
<pre>
struct cec_connector_info {
// 没有 HDMI connector 与此 CEC 相关或者驱动程序并没有提供有用信息
#define CEC_CONNECTOR_TYPE_NO_CONNECTOR             0
// 存在一个 DRM 设备与该 CEC 设备相关联，详细信息可在 <code>cec_drm_connector_info</code> 中找到。
#define CEC_CONNECTOR_TYPE_DRM                      1
    __u32 type;

    union {
        struct cec_drm_connector_info drm;
        __u32 raw[16];
    };
};
</pre>
<p>
    struct cec_drm_connector_info 的结构如下所示：
</p>
<pre>
struct cec_drm_connector_info {
    // DRM card number， 如果值为 0， 则代表该 CEC 设备与 <code>/dev/card0</code> 关联
    __u32 card_no;

    // DRM connector ID
    __u32 connector_id;
};
</pre>


<div class="head head_3">ioctl CEC_DQEVENT</div>
<p>
    使用方法：<code>int ioctl(int fd, CEC_DQEVENT, struct cec_event *argp)</code>
</p>
<p>
    CEC devices can send asynchronous events. These can be retrieved by calling CEC_DQEVENT(). If the file descriptor is in non-blocking mode and no event is pending, then it will return -1 and set errno to the EAGAIN error code.

The internal event queues are per-filehandle and per-event type. If there is no more room in a queue then the last event is overwritten with the new one. This means that intermediate results can be thrown away but that the latest event is always available. This also means that is it possible to read two successive events that have the same value (e.g. two CEC_EVENT_STATE_CHANGE events with the same state). In that case the intermediate state changes were lost but it is guaranteed that the state did change in between the two events.
</p>
<p>
    struct cec_event 的结构如下所示：
</p>
<pre>
struct cec_event {
	__u64 ts;
	__u32 event;
	__u32 flags;
	union {
		struct cec_event_state_change state_change;
		struct cec_event_lost_msgs lost_msgs;
		__u32 raw[16];
	};
};
</pre>

<p>
    <code>struct cec_event_state_change</code> 的结构如下所示：
</p>
<pre>
struct cec_event_state_change {
	__u16 phys_addr;
	__u16 log_addr_mask;
	__u16 have_conn_info;
};
</pre>

<p>
    <code>struct cec_event_lost_msgs</code> 的结构如下所示：
</p>
<pre>
struct cec_event_lost_msgs {
	__u32 lost_msgs;
};
</pre>

<p>
    <code>CEC Events Types</code> 有下面这些
</p>
<pre>
#define CEC_EVENT_STATE_CHANGE		1
#define CEC_EVENT_LOST_MSGS		    2
#define CEC_EVENT_PIN_CEC_LOW		3
#define CEC_EVENT_PIN_CEC_HIGH		4
#define CEC_EVENT_PIN_HPD_LOW		5
#define CEC_EVENT_PIN_HPD_HIGH		6
#define CEC_EVENT_PIN_5V_LOW		7
#define CEC_EVENT_PIN_5V_HIGH		8
</pre>

<p>
    <code>CEC Event Flags</code> 有下面这些：
</p>
<pre>
#define CEC_EVENT_FL_INITIAL_STATE	(1 << 0)
#define CEC_EVENT_FL_DROPPED_EVENTS	(1 << 1)
</pre>


<div class="head head_3">ioctls CEC_G_MODE and CEC_S_MODE</div>
<p>
    使用方法：<code>int ioctl(int fd, CEC_G_MODE, __u32 *argp)</code> 和 <code>int ioctl(int fd, CEC_S_MODE, __u32 *argp) </code>
</p>

<p>
    By default any filehandle can use ioctls CEC_RECEIVE and CEC_TRANSMIT, but in order to prevent applications from stepping on each others toes it must be possible to obtain exclusive access to the CEC adapter. This ioctl sets the filehandle to initiator and/or follower mode which can be exclusive depending on the chosen mode. The initiator is the filehandle that is used to initiate messages, i.e. it commands other CEC devices. The follower is the filehandle that receives messages sent to the CEC adapter and processes them. The same filehandle can be both initiator and follower, or this role can be taken by two different filehandles.

When a CEC message is received, then the CEC framework will decide how it will be processed. If the message is a reply to an earlier transmitted message, then the reply is sent back to the filehandle that is waiting for it. In addition the CEC framework will process it.

If the message is not a reply, then the CEC framework will process it first. If there is no follower, then the message is just discarded and a feature abort is sent back to the initiator if the framework couldn’t process it. If there is a follower, then the message is passed on to the follower who will use ioctl CEC_RECEIVE to dequeue the new message. The framework expects the follower to make the right decisions.

The CEC framework will process core messages unless requested otherwise by the follower. The follower can enable the passthrough mode. In that case, the CEC framework will pass on most core messages without processing them and the follower will have to implement those messages. There are some messages that the core will always process, regardless of the passthrough mode. See Core Message Processing for details.

If there is no initiator, then any CEC filehandle can use ioctl CEC_TRANSMIT. If there is an exclusive initiator then only that initiator can call ioctls CEC_RECEIVE and CEC_TRANSMIT. The follower can of course always call ioctl CEC_TRANSMIT.

Available initiator modes are:
</p>

<p>
    <code>Initiator Modes</code> 如下所示：
</p>
<pre>
#define CEC_MODE_NO_INITIATOR		(0x0 << 0)
#define CEC_MODE_INITIATOR		(0x1 << 0)
#define CEC_MODE_EXCL_INITIATOR		(0x2 << 0)
#define CEC_MODE_INITIATOR_MSK		0x0f
</pre>

<p>
    <code>Follower Modes</code> 如下所示：
</p>
<pre>
#define CEC_MODE_NO_FOLLOWER		(0x0 << 4)
#define CEC_MODE_FOLLOWER		(0x1 << 4)
#define CEC_MODE_EXCL_FOLLOWER		(0x2 << 4)
#define CEC_MODE_EXCL_FOLLOWER_PASSTHRU	(0x3 << 4)
#define CEC_MODE_MONITOR_PIN		(0xd << 4)
#define CEC_MODE_MONITOR		(0xe << 4)
#define CEC_MODE_MONITOR_ALL		(0xf << 4)
#define CEC_MODE_FOLLOWER_MSK		0xf0
</pre>

<p>
    <code>Core Message Processing</code> 如下所示：
</p>
<pre>
#define CEC_MSG_GET_CEC_VERSION				0x9f
#define CEC_MSG_GIVE_DEVICE_VENDOR_ID       0x8c
#define CEC_MSG_ABORT                       0xff
#define CEC_MSG_GIVE_PHYSICAL_ADDR			0x83
#define CEC_MSG_GIVE_OSD_NAME				0x46
#define CEC_MSG_GIVE_FEATURES				0xa5
#define CEC_MSG_USER_CONTROL_PRESSED        0x44
#define CEC_MSG_USER_CONTROL_RELEASED       0x45
#define CEC_MSG_REPORT_PHYSICAL_ADDR        0x84
</pre>


<div class="head head_3">ioctls CEC_RECEIVE and CEC_TRANSMIT</div>
<p>
    使用方法：<code>int ioctl(int fd, CEC_RECEIVE, struct cec_msg *argp)</code> 和 <code>int ioctl(int fd, CEC_TRANSMIT, struct cec_msg *argp)</code>。
    参考：<a href="https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/cec/cec-ioc-receive.html">https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/cec/cec-ioc-receive.html</a>
</p>
<p>
    <code>struct cec_msg</code> 的结构如下所示：
</p>
<pre>
struct cec_msg {
    __u64 tx_ts;
    __u64 rx_ts;
    __u32 len;
    __u32 timeout;
    __u32 sequence;

#define CEC_MSG_FL_REPLY_TO_FOLLOWERS	(1 << 0)
#define CEC_MSG_FL_RAW			(1 << 1)
    __u32 flags;
    __u8 msg[CEC_MAX_MSG_SIZE];
    __u8 reply;


#define CEC_RX_STATUS_OK		(1 << 0)
#define CEC_RX_STATUS_TIMEOUT		(1 << 1)
#define CEC_RX_STATUS_FEATURE_ABORT	(1 << 2)
#define CEC_RX_STATUS_ABORTED		(1 << 3)
    __u8 rx_status;


#define CEC_TX_STATUS_OK		(1 << 0)
#define CEC_TX_STATUS_ARB_LOST		(1 << 1)
#define CEC_TX_STATUS_NACK		(1 << 2)
#define CEC_TX_STATUS_LOW_DRIVE		(1 << 3)
#define CEC_TX_STATUS_ERROR		(1 << 4)
#define CEC_TX_STATUS_MAX_RETRIES	(1 << 5)
#define CEC_TX_STATUS_ABORTED		(1 << 6)
#define CEC_TX_STATUS_TIMEOUT		(1 << 7)
    __u8 tx_status;
    __u8 tx_arb_lost_cnt;
    __u8 tx_nack_cnt;
    __u8 tx_low_drive_cnt;
    __u8 tx_error_cnt;
};
</pre>

<div class="head head_3">xxxxxxx</div>
<div class="head head_3">xxxxxxx</div>


</div>














<div class="breadboard">
<div class="head head_1">参考文档</div>
<ul>
<li>
    <a href="https://linuxtv.org/downloads/v4l-dvb-apis/index.html">Linux Kernel Media Documentation</a>
</li>
<li>
    <a href="https://git.linuxtv.org/v4l-utils.git/about/">v4l-utils</a>
</li>
<li>
    <a href="https://en.wikipedia.org/wiki/Video4Linux">wiki V4l2</a>
</li>
</ul>

</div>
















<table><tr>
<td><img width="190" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_AliPay1.jpg" alt=""></td>
<td><img width="200" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_WeChatPa1.jpg" alt=""></td>
</tr></table>
<div class="div_2" id="AuthorizationWarning">
<div class="Text_ZZ">原创文章，版权所有，转载请获得作者本人允许并注明出处</div>
<div class="Text_LB">我是留白；我是留白；我是留白；（重要的事情说三遍）</div>
</div>
<div class="foot_panel" id="foot_panel">
    <div id="foot_panel_top" >
        <a href="#main_index" class="NoExternal">TOP</a>
    </div>
    <div id="foot_panel_bottom" >
        <a href="#AuthorizationWarning" class="NoExternal">BOT</a>
    </div>
</div>
</body>

<script src="js/PrePost.js"></script>
</html>
