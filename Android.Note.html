<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title>Android 笔记</title>
</head>
<body style="font-family: Courier New, Arial, Microsoft YaHei, sans-serif;" >
<style id="style_area" >
a{
    text-decoration:none;
}
p{
    line-height: 1.4em;
    /* text-indent:2em; */
    margin-top: 0;
    margin-bottom: 0;
    padding: 0.3em 0;
}
li{
    padding: 0.3em 0;
}
.gray-line{
    color:#F77;
    font-weight: 100;
    font-style: oblique;
    font-size: 0.8em;
}
code{
    line-height: 24px;
    border-bottom: rgb(253, 191, 186) solid 2px;
    margin: 3px 0.5em;
    padding: 2px;

    font-weight: 400;
    font-size: 13px;
    font-style: oblique;
    border-radius: 3px;
    backdrop-filter: blur(2px);
    color: rgb(227, 103, 90);
}
/* code{
    line-height: 20px;
    margin: 3px;
    padding: 2px;
    border-radius: 3px;
    color: #eb3f2f;
    font-weight: bold;
    font-size: 12px;
    margin: 3px;
    background-color:#f0f0f0;
    border-right: 1px solid #a9a9a9;
    border-bottom: 1px solid #a9a9a9;
    backdrop-filter: blur(2px);
} */
pre{
    border-radius: 4px;
    background-color: rgb(247,247,247,0.3);
    border: 1px solid #aaa;
    line-height: 1.182em;
    overflow: auto;
    font-size: 11px;
    padding: 16px;
    margin: 10px;
}
img{
    opacity:1;
    margin: 10px;
}
table, th, td {
    font-size: 12px;
    border: 1px solid #aaa;
    padding: 2px 0.5em;
    border-collapse: collapse;
}
th{
    font-size: 16px;
}

.ps{
    margin: 2px;
    font-size: 11px;
    font-style: italic;
}
.breadboard{
    box-shadow: 0 1px 4px 0 rgba(0,0,0,0.37);
    margin: 5px 2% 45px;
    padding: 10px;
}

.head_index{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: center;
}
.head_1{
    color: #133152;
    font-size: 32px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 4px #133152 solid;
    width: 99%;
    margin-top: 1.5em;
}
.head_2{
    color: #163a60;
    font-size: 28px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 2px #163a60 solid;
    width: 99%;
    margin-top: 1.25em;
}
.head_3{
    color: #1a426e;
    font-size: 24px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}
.head_4{
    color: #1d4a7bc2;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}
.head_5{
    color: #0d4886d2;
    font-size: 16px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.div_2{
    margin: 5px 2% 45px;
    padding: 40px;
    height: 100px;
    text-align: center;

}

.img_center{
    text-align: center;
}
.img_left{
    text-align: left;
    margin-left: 4em;
}
.note_msg{
    color: #eb3f2f;
    font-weight: 600;
}

.offset_1em{margin-left: 1em;}
.offset_2em{margin-left: 2em;}
.offset_3em{margin-left: 3em;}
.offset_4em{margin-left: 4em;}
.offset_5em{margin-left: 5em;}
.offset_6em{margin-left: 6em;}
.offset_7em{margin-left: 7em;}
.offset_8em{margin-left: 8em;}
.offset_9em{margin-left: 9em;}
.offset_10em{margin-left: 10em;}

.green_t{
    color: green;
}
.red_t{
    color: red;
}
.blue_t{
    color: blue;
}
.purple_t{
    color: purple;
}

.limit_window_size{
    /* overflow:auto; */
    max-height:30em;
    overflow-y:auto;
    word-wrap:break-word;
    word-break: normal;
    white-space: pre-wrap;
    margin:10px;
}

.child_red2_key li strong{
    color: red;
}
.child_red1_key li strong{
    color: red;
}
.child_red2_key li strong{
    color: #F77;
}
.child_red3_key li strong{
    color: #Faa;
}
.foot_panel{
    position:fixed;
    right:3em;
    bottom: 3em;
    width:6em;
    height:30px;
    padding:15px 5px 5px 15px;
    background-color:rgb( 157, 157, 157, 0.618 );
    border-radius: 8px;
}
/* .latex_str{
} */
#foot_panel_top{
    display: inline;
    border-right: 5px solid #eee;
}
#foot_panel_top a{
    width:4em;
}
#foot_panel_bottom {
    display: inline;
    margin-left: 5px;
}
#foot_panel_top a{
    width:4em;
}

#main_index li{
    line-height: 17px;
    font-size: 16px;
}
</style>




<div class="breadboard">
<div class="head_index">目录</div>
<div><ol id="main_index">
</ol></div>
</div>












<div class="breadboard">
<div class="head head_1">基础</div>
<ul>
<li><strong>版本</strong>
    <br> Android 作業系統有預發行的內部版本，分別為原子小金剛（Astro）與機器人班亭（Bender，电视动画《乃出個未來》的角色）。
    從2009年5月開始，Android 的版本代號改以甜點來命名，且每個代號間的字首以英文字母序接續排列： Cupcake （紙杯蛋糕）、Donut（甜甜圈）、Eclair（閃電泡芙）、
    Froyo（優格冰淇淋）、Gingerbread（薑餅）、Honeycomb（蜂巢）[來源請求]、Ice Cream Sandwich（冰淇淋三明治）、Jelly Bean（雷根糖）、KitKat（奇巧巧克力）、
    Lollipop（棒棒糖）、Marshmallow（棉花糖）、Nougat（牛轧糖）、Oreo（奧利奧）、Pie（派）、Red Velvet Cake（11.0——紅色天鵝絨蛋糕）、Snow cone（12.0——杯套裝碎冰）。
    唯一不使用以甜品命名的版本為 Android 10，2019 年 8 月 23 日，Google 宣布從 Android Q 開始不再以甜品命名，且直接稱 <strong>Android Q</strong> 為 <strong>Android 10</strong> 。 -- 摘自 WIKI-PEDIA 
    <br>  <img cllass="img_center" width="600px" src="https://images.cnblogs.com/cnblogs_com/mojies/2134079/o_220328160151_Android.version.png"/>
    <div class="tb_format offset_1em">
        {
            "head":["名称", "代号"],
            "data":[
            [ "Android 10", "Q" ],
            [ "Android 11", "R" ],
            [ "Android 12", "S" ],
            [ "Android 13", "T" ]
            ]
        }
    </div>
</li>

<li><strong>NDK 下载</strong>
    <br> NDK 的下载请访问：<a href="https://developer.android.com/ndk/downloads?hl=zh-cn">这里</a>。
</li>


</ul>
</div>










<div class="breadboard">
<div class="head head_1">AS 开发</div>
<ul>

<li><strong>AndroidAPP 中指定 SDK and NDK</strong>
    <br> 工程 <code>local.properties</code> 文件中增加以下两行，其中路径该成你安装 SDK 和 NDK 的路径。
<pre>
sdk.dir=D\:\\AndroidSDK
ndk.dir=D\:\\AndroidSDK\\ndk\\24.0.8215888
</pre>

</li>

<li><strong>乱码</strong>
    <br> 方法1: <strong>双击 shift -> 搜索 <code>Edit Custom VM Options</code> -> 回车，没有则创建之 </strong>, 在打开的文件中加入配置： <code>-Dfile.encoding=UTF-8</code>, 然后 <strong>双击 shift -> 搜索 <code>restart IED</code> -> 回车 </strong>,
</li>

<li><strong>配置代理</strong>
    <br> 在工程的 <code>gradle.properties</code> 文件中，或者 <code>~/.gradle/gradle.properties</code> 中加入下列配置，如果不支持可以使用 <code>#</code> 注释。
    <pre>
systemProp.http.proxyHost=www.somehost.org
systemProp.http.proxyPort=8080
systemProp.http.proxyUser=user
systemProp.http.proxyPassword=password
systemProp.http.nonProxyHosts=localhost
systemProp.http.auth.ntlm.domain=domain

systemProp.https.proxyHost=www.somehost.org
systemProp.https.proxyPort=8080
systemProp.https.proxyUser=user
systemProp.https.proxyPassword=password
systemProp.https.nonProxyHosts=localhost
systemProp.https.auth.ntlm.domain=domain
    </pre>

</li>
<li><strong>Could not resolve all artifacts for configuration ':classpath'.</strong>
    <br> 如果你出现类似下面的 BUG, 那么很有可能你无法访问 maven 仓库，这时你可能需要设置一下代理，或者直接在浏览器中访问一下报错链接：
    <pre>
> Could not resolve all artifacts for configuration ':classpath'.
   > Could not resolve com.android.tools.build:gradle:4.1.0.
   ...
               > Could not GET 'https://maven.aliyun.com/nexus/content/groups/public/com/android/tools/build/gradle/4.1.0/gradle-4.1.0.pom'.
   ...
    </pre>
    <br> 但是还有一种可能，你设置了 aliyun 的代理仓库。但是老的代理仓库已经不支持了，比如下面这样的老配置：
    <pre>
buildscript {
    repositories {
        maven{ url 'https://maven.aliyun.com/nexus/content/groups/public/' }
        maven{ url 'https://maven.aliyun.com/repository/google' }
        maven{ url 'https://maven.aliyun.com/nexus/content/groups/public/'}
        google()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:4.1.0'
    }
}

allprojects {
    repositories {
        maven{ url 'https://maven.aliyun.com/nexus/content/groups/public/' }
        maven{ url 'https://maven.aliyun.com/repository/google' }
        maven{ url 'https://maven.aliyun.com/nexus/content/groups/public/'}
        google()
    }
}
    </pre>
    <br> 这个时候你需要参考阿里云最新的 maven 仓库使用规范： <a href="https://developer.aliyun.com/mvn/guide">https://developer.aliyun.com/mvn/guide</a>, 来更新你的配置，但我自己没有搞定。
        因此我还是用回了原来的仓库，解决问题：如下所示：
    <pre>
buildscript {
    repositories {
        google()
        jcenter()
        maven { url "https://maven.google.com" }
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:4.1.0'
    }
}

allprojects {
    repositories {
        google()
        jcenter()
        maven { url "https://maven.google.com" }
    }
}
    </pre>
</li>
<li><strong>在命令行编译 Android APP</strong>
    <br> 在命令行可以直接使用 <code>gradle</code>，或者工程下的 gradlew 来直接编译，不过你先需要使用 <code>chmod +x</code> 确保你的 <code>gradlew</code> 有可执行权限。
    <br> 使用 <code>./gradlew task</code> 可以查看当前工程中支持的子任务，如下所示：
    <pre>
> ./gradlew task               

> Task :tasks

------------------------------------------------------------
Tasks runnable from root project
------------------------------------------------------------
...

Build tasks
-----------
assemble - Assemble main outputs for all the variants.
assembleAndroidTest - Assembles all the Test applications.
...

    </pre>
    <br> 这时你可以直接使用 <code>./gradlew TASK</code> 的形式来进行相关 task 的执行。
</li>

<li><strong>命令行编译 Android 应用工程和升级 Android SDK</strong>
    <br> 首先你可以使用如下命令来编译 Android 工程，而且有可能你编译的时候会报错，如下所示：
    <pre>
> ./gradlew compileDebugSources
Exception while marshalling /opt/android-sdk/tools/package.xml. Probably the SDK is read-only
...
<span class="red_t">FAILURE: Build failed with an exception.</span>

* What went wrong:
Could not determine the dependencies of task ':app:compileDebugJavaWithJavac'.
> Failed to install the following Android SDK packages as some licences have not been accepted.
     build-tools;30.0.3 Android SDK Build-Tools 30.0.3
     platforms;android-29 Android SDK Platform 29
    </pre>
    <br> 这时你可以通过 <code>sdkmanager --install "build-tools;30.0.3"</code> 命令和 <code>sdkmanager --install platforms;android-29</code> 来安装相关的哦依赖；
    <br> 当然你首先要确保 <code>sdkmanager</code> 存在才行，这请参考： <a href="https://developer.android.com/studio/command-line">https://developer.android.com/studio/command-line</a>
    <br> 其次你还需要确保你的 Android studio 工程使用的 SDK 是你安装的 SDK 目录才行。
        像我系统默认的 SDK 目录是 <code>/opt/android/sdk</code>, 但是如果你没有安装 SDK 在该目录或者，你没有权限，那么此时大概率也会报告上述问题。
        假如你安装 Android SDK 的目录在 <code>/home/USER/android/sdk</code>, 那么你需要在 <code>local.properties</code> 中声明你使用的 SDK 的实际目录。
        如下所示：
        <pre>
> cat local.properties
## This file must *NOT* be checked into Version Control Systems,
# as it contains information specific to your local configuration.
#
# Location of the SDK. This is only used by Gradle.
# For customization when using a Version Control System, please read the
# header note.
#Sun Jul 24 16:58:18 CST 2022
sdk.dir=/home/USER/android/sdk
        </pre>
</li>
<li><strong>给你的 Android 工程制定 SDK 可 NDK 目录</strong>
    <br> 你可以在 <code>local.properties</code> 中声明你使用的 Android SDK 或者 NDK 的实际目录。
    如下所示：
    <pre>
> cat local.properties
sdk.dir=/home/USER/android/sdk
ndk.dir=/home/USER/android/sdk/ndk-bundle
    </pre>
    <br> <span class="red_t">注意：这里的路径不能是相对路径，一定要得是相对路径，而且像 <code>sdk.dir=~/android/sdk</code> 这样的路径也是不行的。</span>
    <br> <span class="red_t">注意： Windows 下的反斜杠需要使用 <code>\\</code> 取代，防止反转译。比如： <code>sdk.dir=D:\\android\\sdk</code></span>
    

</li>
</ul>

</div>








<div class="breadboard">
<div class="head head_1">命令行工具</div>
<ul>
<li><strong>screencap 源码</strong>
    <br> 位置： <code>frameworks/base/cmds/screencap/</code>
</li>
<li><strong>dumpsys</strong>
    <br> 查询系统服务运行状态：命令格式 <code>dumpsys 服务名</code>, 服务名可以通过 <code>dumpsys -L</code> 或者 <code>service List</code> 查看。
    <br> 查看可以的 display <code>dumpsys SurfaceFlinger --display-id</code>
</li>
</ul>
</div>








<div class="breadboard">
<div class="head head_1">Android 系统编译框架</div>





<div class="head head_2">Android 一些基本知识</div>
<ul>
<li><strong>KITA</strong>
    <br> 参考文档： <a href="https://note.qidong.name/2017/08/android-kati/">Android中的Kati</a>
    <br> KITA 的仓库地址：<a href="https://github.com/google/kati">https://github.com/google/kati</a>
    <br> 基本上里面初步对 KITA 进行了介绍，但是为了避免原文失效，我将原文中部分内容进行摘抄。
    <br> KITA 的作用： kati 是 Google 专门为了 Android 而开发的一个小项目，基于 Golang 和 C++ 。 目的是为了把 Android 中的 Makefile ，转换成 Ninja 文件。


</li>
<li><strong>Ninjia</strong>
    <br> 参考文档： <a href="https://note.qidong.name/2017/08/android-ninja/">Android中的Ninja简介</a>
    <br> 基本上里面初步对 KITA 进行了介绍，但是为了避免原文失效，我将原文中部分内容进行摘抄。
    <br> 二者最核心的区别，在于设计哲学。 Makefile 是设计来给人手写的，而 Ninja 设计出来是给其它程序生成的。 如果说 Makefile 是 C 语言，那么 Ninja 就是汇编语言。 如果说 Makefile 是一个 DSL ，那么 Ninja 就是一种配置文件。
         Makefile 支持分支、循环等流程控制，而 Ninja 只支持一些固定形式的配置。
    <br> 二者的相同点是，都是为了控制编译流程而设计。 所以，他们的核心功能，都是指定目标，以及目标之间的依赖关系，自动计算执行顺序。
    <br> 与 Makefile 相比，由于 Ninja 仅仅专注于核心的功能，所以有轻巧、速度快的优点。

</li>
<li><strong>Android 中 Makefile, Android.mk, Android.bp, Soong, Ninja, Blueprint 的关系</strong>
    <br> kita 编译出 ckita 可执行文件， ckita 可将 Makefile 转换成 build.ninja 文件，用于 ninja 建构；
    <br> Soong 包含一个 androidmk 的命令，可自动将 Android.mk 转换成 Android.bp,  这只对无选择、循环等复杂流程控制的 Android.mk 生效。
    <br> Android.bp 则使用 Blueprint 框架来解析，最终转换成 Ninja 文件。
    <br> Android.bp 是用来替换 Android.mk 的配置文件。
    <br> Blueprint 和 Soong 都是由 Golang 写的项目。 从 Android Nougat 开始， prebuilts/go/ 目录下新增了 Golang 所需的运行环境，在编译时使用。
    <br> 这几个模块之间的关系也可表示成下面这样：
    <pre>
Android.bp --> Blueprint --> Soong --> Ninja
Makefile or Android.mk --> kati --> Ninja
(Android.mk --> Soong --> Blueprint --> Android.bp)
    </pre>


</li>
</ul>







<div class="head head_2">Android build/envsetup.sh 提供的指令（函数）</div>
<p>
    一般编译 Android 会首先要执行 <code>source build/envsetup.sh</code>, 该命令会将脚本中的一些脚本函数（操作流程）加载到当前的环境中。
    你可以通过直接调用函数名称来执行该过程。该脚本加载的函数包括：
</p>
<ul>
<li><strong>gettop</strong>（经常用到）
    <br> 获取当前工程的绝对路径
</li>
<li><strong>get_build_var</strong>（非常有用，有助于分析编译架构）
    <br> 获取某一个宏（变量 or 环境变量）对应对值。这个函数其实调用的是 <code>build/soong/soong_ui.bash --dumpvar-mode $1</code>。
    <br> 而 soong 则是变量 device 目录下的 <code>AndroidProducts.mk</code> 目录来获得该列表的。
</li>
<li><strong>hmm</strong>
    <br> 打印以下命令的帮助信息
</li>
<li><strong>lunch</strong>
    <br> 选择板级，你可以直接在该函数后带目标板级，也可以直接执行该函数。
    <br> 直接调用该函数之后，它会直接打印出当前 SDK 支持的板级，你选择好编号之后，也可选择初始化对应的板级。
    <br> 一般你在编译之前，都需要运行该命令，确定你编译的目标平台。
    <br> 执行完该命令之后，一般会设置下列几个主要的环境变量：<code>TARGET_PRODUCT</code>, <code>TARGET_BUILD_VARIANT</code>, <code>TARGET_PLATFORM_VERSION</code>
    <br> <code>BUILD_TYPE</code> 一般有三个可选的值： <code>user</code>， <code>userdebug</code>， <code>eng</code>。 其分别代表，开放给用限制权限的版本；带有开放 root 权限的可调式版本；带有开发工具/调试工具的版本。
</li>
<li><strong>tapas</strong>
    <br> 主要用于配置之前没有配置到板级中的应用。执行 <code>tapas</code> 或者 <code>hmm</code> 可以了解详情。
</li>
<li><strong>banchan</strong>
    <br> 和 tapas 类似，不过该命令用于配置模块。
</li>
<li><strong>croot</strong>
    <br> cd 到工程顶部目录。
</li>
<li><strong>m</strong>
    <br> 在 top 目录进行建构，其可指定特定的名称来建构指定模块
    <br> 这些名称在哪里找？
</li>
<li><strong>mm</strong> 和 <strong>mma</strong>
    <br> 构建当前目录中的工程
</li>
<li><strong>mmm</strong> 和 <strong>mmma</strong>
    <br> 构建和安装指定目录中的所有 modules 以及它们的依赖。可用 <code>mmm dir/:target1,target2</code> 来限制构建的对象。
</li>
<li><strong>provision</strong>
    <br> Flash device with all required partitions. Options will be passed on to fastboot.
    <br> （这个我也不知道是什么意思，因为我的工程编译出来也没有 provision-device 这个可执行文件。我从参考脚本中理解到的解释是清除当前编译的目标，不包括 fastboot）
</li>
<li><strong>cgrep</strong>
    <br> Greps on all local C/C++ files
    <br> 在工程的所有 C/C++ 程序中查找包含目标字符串
    <br> 实际执行如下命令：
    <code>find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f \( -name '*.c' -o -name '*.cc' -o -name '*.cpp' -o -name '*.h' -o -name '*.hpp' \) 
        -exec grep --color -n "$@" {} +
    </code>
</li>
<li><strong>ggrep</strong>
    <br> Greps on all local Gradle files.
    <br> 这些命令与上叙类似，可以查看 <code>build/envsetup.sh</code> 中的具体实现。
    比如这个，命令的具体实现是：
    <code> find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f -name "*\.gradle" -exec grep --color -n "$@" {} +
    </code>
</li>
<li><strong>gogrep</strong>
    Greps on all local Go files
</li>
<li><strong>jgrep</strong>
    Greps on all local Java files.
</li>
<li><strong>ktgrep</strong>
    Greps on all local Kotlin files
</li>
<li><strong>resgrep</strong>
    Greps on all local res/*.xml files
</li>
<li><strong>mangrep</strong>
    Greps on all local AndroidManifest.xml files
</li>
<li><strong>mgrep</strong>
    Greps on all local Makefiles and *.bp files
</li>
<li><strong>owngrep</strong>
    Greps on all local OWNERS files
</li>
<li><strong>rsgrep</strong>
    Greps on all local Rust files
</li>
<li><strong>sepgrep</strong>
    Greps on all local sepolicy files
</li>
<li><strong>sgrep</strong>
    Greps on all local source files
</li>
<li><strong>godir</strong>
    <br> 搜索并跳转到包含某个文件的目录
</li>
<li><strong>allmod</strong>
    <br> 列举所有的模块
</li>
<li><strong>gomod</strong>
    <br> 跳转到包含某个模块的目录
</li>
<li><strong>pathmod</strong>
    <br> 打印包含某个模块的路径（绝对路径），比如执行 <code>pathmod Camera2</code>，就会输出 <code>/home/xxx/xxx/packages/apps/Camera2</code>.
</li>
<li><strong>outmod</strong>
    <br> 打印某个模块安装到 out 目录的所有文件的绝对路径。比如执行 <code>outmod toybox</code>
</li>
<li><strong>dirmods</strong>
    <br> 输出某个指定路径下包括的所有模块名称（注意不是模块的目录名称）
</li>
<li><strong>installmod</strong>
    <br> 利用 adb 安装一个构建的 APK
</li>
<li><strong>refreshmod</strong>
    <br> 刷新所有的模块列表，包括 <code> allmod/gomod/pathmod/outmod/installmod </code>。
</li>
<li><strong>syswrite</strong>
    <br> 重新以可写的方式挂载分区(比如：system.img)（如果有可能会 reboot）
</li>

</ul>

<p>
    <code>TARGET_DEVICE_DIR</code> 保存当前板级编译配置的路径。
    比如我编译的板级为 <code>rk3588_firefly_itx_3588j-userdebug</code>， 那么 <code>TARGET_DEVICE_DIR</code> 的值为 <code>device/rockchip/rk3588/rk3588_firefly_itx_3588j</code>
</p>





<div class="head head_2">当你再执行完 <code>source build/envsetup.sh</code> 和 <code>lunch PLT</code> 之后，再运行 make 这时编译系统做了哪些事情？</div>
<p>
    make 命令会自动加载 Makefile 中的内容，而可能你看到的工程根目录中的 Makefile 只有一行内容，即 <code>include build/make/core/main.mk</code>
</p>
<p>
    而再你打开 <code>include build/make/core/main.mk</code> 文件之后，再文件的前部会看到 main.mk 将 make 的默认 target 改成了 <code>droid</code>, 而 <code>droid</code> target 又进而执行了 <code>droid_targets</code> target。
</p>
<pre>
...
.PHONY: droid
DEFAULT_GOAL := droid
$(DEFAULT_GOAL): droid_targets
...
droid_targets : blueprint_tools
...
</pre>
<p>
    你可能已经发现了 <code>droid_targets</code> 最终调用到了 <code>blueprint_tools</code> target, 但你找遍整个 core 都找不到 <code>blueprint_tools</code> target 再哪里。
    别着急，
</p>



<div class="head head_2">关于 Android.mk</div>
<p>
    PS: 本章以下内容大多取自 <a href="https://deepinout.com/android-mk-explanation/android-mk-module-description-variable/android-mk-local_path.html">极客笔记</a> 相关页面。
</p>
<ul>
<li><strong>CLEAR_VARS</strong>
    <br> <code>CLEAR_VARS</code> 指向一个特殊的 Makefile（可能在这个路径 <code>./build/make/core/clear_vars.mk</code> ），该命令将会为你清除很多 <code>LOCAL_</code> 开头的变量,
        例如 LOCAL_MODULE、LOCAL_SRC_FILES 和 LOCAL_STATIC_LIBRARIES。
    <br> 不过 GNU Makefile 不会清除 LOCAL_PATH。此变量必须保留其值, 因为系统在单一 GNU Make 执行上下文（其中的所有变量都是全局变量）中解析所有构建控制文件。在描述每个模块之前，您必须声明（重新声明）此变量。
    <br> 使用方式 <code>include $(CLEAR_VARS)</code>

</li>
<li><strong>include $(BUILD_SHARED_LIBRARY)</strong>
    <br> 这一行会运行一个特殊的 Makefile 构建出该模块。
    <br> 该变量指向的文件在 <code>./build/make/core/shared_library.mk</code>
</li>

<li><strong>LOCAL_PATH</strong>
    <br> LOCAL_PATH 每个模块都在 Android.mk 里定义, 表示模块所在目录。
    <br> 此变量用于指定当前文件的路径。必须在 Android.mk 文件开头定义此变量。

</li>
<li><strong>LOCAL_MODULE</strong>
    <br> LOCAL_MODULE 此变量用于存储模块名称。 LOCAL_MODULE 将在每个模块的 makefile 里定义，如果未定义，编译系统会报错。
    <br> 指定的名称在所有模块名称中必须唯一，并且不得包含任何空格。
    <br> 您必须先定义该名称, 然后才能添加任何脚本 ( CLEAR_VARS 的脚本除外 )。
    <br> 无需添加 lib 前缀或 .so 或 .a 文件扩展名；构建系统会自动执行这些修改。
    <br> 在整个 Android.mk 和 Application.mk 文件中，请用未经修改的名称引用模块。
    <br> 如果您希望生成的模块使用除 "lib + LOCAL_MODULE 的值" 以外的名称，可以使用 LOCAL_MODULE_FILENAME 变量为生成的模块指定自己选择的名称。

</li>
<li><strong>LOCAL_MODULE_FILENAME </strong>
    <br> LOCAL_MODULE_FILENAME 此可选变量使您能够替换构建系统为其生成的文件默认使用的名称。
    <br> 

</li>
<li><strong>LOCAL_MODULE_TAGS</strong>
    <br> LOCAL_MODULE_TAGS 模块的 tag, 为 debug / eng / tests / optional / samples / shell_ash / shell_mksh 等 tag 的组合, 一个模块可有多个Tag。
    <ul>
    <li>user: 指该模块只在 user 版本下才编译</li>
    <li>eng: 指该模块只在 eng 版本下才编译</li>
    <li>tests: 指该模块只在 tests 版本下才编译</li>
    <li>optional: 指该模块在所有版本下都编译</li>
    </ul>
    <br> 如果某个模块没有通过 LOCAL_MODULE_TAGS 指定标记，则其标记默认设置为 optional。仅当 PRODUCT_PACKAGES 的产品配置需要可选模块时，系统才会安装可选模块。
    <br> 该变量在 <code>build/target/product/base.mk</code> 和 <code>build/target/product/core.mk</code> 里有赋值，这是所有产品都将继承的基础配置，
        另外每个设备可在自己的产品配置文件 <code>device_*.mk</code> 里设置该变量，添加更多的模块。
    <br> 如果当前目录或者父目录有*_GPL*的文件，那么将自动添加gnu的tag。

</li>
<li><strong>LOCAL_MODULE_CLASS</strong>
    <br> LOCAL_MODULE_CLASS 将用于决定编译时的中间文件存放的位置。其可选的值有：
        <code>RECOVERY_EXECUTABLES</code>,
        <code>UTILITY_EXECUTABLES</code>,
        <code>ETC</code>,
        <code>STATIC_LIBRARIES</code>,
        <code>EXECUTABLES</code>,
        <code>FAKE</code>,
        <code>JAVA_LIBRARIES</code>,
        <code>SHARED_LIBRARIES</code>,
        <code>APPS</code>

    <br> 使用该变量的过程可参考：<code>build/core/base_rules.mk</code>

</li>
<li><strong>LOCAL_PROPRIETARY_MODULE </strong>
    <br> Vendor 模块是特定于供应商的可执行文件或共享库（必须将这些模块安装到供应商分区中）。
    <br> 在 Android.bp 文件中，供应商模块必须将 vendor 或 proprietary 属性设为 true。
    <br> 在 Android.mk 文件中，供应商模块必须将 LOCAL_VENDOR_MODULE 或 LOCAL_PROPRIETARY_MODULE 设为 true。

</li>
<li><strong>LOCAL_MODULE_PATH</strong>
    <br> LOCAL_MODULE_PATH 表示模块生成的目标将最终存放的目录，也即目标的安装路径。
    <br> 使用该变量的过程可参考：<code>build/core/base_rules.mk</code>, 其常用取值有：
    <div class="tb_format">
        {
            "head": [ "原始表达式", "例子" ],
            "data": [
            [ "<code>TARGET_OUT_INTERMEDIATES := $(PRODUCT_OUT)/obj</code>", "out/target/product/i9100/obj" ],
            [ "<code>TARGET_OUT_HEADERS:= $(TARGET_OUT_INTERMEDIATES)/include</code>", "out/target/product/i9100/obj/include" ],
            [ "<code>TARGET_OUT_INTERMEDIATE_LIBRARIES := $(TARGET_OUT_INTERMEDIATES)/lib</code>", "out/target/product/i9100/obj/lib" ],
            [ "<code>TARGET_OUT_COMMON_INTERMEDIATES := $(TARGET_COMMON_OUT_ROOT)/obj</code>", "out/target/common/obj" ],
            [ "<code>TARGET_OUT := $(PRODUCT_OUT)/$(TARGET_COPY_OUT_SYSTEM)</code>", "out/target/product/i9100/system" ],
            [ "<code>TARGET_OUT_EXECUTABLES:= $(TARGET_OUT)/bin</code>", "out/target/product/i9100/system/bin" ],
            [ "<code>TARGET_OUT_OPTIONAL_EXECUTABLES:= $(TARGET_OUT)/xbin</code>", "out/target/product/i9100/system/xbin" ],
            [ "<code>TARGET_OUT_SHARED_LIBRARIES:= $(TARGET_OUT)/lib</code>", "out/target/product/i9100/system/lib" ],
            [ "<code>TARGET_OUT_JAVA_LIBRARIES:= $(TARGET_OUT)/framework</code>", "out/target/product/i9100/system/framework" ],
            [ "<code>TARGET_OUT_APPS:= $(TARGET_OUT)/app</code>", "out/target/product/i9100/system/app" ],
            [ "<code>TARGET_OUT_KEYLAYOUT := $(TARGET_OUT)/usr/keylayout</code>", "out/target/product/i9100/system/usr/keylayout" ],
            [ "<code>TARGET_OUT_KEYCHARS := $(TARGET_OUT)/usr/keychars</code>", "out/target/product/i9100/system/usr/keychars" ],
            [ "<code>TARGET_OUT_ETC := $(TARGET_OUT)/etc</code>", "out/target/product/i9100/system/etc" ],
            [ "<code>TARGET_OUT_NOTICE_FILES:=$(TARGET_OUT_INTERMEDIATES)/NOTICE_FILES</code>", "out/target/product/i9100/obj/NOTICE_FILES" ],
            [ "<code>TARGET_OUT_FAKE := $(PRODUCT_OUT)/fake_packages</code>", "out/target/product/i9100/fake_packages" ],
            [ "<code>TARGET_OUT_DATA := $(PRODUCT_OUT)/$(TARGET_COPY_OUT_DATA)</code>", "out/target/product/i9100/data" ],
            [ "<code>TARGET_OUT_DATA_EXECUTABLES:= $(TARGET_OUT_EXECUTABLES)</code>", "out/target/product/i9100/system/bin" ],
            [ "<code>TARGET_OUT_DATA_SHARED_LIBRARIES:= $(TARGET_OUT_SHARED_LIBRARIES)</code>", "out/target/product/i9100/system/lib" ],
            [ "<code>TARGET_OUT_DATA_JAVA_LIBRARIES:= $(TARGET_OUT_JAVA_LIBRARIES)</code>", "out/target/product/i9100/system/framework" ],
            [ "<code>TARGET_OUT_DATA_APPS:= $(TARGET_OUT_DATA)/app</code>", "out/target/product/i9100/data/app" ],
            [ "<code>TARGET_OUT_DATA_KEYLAYOUT := $(TARGET_OUT_KEYLAYOUT)</code>", "out/target/product/i9100/system/usr/keylayout" ],
            [ "<code>TARGET_OUT_DATA_KEYCHARS := $(TARGET_OUT_KEYCHARS)</code>", "out/target/product/i9100/system/usr/keychars" ],
            [ "<code>TARGET_OUT_DATA_ETC := $(TARGET_OUT_ETC)</code>", "out/target/product/i9100/system/etc" ],
            [ "<code>TARGET_OUT_DATA_NATIVE_TESTS := $(TARGET_OUT_DATA)/nativetest</code>", "out/target/product/i9100/data/nativetest" ],
            [ "<code>TARGET_OUT_CACHE := $(PRODUCT_OUT)/cache</code>", "out/target/product/i9100/cache" ],
            [ "<code>TARGET_OUT_VENDOR := $(PRODUCT_OUT)/$(TARGET_COPY_OUT_VENDOR)</code>", "out/target/product/i9100/system/vendor" ],
            [ "<code>TARGET_OUT_VENDOR_EXECUTABLES:= $(TARGET_OUT_VENDOR)/bin</code>", "out/target/product/i9100/system/vendor/bin" ],
            [ "<code>TARGET_OUT_VENDOR_OPTIONAL_EXECUTABLES:= $(TARGET_OUT_VENDOR)/xbin</code>", "out/target/product/i9100/system/vendor/xbin" ],
            [ "<code>TARGET_OUT_VENDOR_SHARED_LIBRARIES:= $(TARGET_OUT_VENDOR)/lib</code>", "out/target/product/i9100/system/vendor/lib" ],
            [ "<code>TARGET_OUT_VENDOR_JAVA_LIBRARIES:= $(TARGET_OUT_VENDOR)/framework</code>", "out/target/product/i9100/system/vendor/framework" ],
            [ "<code>TARGET_OUT_VENDOR_APPS:= $(TARGET_OUT_VENDOR)/app</code>", "out/target/product/i9100/system/vendor/app" ],
            [ "<code>TARGET_OUT_VENDOR_ETC := $(TARGET_OUT_VENDOR)/etc</code>", "out/target/product/i9100/system/vendor/etc" ],
            [ "<code>TARGET_OUT_UNSTRIPPED := $(PRODUCT_OUT)/symbols</code>", "out/target/product/i9100/system/symbols" ],
            [ "<code>TARGET_OUT_EXECUTABLES_UNSTRIPPED := $(TARGET_OUT_UNSTRIPPED)/system/bin</code>", "out/target/product/i9100/sysmbols/system/bin" ],
            [ "<code>TARGET_OUT_SHARED_LIBRARIES_UNSTRIPPED := $(TARGET_OUT_UNSTRIPPED)/system/lib</code>", "out/target/product/i9100/sysmbols/system/lib" ]
            ]
        }
    </div>


</li>
<li><strong>LOCAL_SRC_FILES</strong>
    <br> 该变量包含要建构到该模块中的 C 或者 C++ 源文件, 每一个文件用空格分隔
    <br> 请注意，您可以使用相对 ( 相对于 LOCAL_PATH ) 和绝对文件路径。不过应该避免使用绝对文件路径；相对路径可以提高 Android.mk 文件的移植性。
</li>
<li><strong>LOCAL_MODULE_RELATIVE_PATH</strong>
    <br> LOCAL_MODULE_RELATIVE_PATH 指定动态库的相对路径,以各自编译对象放置的目录为参考。
    <br> 通知编译系统来将一个模块放置到它的类型通常需要放到的目录的子目录下。
    <br> 比如: <code>LOCAL_MODULE_RELATIVE_PATH := ak</code>, 生成的库将会存在于 <code>xxx/ak/</code> 目录下, xxx 取决于 LOCAL_MODULE_PATH。

</li>
<li><strong>LOCAL_CPP_EXTENSION</strong>
    <br> 指定 .cpp 以外的文件扩展名。比如： <code>LOCAL_CPP_EXTENSION := .cxx .cpp .cc</code>

</li>
<li><strong>LOCAL_CPP_FEATURES</strong>
    <br> LOCAL_CPP_FEATURES 您可使用此可选变量指明您的代码依赖于特定 C++ 功能。
    <br> 它会在构建过程中启用正确的编译器标记和链接器标记。
    <br> 对于预构建的二进制文件，此变量还会声明二进制文件依赖于哪些功能，从而确保最终链接正常运行。
    <br> 我们建议您使用此变量，而不要直接在 LOCAL_CPPFLAGS 定义中启用 -frtti 和 -fexceptions。
    <br> 使用此变量可让构建系统对每个模块使用适当的标记。使用 LOCAL_CPPFLAGS 会导致编译器将所有指定的标记用于所有模块，而不管实际需求如何。
    <br> 比如: <code>LOCAL_CPP_FEATURES := rtti features</code>

</li>
<li><strong>LOCAL_C_INCLUDES</strong>
    <br> LOCAL_C_INCLUDES 您可使用此可选变量指定相对于 NDK root 目录的路径列表, 以便在编译所有源文件 ( C、C++ 和 Assembly ) 时添加到 include 搜索路径中。
        例如: <code>LOCAL_C_INCLUDES := $(LOCAL_PATH)/xxx/foo</code>
    <br> 请在通过 LOCAL_CFLAGS 或 LOCAL_CPPFLAGS 设置任何对应的包含标记前定义此变量。

</li>
<li><strong>LOCAL_CFLAGS</strong>
    <br> LOCAL_CFLAGS 此可选变量用于设置在构建 C 和 C++ 源文件时构建系统要传递的编译器标记。这样，您就可以指定额外的宏定义或编译选项。可以使用 LOCAL_CPPFLAGS 仅为 C++ 指定标记。
    <br> 请勿尝试在 Android.mk 文件中更改优化/调试级别。构建系统可以使用 Application.mk 文件中的相关信息自动处理此设置。这样，构建系统就可以生成供调试期间使用的有用数据文件。

</li>
<li><strong>LOCAL_CPPFLAGS</strong>
    <br> LOCAL_CPPFLAGS 只构建 C++ 源文件时将传递的一组可选编译器标记。

</li>
<li><strong>LOCAL_STATIC_LIBRARIES</strong>
    <br> LOCAL_STATIC_LIBRARIES 此变量用于存储当前模块依赖的静态库模块列表。
    <br> 如果当前模块是共享库或可执行文件，此变量将强制这些库链接到生成的二进制文件。
    <br> 如果当前模块是静态库，此变量只是指出依赖于当前模块的其他模块也会依赖于列出的库。

</li>
<li><strong>LOCAL_SHARED_LIBRARIES</strong>
    <br> LOCAL_SHARED_LIBRARIES 此变量会列出此模块在运行时依赖的共享库模块。
    <br> 此信息是链接时必需的信息，用于将相应的信息嵌入到生成的文件中。

</li>
<li><strong>LOCAL_WHOLE_STATIC_LIBRARIES</strong>
    <br> LOCAL_WHOLE_STATIC_LIBRARIES 此变量是 LOCAL_STATIC_LIBRARIES 的变体，表示链接器应将相关的库模块视为完整归档。如需详细了解完整归档，请参阅有关 --whole-archive 标记的 GNU Id 文档。
    <br> 多个静态库之间存在循环依赖关系时，此变量十分有用。使用此变量构建共享库时，它将强制构建系统将静态库中的所有对象文件添加到最终二进制文件。但是，生成可执行文件时不会发生这种情况。

</li>
<li><strong>LOCAL_LDLIBS</strong>
    <br> LOCAL_LDLIBS 此变量列出了在构建共享库或可执行文件时使用的额外链接器标记。
    <br> 利用此变量，您可使用 -l 前缀传递特定系统库的名称。比如: <code>LOCAL_LDLIBS := -lz</code>

</li>
<li><strong>LOCAL_LDFLAGS</strong>
    <br> LOCAL_LDFLAGS表示链接时用的参数，此变量列出了构建系统在构建共享库或可执行文件时使用的其他链接器标记。
    <br> 若要在 ARM/X86 上使用 ld.bfd 链接器可以添加该行 <code>LOCAL_LDFLAGS += -fuse-ld=bfd</code>

</li>
<li><strong>LOCAL_ALLOW_UNDEFINED_SYMBOLS</strong>
    <br> LOCAL_ALLOW_UNDEFINED_SYMBOLS 忽略链接错误，但是在运行中可能会出现错误，因为库文件找不到依赖的文件就会报错。
    <br> 默认情况下，如果构建系统在尝试构建共享库时遇到未定义的引用，将会抛出“未定义的符号”错误。此错误可帮助您捕获源代码中的错误。
    <br> 如需停用此检查，请将此变量设置为 true。请注意，此设置可能会导致共享库在运行时加载。

</li>
<li><strong>LOCAL_ARM_MODE</strong>
    <br> LOCAL_ARM_MODE 默认情况下，构建系统会以 thumb 模式生成 ARM 目标二进制文件，其中每条指令都是 16 位宽，并与 thumb/ 目录中的 STL 库链接。

</li>
<li><strong>LOCAL_MULTILIB</strong>
    <br> LOCAL_MULTILIB 可以指定特定模块编译32bit或64bit或都编译。
    <br> 默认值有 "both", "32", "64", "first", ""(由其他命令确定)

</li>
<li><strong>LOCAL_SDK_VERSION</strong>
    <br> 我也没找到该变量的具体说明，但目前从经验来看，该变量制指定的是当前编译 Android 的 SDK 版本。
    <br> 而且如果你编写了 JNI， 那么你必须指定该变量，否则编译的时候可能会报告 <code>jni.h not found</code>（出现在 Android 12 某芯片厂商的工程中）。
    <br> 一般赋值为 <code>current</code> 即可。
    <br> 其可选值有：<code>current</code>， <code>system_current</code>, <code>test_current</code>, <code>core_current</code>，以及具体的版本编号，
</li>
</ul>






<div class="head head_2">关于 Android.bp</div>





<div class="head head_2">APP 下的 gradle</div>
<p>
    大体框架如下：
</p>
<pre>
apply plugin: 'com.android.application'
android{
    compileSdkVersion xx
    defaultConfig {
        applicationId 'com.xxx.xxx'
        minSdkVersion xx
        targetSdkVersion xx
        versionCode X
        versionName xx

        externalNativeBuild{
            cmake {

            }
            // or
            ndkBuild {

            }

        }
    }

    buildTypes {
        release {

        }
        debug {
            minifyEnable true/false
            proguarFiles
        }
    }

    externalNativeBuild {
        cmake {
            path '.../CMakeLists.txt'
            version '3.xx.x'
        }
    }
}

dependencies {
  ...
}
</pre>


</div>








<div class="breadboard">
<div class="head head_1">Android init</div>
https://android.googlesource.com/platform/system/core/+/master/init/README.md
http://gityuan.com/2016/02/05/android-init/
https://segmentfault.com/a/1190000023184321
<p>
    init 程序的源码位于 <code>system/core/init</code> 中。而解析 init.rc 文件的函数入口为 <code>parse_config_file</code>。.rc 中的 service 信息会被存放在 server_list 中。
</p>
<p>
    Android Init 文件中主要存在五类对象： Actions、Commands、Services、Options 和 Imports。init 文件中可用 <code>#</code> 进行注释，并且可以使用 <code>${property.name}</code> 来使用系统属性
    （如：<code>import /init.recovery.${ro.hardware}.rc</code> ）。
</p>
<p>
    init 程序会在加载之后第一时间加载 <code>/system/etc/init/hw/init.rc</code> 中的配置，随后会加载 <code>/{system,system_ext,vendor,odm,product}/etc/init/</code> 中的 <code>.rc</code> 文件。
</p>
<p>
    其中，<code>/system/etc/init/</code> 中存放 Android 核心组件的一些启动配置文件；<code>/vendor/etc/init/</code> 用于存放厂商的核心 SoC 功能所需的操作或守护程序。
    而 <code>/odm/etc/init/</code> 目录则存放设备制造商的启动文件，如外设或者传感器的守护进程或初始化动作。
</p>
<p>
    Action 和 Service 指示一个 section 的开始，所有的命令或者选项都属于先前定义的最近一个 section , 第一个区块以前的命令和选项将会被忽略。
</p>
<p>
    另外 service 的名字必须被忽略，如果出现第二个同名的 service 名字，那么这个 service 将会被忽略，并且会答应 error 日志。
</p>
<p>
    之前对于 Legacy devices 没有 first stage mount 机制，因此可以在 mount_all 阶段去导入 init 脚本，但是在后续版本中该特性被作废了，并且不允许在 Q 之后启动设备。
</p>
<p>
    system / vendor / odm 分区的所有服务的可执行二进制文件或者脚本都应该在与之相关联的 .rc 文件都应该安装到所在分区的 <code>/etc/init</code> 目录中，并且每一个 .rc 文件应该包含其申明的服务的所有操作。
    文件可以申明在 Android.mk 的 <code>LOCAL_INIT_RC</code> 宏中，编译的时候会自动安装到相应的目录。Android.pb 的编译代码如下所示：
</p>
<pre>
prebuilt_etc {
    name: "init_recovery.rc",
    filename: "init.rc",
    src: "etc/init.rc",
    sub_dir: "init/hw",
    recovery: true,
}
</pre>
<p>
    一个 logcat 例子， logcat 的代码位于 <code>system/core/logcat</code> 目录， logcatd.rc 也在其中。
    在改目录下有一个  Android.mk 文件，文件中指定了 LOCAL_INIT_RC 宏，在编译的时候将 logcatd.rc 安装到 /system/etc/init 目录中。
    init 将在 mount_all 期间加载 logcatd.rc ，而其将会在系统启动过程的适当时机被执行。
</p>
<p>
    每个服务拥有自己 .rc 文件的方式优于以前一个大 init.rc 的方式，一方面在代码的管理方面，冲突会大大减少，另外 .rc 文件跟着工程走，这保证了我们可以非常方便的查找定位问题。 
</p>
<p>
    因为 APEX 会应用到多个 Android 主线版本上，此时不同版本的 init.rc 可能不一致，由此在 APEX 中以 init.#rc 的方式命名了各个不同版本的 init.rc 文件，其中 # 为支持的 SDK 版本号（比如 init.rc, init.32rc, init.35rc ）。
    而在编译的时候，编译器会找出最大的，最接近当前 SDK 版本的 init.rc 安装进去。(如果你的 SDK 为 32,33,34 则会选择 init.32rc, 而如果你的 SDK 版本 >= 35, 那么会选择 init.35rc)
</p>

<div class="head head_2">Actions</div>
<p>
    Action 是一系列指令的名字， Action 中有一个 trigger 字段，该字段标识该 action 在何时被调用。
    动作被添加到队列中并根据包含它们的文件被解析的顺序执行（参见 import 部分），然后在单个文件中按顺序执行。
</p>
<p>    
    Each action in the queue is dequeued in sequence and each command in that action is executed in sequence.
     Init handles other activities (device creation/destruction, property setting, process restarting) “between” the execution of the commands in activities.
</p>
<p>
    Action 的通用形式如下所示：
</p>
<pre>
on \trigger [&& \trigger]*
   \command
   \command
   \command
</pre>
<p>
    比如下面这个例子：
</p>
<pre>
on boot
   setprop a 1
   setprop b 2

on boot && property:true=true
   setprop c 1
   setprop d 2

on boot
   setprop e 1
   setprop f 2
</pre>
<p>
    当 属性 true 的值为 true 时，执行的顺序如下所示：
</p>
<pre>
    setprop a 1
    setprop b 2
    setprop c 1
    setprop d 2
    setprop e 1
    setprop f 2
</pre>

<div class="head head_2">Services</div>
<p>
    Services 是一个在开机时需要启动的一个程序，其可以指定是否在程序退出时，自动重启。 Service 的格式如下所示：
</p>
<pre>
service \name \pathname [ \argument ]*
   \option
   \option
   ...
</pre>

<div class="head head_2">Options</div>
<ul>
<li><strong>class $name [ $name\* ]</strong>
    <br> 指定服务的 classname 。
    <br> 属于同一 classname 的服务可以一起停止或者启动。如果没有指定 classname, 那么该服务默认属于 <code>default</code> classname, 
    <br> 一个 service 可以设置多个 classname, 除了第一个 classname 其他的 classname 用于对服务进行分组。
    <br> animation 类的 class 包括 启动和关闭动画所需的所有服务，这些服务在系统早期就被启动，并且可以运行到关机的最后阶段，
</li>
<li><strong>socket $name $type $perm [ $user [ $group [ $seclabel ] ] ]</strong>
    <br> 该选项将会创建一个 unix domain socket 给 init 脚本。位置在 <code>/dev/socket/name</code>
    <br> type 的值必须是 <code>dgram</code>， <code>stream</code>， <code>seqpacket</code> 这几个选项
    
    Create a UNIX domain socket named /dev/socket/name and pass its fd to the launched process. type must be “dgram”, “stream” or “seqpacket”. type may end with “+passcred” to enable SO_PASSCRED on the socket. User and group default to 0. ‘seclabel’ is the SELinux security context for the socket. It defaults to the service security context, as specified by seclabel or computed based on the service executable file security context. For native executables see libcutils android_get_control_socket().
</li>
</ul>

<div class="head head_2">参考文档</div>
<ul>
<li>
    <a href="https://android.googlesource.com/platform/system/core/+/master/init/README.md">Andrid init 官方说明文档。</a>
</li>
</ul>

</div>









<div class="breadboard">
<div class="head head_1">Service</div>
<p>
    了解 Service 你可能需要先了解 Binder, 这里有一篇解释 Binder 的文章写得还挺详细的：<a href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a>
</p>
<p>
    Android 的所有系统服务都在 <code>base/services/java/com/android/server/SystemServer.java</code> 中加载。
    <code>SystemServer.java</code> 中包含 java 的函数入口 <code>public static void main(String[] args)</code>, zygote 启动的时候会 fork 出 SystemServer 进程，在最后通过反射机制调用到了 <code>SystemServer.main()</code> 函数。
    SystemServer 类中的初始化过程如下所示: <code>SystemServer.main</code> -> <code>SystemServer.run</code> -> <code>startBootstrapServices(t) && startCoreServices(t) && startOtherServices(t)</code>。

    <span class="red_t">具体的 SystemServer 启动过程可以参考本章文后参考文档 3。</span>
</p>
<p>
    其中 Android 的 core service 包括， <code>SystemConfigService</code>, <code>BatteryService</code>, <code>UsageStatsService</code>, <code>WebViewUpdateService</code>, <code>CachedDeviceStateService</code>,
    <code>BinderCallsStatsService</code>, <code>LooperStatsService</code>, <code>RollbackManagerService</code>, <code>NativeTombstoneManagerService</code>, <code>BugreportManagerService</code>, <code>GpuService</code>。
    这些服务都是在 <code>startOtherServices</code> 函数中启动的。
</p>
<p>
    startOtherServices 中启动的 service 有： <code>KeyAttestationApplicationIdProviderService</code>, <code>KeyChainSystemService</code>, <code>SchedulingPolicyService</code>, <code>TelecomLoaderService</code>,
    <code>TelephonyRegistry</code>, <code>EntropyMixer</code>( 可能算不上 service ), <code>AccountManagerService$Lifecycle</code>, <code>ContentService$Lifecycle</code>, <code>DropBoxManagerService</code>,
    <code>RoleService</code>, <code>VibratorManagerService.Lifecycle</code>, <code>DynamicSystemService</code>, <code>ConsumerIrService</code>, <code>AlarmManagerService</code>, <code>InputManagerService</code>,
    <code>DeviceStateManagerService</code>, <code>CameraServiceProxy</code>, <code>WindowManagerService</code>, <code>VrManagerService</code>, <code>BluetoothService</code>, 
    <code>PinnerService</code>, <code>IorapForwardingService</code>, <code>ProfcollectForwardingService</code>, <code>AppIntegrityManagerService</code>,
    <code>MultiClientInputMethodManagerService.Lifecycle</code>, <code>InputMethodManagerService.Lifecycle</code>, <code>AccessibilityManagerService$Lifecycle</code>, <code>StorageManagerService$Lifecycle</code>,
    <code>StorageStatsService$Lifecycle</code>, <code>UiModeManagerService</code>, <code>LockSettingsService$Lifecycle</code>, <code>PersistentDataBlockService</code>, <code>TestHarnessModeService</code>,
    <code>OemLockService</code>, <code>DeviceIdleController</code>, <code>DevicePolicyManagerService</code>, <code>StatusBarManagerService</code>, <code>MusicRecognitionManagerService</code>,
    <code>SpeechRecognitionManagerService</code>, <code>AppPredictionManagerService</code>, <code>ContentSuggestionsManagerService</code>, <code>SearchUiManagerService</code>, <code>SmartspaceManagerService</code>,
    <code>FontManagerService.Lifecycle</code>, <code>TextServicesManagerService.Lifecycle</code>, 
    <code>SystemUpdateManagerService</code>,
    <code>UpdateLockService</code>, <code>RkDisplayDeviceManagementService</code>, <code>RkAudioSettingService</code>, <code>NotificationManagerService</code>, <code>DeviceStorageMonitorService</code>,
    <code>LocationManagerService</code>, <code>CountryDetectorService</code>, <code>TimeDetectorService$Lifecycle</code>, <code>TimeZoneDetectorService$Lifecycle</code>,
    <code>LocationTimeZoneManagerService$Lifecycle</code>, <code>GnssTimeUpdateService$Lifecycle</code>, <code>SearchManagerService$Lifecycle</code>, <code>WallpaperManagerService$Lifecycle</code>,
    <code>AudioService.Lifecycle</code>, <code>SoundTriggerMiddlewareService.Lifecycle</code>, <code>BroadcastRadioService</code>, <code>DockObserver</code>, <code>MidiService$Lifecycle</code>,
    <code>adb.AdbService$Lifecycle</code>, <code>usb.UsbService$Lifecycle</code>, <code>SerialService</code>, <code>HardwarePropertiesManagerService</code>, <code>TwilightService</code>,
    <code>ColorDisplayService</code>, <code>JobSchedulerService</code>, <code>SoundTriggerService</code>, <code>TrustManagerService</code>, <code>BackupManagerService$Lifecycle</code>,
    <code>appwidget.AppWidgetService</code>, <code>voiceinteraction.VoiceInteractionManagerService</code>, <code>apphibernation.AppHibernationService</code>, <code>GestureLauncherService</code>,
    <code>SensorNotificationService</code>, <code>ContextHubSystemService</code>, <code>DiskStatsService</code>, <code>RuntimeService</code>, <code>RulesManagerService$Lifecycle</code>,
    <code>NetworkTimeUpdateService</code>, <code>EmergencyAffordanceService</code>, <code>BlobStoreManagerService</code>, <code>DreamManagerService</code>, <code>GraphicsStatsService</code>,
    <code>CoverageService</code>, <code>PrintManagerService</code>, <code>CompanionDeviceManagerService</code>, <code>RestrictionsManagerService</code>, <code>MediaSessionService</code>, <code>HdmiControlService</code>,
    <code>TvInputManagerService</code>, <code>TunerResourceManagerService</code>, <code>MediaResourceMonitorService</code>, <code>TvRemoteService</code>, <code>MediaRouterService</code>, <code>FaceService</code>,
    <code>IrisService</code>, <code>FingerprintService</code>, <code>BiometricService</code>, <code>AuthService</code>, <code>BackgroundDexOptService</code>, <code>DynamicCodeLoggingService</code>,
    <code>PruneInstantAppsJobService</code>, <code>ShortcutService</code>, <code>LauncherAppsService</code>, <code>CrossProfileAppsService</code>, <code>PeopleService</code>, <code>MediaMetricsManagerService</code>,
    <code>SliceManagerService$Lifecycle</code>, <code>IoTSystemService</code>, <code>StatsCompanion$Lifecycle</code>, <code>RebootReadinessManagerService$Lifecycle</code>, <code>StatsPullAtomService</code>,
    <code>IncidentCompanionService</code>, <code>MmsServiceBroker</code>, <code>AutofillManagerService</code>, <code>TranslationManagerService</code>, <code>ClipboardService</code>, <code>AppBindingService.Lifecycle</code>,
    <code>TracingServiceProxy</code>, <code>PermissionPolicyService</code>, <code>R.array.config_deviceSpecificSystemServices</code> 中指定的服务, <code>GameManagerService$Lifecycle</code>,
    <code>uwb.UwbService</code>, <code>AppSearchManagerService</code>, <code>MediaCommunicationService</code>, <code>CarServiceHelperService</code>
</p>
<p>
    startOtherServices 中启动的和网络相关的 service 有： 
    <code>IpConnectivityMetrics</code>, <code>NetworkWatchlistService</code>, <code>NetworkManagementService</code>, <code>IpSecService</code>, <code>NetworkScoreService.Lifecycle</code>,
    <code>NetworkStatsService</code>,  <code>NetworkPolicyManagerService</code>, <code>wifi.WifiService</code>, <code>wifi.scanner.WifiScanningService</code>, <code>wifi.rtt.RttService</code>,
    <code>wifi.aware.WifiAwareService</code>, <code>wifi.p2p.WifiP2pService</code>, <code>lowpan.LowpanService</code>, <code>ethernet.EthernetService</code>, <code>PacProxyService</code>,
    <code>ConnectivityServiceInitializer</code>, <code>VpnManagerService</code>, <code>VcnManagementService</code>, <code>NsdService</code>, 
</p>
<p>
    startOtherServices 中启动的和手表相关的 service 有：<code>ThermalObserver</code>, 
    <code>MediaProjectionManagerService</code>, <code>WearPowerService</code>, <code>WearConnectivityService</code>, <code>WearDisplayService</code>,
    <code>WearTimeService</code>, <code>WearLeftyService</code>, <code>GlobalActionsService</code>
</p>

<div class="head head_2">publishBinderService 和 publishLocalService 区别</div>
<p>
    参考文档：<a href="https://blog.csdn.net/u010871962/article/details/120047716">publishBinderService和publishLocalService区别</a>
</p>
<p>
    摘要： 1. 通过 publishBinderService 方法发布的 Service 上层可以访问对应服务 Manager; 2. 通过 publishLocalService 方法发布的 Service, 上层不可以访问对应服务 Manager, 只能 System 进程访问。
</p>
<p>
    查看 Android 系统中启动的 service 可以使用： <code>service list</code>
</p>

<ul>
<li><strong>./frameworks/base/core/java/android/os/ServiceManager.java</strong>
    <br> <code>public static IBinder getService(String name)</code>
</li>
</ul>

<div class="head head_2">NetworkManagementService</div>
<p>
    NetworkManagementService 位于 <code>frameworks/base/services/core/java/com/android/server/NetworkManagementService.java</code> 位置。
</p>
<p>
    <code>framework/base/services/java/com/android/server/SystemServer.java</code> 在初始化的时候在 <code>private void startOtherServices(@NonNull TimingsTraceAndSlog t)</code> 函数会初始化网络相关服务，
    之后再初始化大多数基础模块之后会调用 <code>NetworkManagementService</code> 进行初始化。
    如下所示：
</p>
<pre>
    ...

    networkManagement = NetworkManagementService.create(context);
    ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
    ...
    final NetworkManagementService networkManagementF = networkManagement;
    ...
    if (networkManagementF != null) {
        networkManagementF.systemReady();
    }
</pre>
<p>
    SystemServer 调用 <code>NetworkManagementService.systemReady</code> 之后, <code>systemReady</code> 会调用 <code>private void prepareNativeDaemon()</code> 进行一系列的网络初始化工作。
</p>
<p>
    NetworkManagementService 继承自 <code>INetworkManagementService</code>, <code>INetworkManagementService</code> 定义于 <code>./frameworks/base/core/java/android/os/INetworkManagementService.aidl</code> 文件中。
</p>
<p>
    NetworkManagementService 提供的接口包括：注册监听网络事件接口； get/set/config 网络接口的接口； 对网络接口进行 IPV6 设置的接口； 操作共享网络的接口； 为 Uid 设置网络接口的权限； 设置防火墙的一些接口; ...
</p>
<p>
    如何打开 NetworkManagerService 的调试信息？方法之一是直接修改 <code>NetworkManagementService.java</code> 中 <code>DBG</code> 成员的值为 <code>true</code>。下面是一个自动编译安装的脚本。
</p>
<pre>
ssh ${PRJ_HOST} "cd ${PRJ_HOME}; source build/envsetup.sh; lunch ${PRJ_PLT}-userdebug; make services -j 32"
scp ${PRJ_HOST}:${PRJ_HOME}/out/target/product/${PRJ_PLT}/system/framework/services.jar /tmp/services.jar
adb root && adb remount && adb push /tmp/services.jar //system/framework/services.jar && adb shell sync && adb reboot
rm -rf /tmp/services.jar
</pre>


<div class="head head_2">参考文档</div>

<ol>
<li>
    <a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/framework/01_system_start.md">图解 Android 系列（一）揭秘 Android 系统启动过程</a>
</li>
<li>
    <a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/framework/02_init_zygote.md">图解 Android 系列（二）深入理解 init 与 zygote 进程</a>
</li>
<li>
    <a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/framework/03_system_server_01.md">图解 Android 系列（三）探索 SystemServer 进程创建过程</a>
</li>



</ol>

</div>    







<div class="breadboard">
<div class="head head_1">Android NetD</div>
<div class="head head_2">简介</div>
https://github.com/Dufre/Android-Settings-Ethernet
<p>
    Netd 是 Android 系统中专门负责网络管理和控制的后台 daemon 程序，主要三块功能。
</p>
<ul>
<li> 网络设置：
    设置防火墙 ( Firewall )、网络地址转换 ( NAT ) 、带宽控制、无线网卡软接入点 (Soft Access Point) 控制, 网络设备绑定 ( Tether ) 等。
</li>
<li> Android 系统中 DNS 信息的缓存和管理。
</li>
<li>服务：
    网络服务搜索 ( Net Service Discovery, 简称NSD ) 功能, 包括服务注册( Service Registration )、服务搜索( Service Browse )和服务名解析 ( Service Resolv )等。
</li>
</ul>

<p>
    Netd 启动的时候会创建这么几个 socket:
    netd / mdns -- Framework 层中的 NetworkManagementService 和 NsdService 将分别和 netd 及 mdns 监听 socket 建立链接并交互;
    dnsproxyd -- 每一个调用和域名解析相关的 socket API (如 getaddrinfo 或 gethostbyname 等) 的进程都会借由 dnsproxyd 监听 socket 与 netd 建立链接;
    fwmarkd -- fwmarkd 和底层 kernel 交互, 防火墙 firewall 会对进来的包做标记。
    如下所示：
</p>
<pre>
rk3588_firefly_itx_3588j:/system # cat etc/init/netd.rc
service netd /system/bin/netd
    class main
    capabilities CHOWN DAC_OVERRIDE DAC_READ_SEARCH FOWNER IPC_LOCK KILL NET_ADMIN NET_BIND_SERVICE NET_RAW SETUID SETGID
    socket dnsproxyd stream 0660 root inet
    socket mdns stream 0660 root system
    socket fwmarkd stream 0660 root inet
    onrestart restart zygote
    onrestart restart zygote_secondary
    # b/121354779: netd itself is not updatable, but on startup it dlopen()s the resolver library
    # from the DNS resolver APEX. Mark it as updatable so init won't start it until all APEX
    # packages are ready.
    updatable
</pre>

<p>
    Netd 接收并处理来自 Framework 层中 NetworkManagementService 或 NsdService 的命令。
    这些命令最终由 Netd 中对应的 Command 对象去处理。Net 接收并解析来自 Kernel 的 UEvent 消息, 然后再转发给 Framework 层中对应 Service 去处理。
</p>
<p>
    Netd 进程由 init 进程根据 init.rc 的对应配置项而启动。
</p>

<p>
    NetdService
</p>
<p>
    假定你已经熟悉 ServiceManager 相关知识，
    假定你已经熟悉基本的网络知识： ethnet, wifi, 七层架构，四层架构，路由，常规网络管理知识， IPV4/IPV6, DNS, DHCP ...
</p>

<ol>
<li><strong>./system/netd/server/binder/android/net/INetd.aidl</strong>
    <br> <code>./system/netd</code> 下定义了好几个版本的 INetd.aidl 请仔细甄别使用的是哪一个

</li>
<li><strong>./frameworks/base/services/net/java/android/net/util/NetdService.java</strong>
    <br> 返回 Netd service 实例： <code>final INetd netdInstance = INetd.Stub.asInterface(ServiceManager.getService(Context.NETD_SERVICE));</code>
</li>
<li><strong>./frameworks/libs/net/client-libs/netd/com/android/net/module/util/NetdUtils.java</strong>
    <br> 该类主要提供一些功能函数的封装，借由 netd 赖对 interface 进行一些基本的操作，其中包括： 获取和设置 interface 的配置 <code>getInterfaceConfigParcel</code> <code>setInterfaceConfig</code>,
         up/down interface <code>setInterfaceUp</code>, <code>setInterfaceDown</code>
</li>

<li><strong>./frameworks/opt/net/ethernet/java/com/android/server/ethernet/EthernetNetworkFactory.java</strong>
    <br> 提供操作 Ethnet 的一些基础函数，包括： <code>hasInterface</code>, <code>updateIpConfiguration</code>, <code>getIpAddress</code>, <code>getNetmask</code> ...
    <br> 其中 updateIpConfiguration 可以直接设置 Ethnet 的一些配置，比如说 DHCP
</li>

<li><strong>./frameworks/opt/net/ethernet/java/com/android/server/ethernet/EthernetTracker.java</strong>
    <br> 该类在创建之后调用 <code>void start()</code> 会调用 <code>mNMService.registerObserver(new InterfaceObserver());</code> 向 INetworkManagementService 注册 <code>BaseNetworkObserver</code> 观察者。
        该 Observer 主要用于监听网络的状态变化（如： <code>interfaceLinkStateChanged</code>, <code>interfaceAdded</code>, <code>interfaceRemoved</code> ）。
</li>


</ol>
<p>
    为解决的问题： framework 各个目录中 net 的关系是如何的
</p>

<div class="head head_2">NetD 小知识</div>
<ul>
<li><strong>netd 初始化防火墙</strong>
    <br> 初始化流程如下所示： <code>main.cpp / gCtls->init();</code> -> <code>Controllers.cpp / void Controllers::init()</code> -> <code>Controllers.cpp / initIptablesRules();</code>
    <br> 在 <code>initIptablesRules</code> 会初始化 <code>INPUT</code>, <code>FORWARD</code>, <code>PREROUTING</code>, <code>POSTROUTING</code>, <code>OUTPUT</code> 的子链
</li>
<li><strong>netd 添加客制化 iptables 规则</strong>
    <br> 可将对应的 iptables 的添加命令编写到 <code>/system/bin/oem-iptables-init.sh</code> 文件中，并同时赋予该文件的可读可执行权限
    <br> 需要注意的是，你需要确保该脚本执行成功，否则 netd 会清空所有的 oem 的设置，如下所示：
    <pre>
iptables -I  oem_fwd -p all -i eth0 -o eth1 -j ACCEPT; iptables -I  oem_fwd -p all -i eth1 -o eth0 -j ACCEPT;
exit 0
    </pre>
    <br> 另外，与 oem 相关的表有： <code>oem_fwd</code> / <code>oem_out</code>, 如果还要增加则要改 netd 中 <code>oem_iptables_hook.cpp</code> 部分代码。
</li>
</ul>


<div class="head head_2">netd 如何提供服务的</div>
<p>
    netd 的服务存在一个类 <code>class NetdNativeService</code>, 该类继承自 <code>public BinderService&lt;NetdNativeService&gt;, public BnNetd</code>, 也意味着它是一个 binder service。
</p>
<p>
    netd 启动的时候执行以下代码启动该服务:
</p>
<pre>
    if ((ret = NetdNativeService::start()) != android::OK) {                                                                                                                                                                                                                         ALOGE("Unable to start NetdNativeService: %d", ret);
        exit(1);
    }
</pre>

<div class="head head_2">netd 提供的服务</div>
<div class="head head_3">获取 interface List</div>
<p>
    调用路径如下所示：
    <code>@utf8InCpp String[] interfaceGetList();</code> -> <code>NetdNativeService::interfaceGetList</code> -> <code>InterfaceController::getIfaceNames</code> 。
</p>
<p>
    <code>InterfaceController::getIfaceNames</code> 会打开 <code>/sys/class/net</code> 目录，并查看该目录下的接口有哪些。并将这些接口存储到
    <code>std::vector<std::string> ifaceNames</code> 中，然后返回给调用者。
</p>
<div class="head head_3">获取某个 interface 的配置</div>
<p>
    调用路径如下所示：
    <code>InterfaceConfigurationParcel interfaceGetCfg(in @utf8InCpp String ifName);</code> -> <code>NetdNativeService::interfaceGetCfg</code> -> <code>InterfaceController::getCfg</code>。
</p>
<p>
    <code>InterfaceController::getCfg</code> 函数会获取到接口的 MAC 地址, IP 地址，掩码， UP/DOWN 等信息。为了获取这些信息，首先要打开一个 socket ( <code>socket(AF_INET, SOCK_DGRAM | SOCK_CLOEXEC, 0)</code> ),
    然后调用 <code>ioctl(fd, SIOCGIFHWADDR, &ifr)</code> 获取接口的硬件地址，调用 <code>ioctl(fd, SIOCGIFADDR, &ifr)</code> 获取接口的 IP 地址以及类型，调用 <code>ioctl(fd, SIOCGIFNETMASK, &ifr)</code> 获取接口掩码，
    调用 <code>ioctl(fd, SIOCGIFFLAGS, &ifr)</code> 获取目前接口状态，并通过检查 <code>IFF_UP</code> 查看接口是否被使能。同时还可以检查如下状态 <code>IFF_BROADCAST</code>, <code>IFF_LOOPBACK</code>, <code>IFF_POINTOPOINT</code>,
    <code>IFF_RUNNING</code>, <code>IFF_MULTICAST</code>。
</p>
<div class="head head_3">设置 interface</div>
<p>
    set 的接口和 get 的接口类似，调用流程如下所示：
    <code>void interfaceSetCfg(in InterfaceConfigurationParcel cfg)</code> -> <code>NetdNativeService::interfaceSetCfg</code> -> <code>InterfaceController::setCfg</code> 。
</p>
<p>
    set 的时候 ioctl 带的 request id 分别为， <code>SIOCSIFADDR</code> ( 设置 IP 地址 ). <code>SIOCSIFFLAGS</code> ( 将接口 UP or DOWN )。
</p>



<div class="head head_2">ndc</div>
<p>
    ndc 工具是属于 netd 的一部分，在调试 netd 的时候非常有帮助。 netd 工程地址在 <code>system/netd</code>。
</p>
<p>
    其中与 ndc 相关的配置在 <code>system/netd/server/Android.pb</code> 文件中，如下所示：
</p>
<pre>
cc_binary {
    name: "ndc",                                                                                                                                                                                                                                                                 defaults: ["netd_defaults"],
    include_dirs: [
        "system/netd/include",
    ],
    header_libs: [
        "libnetd_client_headers",
    ],
    shared_libs: [
        "libbase",
        "libnetdutils",
        "libnetutils",
        "libcutils",
        "liblog",
        "libutils",
        "libbinder",
        "dnsresolver_aidl_interface-V7-cpp",
        "netd_aidl_interface-V6-cpp",
    ],
    srcs: [
        "ndc.cpp",
        "UidRanges.cpp",
        "NdcDispatcher.cpp",
    ],
    sanitize: {
        cfi: true,
        memtag_heap: true,
    },
}
</pre>
<p>
    <code>server/ndc.cpp</code> 中包含了 ndc 的入口，如下所示。
</p>
<pre>
int main(int argc, char** argv){
    android::net::NdcDispatcher nd;
    exit(nd.dispatchCommand(argc - 1, argv + 1));
}
</pre>
<p>
    ndc 支持下表所列的一些指令。
    这些指令从 <code>server/NdcDispatcher.cpp</code> 注册到每一个指令的专属类中，这些类的定义在 <code>server/NdcDispatcher.h</code> 中。
    <code>ndc</code> 收到命令行输入的数据之后会直接调用 <code>NdcDispatcher::dispatchCommand</code> 方法，该方法会在注册到 <code>NdcDispatcher::mCommands</code> 的命令类中找到对应的命令类，
    并调用该命令类的 <code>NdcNetdCommand::runCommand</code> 将指令分发出去。
</p>
<p>
   <code>NdcNetdCommand</code> 为各个命令类的基类，每个派生类都会实现一次 <code>NdcDispatcher::_xxx_::runCommand</code>。
    而 <code>runCommand</code> 会负责检查参数的合法性，并调用 <code>sp&lt;INetd&gt; mNetd</code> 通过 binder 将要操作的指令发给 netd 去处理。
</p>
<div class="tb_format">
    {
        "head": [ "指令", "说明" ],
        "data": [
        [ "<code>interface</code>", "支持的指令有 <code>list</code>, <code>getcfg</code>, <code>setcfg</code>, <code>clearaddrs</code>, <code>ipv6privacyextensions</code>, <code>ipv6</code>, <code>enable</code>, <code>setmtu</code> " ],
        [ "<code>ipfwd</code>", "支持的指令有 <code>status</code>, <code>enable</code>, <code>add</code>, <code></code> " ],
        [ "<code>tether</code>", "支持的指令有 <code>stop</code>, <code>status</code>, <code>interface</code>, <code>start</code>, <code>dns</code>, <code></code> " ],
        [ "<code>nat</code>", "支持的指令有 <code>enable</code>, <code>disable</code> " ],
        [ "<code>bandwidth</code>", "支持的指令有 <code>removeiquota | riq</code>, <code>setiquota | siq</code>, <code>addnaughtyapps | ana</code>, <code>removenaughtyapps | rna</code>, <code>addniceapps | aha</code>, <code>removeniceapps | rha</code>, <code>setglobalalert | sga</code>, <code>setinterfacealert | sia</code>, <code>removeinterfacealert | ria</code> " ],
        [ "<code>idletimer</code>", "支持的指令有 <code>add</code>, <code>remove</code>  " ],
        [ "<code>firewall</code>", "支持的指令有 <code>enable</code>, <code>set_interface_rule</code>, <code>set_uid_rule</code>, <code>enable_chain</code>, <code>disable_chain</code> " ],
        [ "<code>clatd</code>", "支持的指令有 <code>stop</code>, <code>start</code> " ],
        [ "<code>strict</code>", "支持的指令有 <code>set_uid_cleartext_policy</code> " ],
        [ "<code>network</code>", "支持的指令有 <code>route</code>, <code>interface</code>, <code>create</code>, <code>destroy</code>, <code>default</code>, <code>permission</code>, <code>users</code>, <code>protect</code> " ]
        ]
    }
</div>
<p>
    下面是一些例子：
</p>
<ul>
<li><span>列举系统中存在的网络 interface</span>
    <code>ndc interface list</code>
</li>
<li><span>获取 eth0 的配置</span>
    <code>ndc interface getcfg eth0</code>
</li>
<li><span>配置 eth0 down</span>
    <code>ndc interface setcfg eth0 down</code>
</li>
<li><span>配置 eth0 up</span>
    <code>ndc interface setcfg eth0 up</code> or
    <code>ndc interface setcfg eth0 0.0.0.0 up</code>
</li>
</ul>

<div class="head head_2">关于 interface 的操作</div>
<p>

</p>


</div>    








<div class="breadboard">
<div class="head head_1">SELinux</div>
<div class="head head_2">简介</div>
<p>
    关于 SELinux 再 Android 中的简要介绍可以查看<a href="https://source.android.com/security/selinux">Android 官方关于 SELinux 的介绍</a>。
    AOSP 的 SELinux 仓库位于<a href="https://android.googlesource.com/platform/external/selinux/">https://android.googlesource.com/platform/external/selinux/</a>。
</p>
<p>
    如果想要查询 SELinux 的目的，架构，以及其他关于 SELinux 的一切，你可以查看 <a href="https://github.com/SELinuxProject/selinux-notebook">SELinux Notebook Github 工程</a>, 该工程介绍了：
</p>
<ul>
<li>
    SELinux 的宗旨。
</li>
<li>
    LSM / SELinux 架构、它的支持服务以及它们是如何在 GNU / Linux 中实现的。
</li>
<li>
    SELinux 网络、虚拟机、X-Windows、PostgreSQL 和 Apache/SELinux-Plus SELinux 感知功能。
</li>
<li>
    关于 SELinux 的核心策略语言，以及如何为研究目的构建基本政策模块。
</li>
<li>
    关于新的 Common Intermediate Language (CIL) 语言的实现介绍。
</li>
<li>
    SELinux 策略管理工具，以及其使用范例。
</li>
<li>
    参考的策略架构，它的支持服务以及如何实现的。
</li>
<li>
    SELinux 在 Android 中的集成方式。
</li>
</ul>
<p>
    如果想跳过简介直接查看 SELinux 相关的介绍资料可以访问该文档 <a href="https://github.com/SELinuxProject/selinux-notebook/blob/main/src/toc.md">https://github.com/SELinuxProject/selinux-notebook/blob/main/src/toc.md</a>。
</p>


<div class="head head_2">一些使用 SElinux 的场景</div>
<p>
    可以参考 <a href="https://source.android.com/security/selinux/implement#use_cases">Google 官方提供的参考用例</a> 查看。（非完备清单）
</p>

<div class="head head_2">一些经验</div>
<ul>
<li><strong>单独编译 SELinux policy</strong>
    <br> 在经过 <code>source build/envsetup.sh</code> 和 <code>lunch xxx-xxx</code> 之后 执行 <code>make selinux_policy</code> 即可单独编译 SELinux 的 Policy

</li>
<li><strong>如何查看进程和文件的安全标签</strong>
    <br> 查看进程的 SELinux 标签： <code>ps -Z</code>
    <br> 查看文件的 SELinux 标签： <code>ls -Z</code>
</li>
<li><strong>TE 文件格式的敏感性</strong>
    <br> 我们都知道 Windows 下的格式为 CRLF, 而 Linux 下位 LF, 我在编译的过程中发现 SElinux 的检查程序报告大量的 te 文件格式错误信息（如下所示），
        这时你可能需要注意一下，你的文件是否为 LF 格式的。如果不是你可能需要使用 IDE 工具（比如说 vscode ）将你的文件转换为 LF Unix 格式的。
        如果你是在 Linux 服务器中，你可以直接使用 <code>dos2unix</code> 进行文件格式转换。
</li>
<li><strong>Android 下脚本文件格式的敏感性</strong>
    <br> 如果你启用的服务是一个脚本，
</li>
<li><strong>对于 ioctl 的特殊性</strong>
    <br> 如果你的程序中使用了 ioctl 接口，即便你申明了访问 ioctl 的权限，那么你也同样会被内核报警告，如下所示：
    <pre>
# te 中存在的规则        
allow self_net self_net:udp_socket { create ioctl };

# 报告的警告
avc: denied { ioctl } for path="socket:[47164]" dev="sockfs" ino=47164 ioctlcmd=0x8914 scontext=u:object_r:self_net:s0 tcontext=u:object_r:self_net:s0 tclass=udp_socket permissive=1
avc: denied { ioctl } for path="socket:[50134]" dev="sockfs" ino=50134 ioctlcmd=0x8916 scontext=u:object_r:self_net:s0 tcontext=u:object_r:self_net:s0 tclass=udp_socket permissive=1
    </pre>
    <br> 这是因为 ioctl 能够操作的东西太多， SELinux 对其做了进一步的限制，因此你需要针对 ioctl 做出额外的规则申明，如下所示：
    <pre>
# te 中存在的规则    
allowxperm ak_net ak_net:udp_socket ioctl { 0x8914 0x8916 };
    </pre>

</li>
<li><strong>SELinux 的宏</strong>
    <br> 官方定义的宏函数在 <code>system/sepolicy/public/te_macros</code> 路径下，其他和平台相关的宏可以在 device 目录使用 <code>find -name "te_macros"</code> 进行搜索。
</li>
<li><strong>SELinux 一键脚本</strong>
    <pre>
#!/bin/bash

set -e

PRJ_HOST=l2
PRJ_HOME=./firefly

f_cp_selinux_server_2_device(){
	TEMP_F_NAME=/tmp/$$$$
	ssh ${PRJ_HOST} "cd ${PRJ_HOME}/out/target/product/rk3588_firefly_itx_3588j/ && ls $1"  | while read FILE
	do
		scp ${PRJ_HOST}:${PRJ_HOME}/out/target/product/rk3588_firefly_itx_3588j/$1/${FILE} ${TEMP_F_NAME}
		adb push ${TEMP_F_NAME} //$1/${FILE}
		rm -rf ${TEMP_F_NAME}
	done
}

adb root && adb remount
f_cp_selinux_server_2_device system/etc/selinux/mapping/
f_cp_selinux_server_2_device system/etc/selinux
f_cp_selinux_server_2_device vendor/etc/selinux
f_cp_selinux_server_2_device odm/etc/selinux
adb reboot
    </pre>

</li>
</ul>


<div class="head head_2">参考资料</div>
<ul>
<li><a href="https://blog.csdn.net/fanx9339/article/details/106897218">Android SELinux介绍和配置</a>
    <br> 简单介绍了 SELinux 的三种模式，如何开机关闭 SELinux, 如何查看进程以及 文件的 SELinux 权限，等等...
    <br> 文中对规则的解释我觉得非常形象，因此我摘抄到这里： <code>什么是规则？ 规则就是针对 domain 对象的，上面我们说过，每一个进程都属于一个 domain （域），
        规则就是设置哪个 domain （域）的对象（就是进程）能够对哪些 type （类型）的目标对象（文件或者属性或者设备）具有哪有操作（删除啊，访问啊等等），这就是规则！</code>
    <br> 补充一下其中提到的但是不是很详细的一些信息：
    <br> 1. uboot 的关闭 selinux 的地方一般在 uboot 的板级配置中， 即 <code>xxx_defconfig</code> 中； kernel 中关闭的地方在板级的 dts 配置中；
</li>
<li><strong><a href="https://blog.csdn.net/feelabclihu/article/details/117576092">SELinux 介绍</a></strong>
    <br> 本文介绍了 SELinux 的实现原理（简介），其中包括： SELinux 内部组成模块， SELinux 与 Linux 的关系， SELinux 与 Android 的关系；
        以及 Security Context ( 安全上下文 ) 中的一些概念的定义，比如， Type Enforcement (TE) / Multi-Level Security (MLS) / Subject / Object / Subject, Object 与 Process, File 之间的关系，等等。
    <br> 该文基本上信息都能从 <strong>SELinux Notebook</strong> 工程找到更加权威的解释，如果需要深入了解，建议还是仔细阅读 <strong>SELinux Notebook</strong> 工程。
</li>
</ul>

</div>












<div class="breadboard">
<div class="head head_1">其他</div>
<ul>
<li><strong>将 system 以读写的方式挂载</strong>
    <pre>
adb root 
adb disable-verity
adb reboot
adb root
adb remount
    </pre>

</li>


<li><strong>向 toybox 中添加我们所需支持的命令</strong>
    <ol>
    <li>
        工具在 external/toybox 中，打开 Android.bp 文件，找到你需要增加的命令（比如 brctl ），然后找到该命令关联的文件，find -name "brctl*" , 现在找到这个文件 brctl.c
    </li>
    <li>
        将该文件添加到 Android.bp 的 device_srcs 中 -- 注意添加的顺序，这里面的文件都按照字母顺序排序。
    </li>
    <li>
        并且在 toybox_symlinks 中加入 brctl ，让编译工具在编译的时候自动创建 brctl 这个软连接文件。
    </li>
    <li>
        检查 Android.bp 中 cc_defaults，可以观察到与 Android 相关的配置头文件在 android/device 路劲中。
    </li>
    <li>
        因此我们还要在 android/device 路径的 generated/config.h 中将我们想要的命令添加到 toybox 中。如下所示：
        <pre>
-#define CFG_BRCTL 0
-#define USE_BRCTL(...)
+#define CFG_BRCTL 1         // 使能 brctl
+#define USE_BRCTL(...) __VA_ARGS__         // 将 brctl 添加到 toybox 中
        </pre>
    </li>
    </ol>
</li>

<li><strong>向 Android 工程中加入一个我们自己的程序</strong>
    <br> 首先你需要将你的代码仓库迁移到 extern 目录，比如 <code>brctl-utils</code>。
    <br>  其次你需要为该仓库编写 <code>Android.bp</code> 文件。<code>Android.bp</code> 如何编写可以参考本章下面 <code>Android.bp</code> 小节。
    <br> 如果你想将 <code>brctl-utils</code> 编进你的平台中，你需要在你平台相应的 <code>AndroidBoard.mk</code> 中的 <code>PRODUCT_PACKAGES</code> 变量加上该 package 名称。
        文件可能在一个类似于这样 <code>device/rockchip/rk3588/xxx</code> 的路径中。
</li>

<li><strong>Android.bp 文件格式</strong>
    <br> 以模块类型开头，模块类型参考 <a href="https://ci.android.com/builds/submitted/8499938/linux/latest/view/soong_build.html">该文档</a>，
        每个模块类型中需要设置相应的属性，点击参考文档里面相应的模块类型可以跳转到该类型的更加详细的说明。
    <br> 如下是一个集成 brctl-utils 的例子：
    <pre>
all_srcs = [
    "libbridge/libbridge_devif.c",
    "libbridge/libbridge_misc.c",
    "libbridge/libbridge_init.c",
    "libbridge/libbridge_if.c",
    "brctl/brctl.c",
    "brctl/brctl_cmd.c",
    "brctl/brctl_disp.c",
]

cc_binary {
    name: "brctl",
    // defaults: ["brctl-defaults"],
    host_supported: true,
    // recovery_available: true,
    vendor_ramdisk_available: true,
    srcs: all_srcs,

    cflags: [
        "-Os",
        "-Wall",
        "-Werror",
        "-Wno-unused-parameter",
        "-Wno-unused-result",
    ],

    // cppflags: [],

    local_include_dirs: [
        "libbridge"
    ],

    // header_libs: [ ],
    // static_libs: [ ],
    // shared_libs: [ ],
    // export_include_dirs: [ ],

    target: {
        android: {
            // local_include_dirs: [],

            // shared_libs: [],

            // symlinks: [],
        },
    },
}
    </pre>
</li>
<li><strong>APEX</strong>

</li>

<li><strong>内存测试</strong>
    <br> <a href="https://github.com/stressapptest/stressapptest">stressapptest</a>
    <br> 

</li>

<li><strong>Java 语言 ublic, protected, private, 不加修饰符 的区别</strong>
    <br>
    <div class="tb_format">
        {
            "head": [ "修饰符", "类内部", "同个包（package）", "子类", "其他范围"  ],
            "data": [
                [ "public", "Y", "Y", "Y", "Y" ],
                [ "protected", "Y", "Y", "Y", "N" ],
                [ "无修饰符", "Y", "Y", "Y或者N(见说明)", "N" ],
                [ "private", "Y", "N", "N", "N" ]
            ]
        }
    </div>
    <!-- <table>
        <thead><tr><th>修饰符</th><th>类内部</th><th>同个包（package）</th><th>子类</th><th>其他范围</th></tr></thead>
        <tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
            <tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr>
            <tr><td>无修饰符</td><td>Y</td><td>Y</td><td>Y或者N(见说明)</td><td>N</td>
            </tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr></tbody></table> -->
    <br> 说明：需要特别说明“无修饰符”这个情况，子类能否访问父类中无修饰符的变量/方法，取决于子类的位置。如果子类和父类在同一个包中，那么子类可以访问父类中的无修饰符的变量/方法，否则不行。

</li>

<li><strong>Android 的启动流程</strong>
    <br> bootloader -> Linux 内核 -> init 进程 -> init 配置文件 -> zygote (JVM / JNI) -> SystemServer
    <br> SystemServer -> 开 Binder 线程池 + SystemServiceManager -> (AMS / WMS / PMS / CS / SS ...)
    <br>  AMS -> Lancher.java -> 
    <br> 应用启动： Lancher.java -> 冷启动/热启动 -> AMS -> Zygote ->fork -> ActivityThread.java
    <br>
    <br> init -> system/core/init -> init.cpp
    <br> init.rc -> system/core/rootdir
    <br> Android 的基础服务是从 init.zygote*.rc 配置中启动的
    <br> Lancher.java -> packages/apps/Lancher*
    <br> 冷启动用 Instramentation， 热启动用 bindler
    <br> AMS -> Instramentation -> Activity/fragment/application
    <br> <img src="https://images.cnblogs.com/cnblogs_com/mojies/2134079/o_220519153313_AndroidStartProcess.png" alt="" width=1000px class="img_center">
    
</li>

<li><strong>Android 加固</strong>
    <br> 加固种类： DEX 加固， SDK 加固，资源加固， SO 加固， H5 加固
    <br> SO 加固：代码/字符串加密，函数隐藏，动态加密，导入导出函数保护，防 HOOK ，对抗拖壳
    <br> 加固的方法： 

</li>

</ul>
</div>








<div class="breadboard">


</div>    














<div class="breadboard">
<div class="head head_1">参考文档</div>
<ul>
<li><strong>toybox</strong>
    <br> <a href="http://landley.net/toybox/about.html">busybox 的替代品， License 是 BSD 的。现在广泛应用于 Android 系统中。</a>
</li>
<li><strong>Beyond Linux® From Scratch (System V Edition)</strong>
    <br> <a href="https://www.linuxfromscratch.org/blfs/view/svn/index.html">一个与 Linux kernel 强相关的资源网站，拥有</a>
    <br> <a href="https://www.linuxfromscratch.org/blfs/view/svn/basicnet/basicnet.html">Networking</a> 是这个网站网络部分的资料，
         <a href="https://www.linuxfromscratch.org/blfs/view/svn/basicnet/netprogs.html">Networking Programs </a> 网络工具。
</li>
<li><strong>NetD</strong>
    <br> <a href="https://blog.csdn.net/love_xsq/article/details/77983969">android netd的工作流程解析</a>

</li>
<li><strong>工具</strong>
    <br> <a href="https://github.com/pxb1988/dex2jar">dex2jar</a>
    <br> <a href="https://android.googlesource.com/platform/art/+/master/dex2oat">dex2aot`</a>
    <br> <a href="https://www.oracle.com/java/technologies/visual-garbage-collection-monitoring-tool.html">VisualGC</a>  Visual Garbage Collection Monitoring Tool

</li>

<li><strong> <a href="https://androidperformance.com/">Android Tech And Perf</a>   </strong>
    <br> 本博客内容主要集中在 Android 开发和优化相关的话题，包括一些性能工具的使用、Android App 优化知识、Android Framework 知识讲解，
        性能理论知识讲解等，这里整理了一份目录供大家参考，大家可以挑感兴趣的部分来看。这里不仅仅包含博客中的内容，
        一些我在 知乎 或者 知识星球 的回答也会放到这里,不过这个目录里面放的都是我原创的博客，另外还收集了一些优秀文章 , 我也会不定期更新 Android 性能优化必知必会
</li>

<li><strong><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode">Android 技术笔记</a></strong>
    <br> 总结了非常多的 Android 工程的解读

</li>

<li><strong>Android 12 Google 对系统要求</strong>
    <br> <a href="https://source.android.com/compatibility/12/android-12-cdd.pdf">https://source.android.com/compatibility/12/android-12-cdd.pdf</a>
</li>

<li><strong>Android API</strong>
    <br> <a href="http://opensource.hcltechsw.com/volt-mx-native-function-docs/Android/android.net-Android-10.0/index.html#!/api">Documentation Android</a>
    <br> <a href="https://cs.android.com/">Android Code Search</a>
</li>

</ul>
</div>










<table><tr>
<td><img width="190" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_AliPay1.jpg" alt=""></td>
<td><img width="200" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_WeChatPa1.jpg" alt=""></td>
</tr></table>
<div class="div_2" id="AuthorizationWarning">
<div class="Text_ZZ">原创文章，版权所有，转载请获得作者本人允许并注明出处</div>
<div class="Text_LB">我是留白；我是留白；我是留白；（重要的事情说三遍）</div>
</div>
<div class="foot_panel" id="foot_panel">
    <div id="foot_panel_top" >
        <a href="#main_index" class="NoExternal">TOP</a>
    </div>
    <div id="foot_panel_bottom" >
        <a href="#AuthorizationWarning" class="NoExternal">BOT</a>
    </div>
</div>
</body>

<script src="js/PrePost.js"></script>
</html>
