<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title>C++ Effective</title>
</head>
<body>

<style id="style_area" >
a{
    text-decoration:none;
}
p{
    line-height: 1.4em;
    text-indent:2em;
    margin-top: 0;
    margin-bottom: 0;
    padding: 0.3em 0;
}
li{
    padding: 0.3em 0;
}
.gray-line{
    color:#F77;
    font-weight: 100;
    font-style: oblique;
    font-size: 0.8em;
}
code{
    line-height: 24px;
    border-bottom: rgb(253, 191, 186) solid 2px;
    margin: 3px 0.5em;
    padding: 2px;

    font-weight: 400;
    font-size: 12px;
    font-style: oblique;
    border-radius: 3px;
    backdrop-filter: blur(2px);
    color: rgb(231,76,60);
}
/* code{
    line-height: 20px;
    margin: 3px;
    padding: 2px;
    border-radius: 3px;
    color: #eb3f2f;
    font-weight: bold;
    font-size: 12px;
    margin: 3px;
    background-color:#f0f0f0;
    border-right: 1px solid #a9a9a9;
    border-bottom: 1px solid #a9a9a9;
    backdrop-filter: blur(2px);
} */
pre{
    border-radius: 4px;
    background-color: rgb(247,247,247,0.3);
    border: 1px solid #aaa;
    line-height: 1.182em;
    overflow: auto;
    font-size: 11px;
    padding: 16px;
    margin: 10px;
}
img{
    opacity:1;
    margin: 10px;
}
.breadboard{
    box-shadow: 0 1px 4px 0 rgba(0,0,0,0.37);
    margin: 5px 2% 45px;
    padding: 10px;
}

.head_index{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: center;
}
.head_1{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 4px #133152 solid;
    width: 99%;
    margin-top: 1.5em;
}
.head_2{
    color: #163a60;
    font-size: 25px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 2px #163a60 solid;
    width: 99%;
    margin-top: 1.25em;
}
.head_3{
    color: #1a426e;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.head_4{
    color: #1d4a7b;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.div_2{
    margin: 5px 2% 45px;
    padding: 40px;
    height: 100px;
    text-align: center;

}

.img_center{
    text-align: center;
}
.img_left{
    text-align: left;
    margin-left: 4em;
}
.note_msg{
    color: #eb3f2f;
    font-weight: 600;
}

.offset_1em{margin-left: 1em;}
.offset_2em{margin-left: 2em;}
.offset_3em{margin-left: 3em;}
.offset_4em{margin-left: 4em;}
.offset_5em{margin-left: 5em;}
.offset_6em{margin-left: 6em;}
.offset_7em{margin-left: 7em;}
.offset_8em{margin-left: 8em;}
.offset_9em{margin-left: 9em;}
.offset_10em{margin-left: 10em;}

.green_text{
    color: green;
}
.red_text{
    color: red;
}
.purple_text{
    color: purple;
}

.limit_window_size{
    /* overflow:auto; */
    max-height:30em;
    overflow-y:auto;
    word-wrap:break-word;
    word-break: normal;
    white-space: pre-wrap;
    margin:10px;
}

.child_red2_key li strong{
    color: red;
}
.child_red1_key li strong{
    color: red;
}
.child_red2_key li strong{
    color: #F77;
}
.child_red3_key li strong{
    color: #Faa;
}

.foot_panel{
    position:fixed;
    right:3em;
    bottom: 3em;
    width:6em;
    height:30px;
    padding:15px 5px 5px 15px;
    background-color:rgb( 157, 157, 157, 0.618 );
    border-radius: 8px;
}
#foot_panel_top{
    display: inline;
    border-right: 5px solid #eee;
}
#foot_panel_top a{
    width:4em;
}
#foot_panel_bottom {
    display: inline;
    margin-left: 5px;
}
#foot_panel_top a{
    width:4em;
}

#main_index li{
    line-height: 17px;
    font-size: 16px;
}
</style>




<div class="breadboard">
<div class="head_index">目录</div>
<div><ol id="main_index">
</ol></div>
</div>










<div class="breadboard">
<div class="head head_1">原则: 让自己习惯 C++</div>
<div>
    <strong>
        下列原则对应原文章的分类：
    </strong>
</div>
<ol>
<li>
    1-4： 让自己习惯 C++
</li>
<li>
    5-12： 构造/析构/赋值运算
</li>
<li>
    13-17：资源管理
</li>
<li>
    18-25： 设计与声明
</li>
<li>
    26-31：实现
</li>
<li>
    32-40：集成与面向对象设计
</li>
<li>
    41-48： 模板与泛型编程
</li>
<li>
    49-52：定制 new 与 delete
</li>
<li>
    53-55：杂项讨论
</li>
</ol>

<div>
    <strong>
        下面是具体的原则：
    </strong>
</div>
<ol>
<li><strong>将 C++ 看成联邦语言</strong>
    <br> C++ 大体上可看坐 C, C with class, Temeplate, STL 的一个集合
</li>

<li><strong>尽量使用 <code>const</code>, <code>enum</code>, <code>inline</code>, <code>template</code> 代替宏定义 </strong>
    <br> 主要有以下三个问题：
    <br> 1. 因为宏定义如果出现为题编译其很难定位问题点
    <br> 2. 其次宏定义是全局性的无法进行区域化
    <br> 3. 最后我们在设计宏定义表达式的时候很容易出问题
</li>

<li><strong>多用 const</strong>
    <br> const 语法虽然变化多端，但并不莫测高深。如果关键字 const 出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。
    <br> const 修饰的函数，返回的值也应该是 const 类型的
    <br> 如果一定要在 const 函数中修改成员，那么可以使用 <code>mutable</code> 修饰该成员。
</li>

<li><strong>确保所有的变量在使用前都初始化了</strong>
    <br> C part of C++ 类的变量不会确保初始化， non-C part of C++ 会确保初始化
    <br> 但你很难确保你记住这些规则，最好的方法就是在使用前先初始化所有变量。
    <br> 因为成员的初始化时更具申明的顺序来的，而不是根据初始化列表的顺序来的，这有时候会造成困惑，为了解决这种困惑，你应该尽量保证初始化列表中的顺序与类成员申明顺序一致。
    <br> static 对象时再程序退出的时候才会被销毁。（即静态变量的析构函数时程序退出时才会调用）
    <br> static 成员因为可能分布在程序中的任何位置，因此编译器要推断其合理的初始化顺序是几乎不可能的，因此一个消除这个问题的方法是将 non-local static 对象放到一个自己的专属函数内。
        这些函数返回一个支详该对象的 refrence 中。换句话说也就是 non-local static 被 local static 代替了。而 local static 对象会在“该函数被调用期间”“首次遇到该对象之定义式” 时被初始化。
        而这样又带来一个好处，如果该对象不被访问到，那么该变量的初始化永远不会被调用到（节省初始化资源消耗）。
    <br> 如果 static 对象在多线程中访问，有可能会产生初始化竞态，从而导致不可知的程序错误，消除这种问题的一种方式是在对象单线程状态时，逐个调用一下每个静态函数的 refrence-returning 函数。
</li>

<li><strong>了解 C++ 默默编写并调用了哪些函数</strong>
    <br> 如果你定义了一个类，即使你不对下列函数进行申明，但只要有人尝试调用它们，编译器会为你声明它们。这些函数有 default 构造函数, copy 构造函数, 析构函数, copy assignment 拷贝复制函数，如下所示：
<pre>
class Empty{
public:
    Empty();
    Empty(const Empty &);
    ~Empty();
    Empty & opterator=( const Empty & );
}
</pre>
    <br> non-static refrence 和 non-static const 对象都不能进行拷贝复制。
<pre>
main.cpp:6:7: error: non-static reference member ‘std::string& NameObject<int>::nameValue’, cannot use default assignment operator
main.cpp:6:7: error: non-static const member ‘const int NameObject<int>::objectValue’, cannot use default assignment operator
</pre>
    <br> non-static refrence 和 non-static const 只能在初始化列表进行初始化。
</li>

<li><strong>若不想使用编译器自动生成的函数，就该明确拒绝</strong>
    <br> 将拷贝函数和拷贝复制函数申明为私有函数并不足以在所有条件下禁用编译自动生成的函数，因为友元函数和成员函数还是可以调用到。
    <br> 而解决办法就是，在申明为似有函数的基础上，不去实现此类函数。
    <br> 当然也可以去继承下面的类：
<pre>
class Uncopyable{
protect:
    Uncopyable();
    ~Uncopyable();
private:
    Uncopyable(const Uncopyable &);
    Uncopyable &operator=(const Uncopyable &);

}
</pre>
</li>

<li><strong>为多态墓类声明 virtual 析构函数</strong>
    <br> 可能你将 new 的派生类给基类的指针，而在使用之后 delete 基类指针。此时如果基类析构函数为非虚函数，那么将会调用基类的析构函数，而不是派生类的析构函数。
    <br> 但是如果你将任何函数的析构函数都定义为虚函数，这会造成不必要的开销，因为一旦一个类中存在一个虚函数，则该类对象会存在一个析函数标指针。这将导致不必要的内存开销。
    <br> 此外 C++ 的很多内建类（比如 std::string ）的基类的析构函数都不是虚函数，因此如果你有类派生自这些内建类，千万要注意妥善的使用 delete。
</li>

<li><strong>到让异常逃离析构函数</strong>
    <br> 如果你有一个装在对象的容器，再容器销毁的时候，该容器中所有的对象的析构函数都应该被调用，而此时如果有异常发生，那么系统再同一时刻出现两个异常会导致导致意想不到的问题。
    <br> 而最好的办法是，不要让异常暴漏到析构函数之外。对此有两种操作：
    <br> 1. 捕获该异常，打印报错信息，退出程序
    <br> 2. 捕获该异常，打印报错信息，不让之继续传播（吞下异常）
    <br> 如果你在运行某个操作时候可能发生异常，那么最好的办法是，在析构函数之外简历一个操作函数，确保在析构之前该函数被调用，并将异常处理放在该函数内。
</li>

<li><strong>不要再构造和析构过程中调用 virtual 函数</strong>
    <br> 因为假设你的基类的构造函数内有调用虚函数，那么此时在你申明一个派生类的时候，构造函数内调用的虚函数并不是派生类里面的虚函数，而是基类里面的虚函数。这可能不是你意料中的。
</li>

<li><strong>让 <code>opterator=</code> 返回一个 <code>refrence to *this</code></strong>
    <br> 这是实现连锁赋值的必要条件 ( a=b=c )，也是 C++ 内建库的通用规则
    <br> 该规则同样适用于 <code>+=</code>, <code>-=</code>, <code>*=</code> 等等
</li>

<li><strong>在 <code>operator=</code> 中处理自我复制</strong>
    <br> 首先你得识别哪些是自我复制。第一种情况是指针和引用之间的复制，比如 <code>*a = *b;</code>, <code>ref_a = *b</code>, <code>a[n] = a[m]</code> ....
    <br> 如果拷贝构造和拷贝赋值是系统生成的，一般没有什么问题（虽然这种自我复制仅仅是在浪费资源）。
    <br> 但是一旦这两个函数是你自己编写的，那么很有可能因为你的疏忽导致非常严重的后果。比如下面这种情况：
<pre>
A &opterator=(const A &a){
    delete memp;
    memp = new mMem( *a.memp ); // a.memp 可能已经被自己释放
    return *this;
}
</pre>
    <br> 另外还一种情况时，当你的函数操作多个对象，而多个对象可能是同意对象的时候，要确保其行为依旧正确。 
</li>

<li><strong>复制对象时勿忘其每一个成员</strong>
    <br> 第一种情况是你编写了自己的拷贝函数，很完美，但后续你可能又为该类增加了一些成员，但在拷贝的时候又忘记了，像下面这种情况：
<pre>
class A{
    int b;
    int c; 后面添加的
public:
    A( A &a ){
        b = a.b
    }
}
</pre>
    <br> 还有一种情况是你继承了类 A, 但是忘记在你的拷贝函数中执行 A 的拷贝函数了。如下所示：
<pre>
class B : public A{
    int d;
public:
    B( B &b )
        :A( b )    // 千万不要忘记这一行
    {
        d = b,d

        A( b );    // 或者这一行
    }

    B & operator=( const B &b ){
        d = b,d
        
        A::operator=( b )    // 也不要忘记这一行
    }
}
</pre>
    <br> 另外，记住，不要在拷贝复制函数里面调用拷贝函数，也不要在拷贝函数里面调用拷贝复制函数，这会有意想不到的问题。
        比较好又比较通用的做法是，创建一个 private 通用函数 ( 比如为 init ) ，然后让拷贝构造函数和拷贝函数都调用这个函数 ( init );

</li>

<li><strong>以对象管理资源</strong>
    <br> 为了防止内存泄漏，（也就是你申请的指针忘记释放），C++ 准备了两种机制帮助你解决这一担忧，但这两种机制都有自己的限制，你需要仔细权衡。
    <br> 一个是 auto_ptr 一个是 tr1::share_ptr
    <br> 其中 auto_ptr 不能有多个 auto_ptr 指向同一指针。因为 auto_ptr 会在离开作用域，释放资源的时候调用析构函数 delete 掉申请的内存，如果有两个 auto_ptr 指向同一个指针，则会导致内存释放多次的异常情况。
    <br> 但这并不意味着你不可以将 auto_ptr A 赋值给 auto_ptr B, 在你赋值之后 auto_ptr A 指向的地址将会被设置为 NULL。
    <br> 另外一个就是引用计数型智慧指针 - RCSP - refrence-counting smart pointer -- tr1::share_ptr
    <br> share_ptr 会对指针的引用进行计数，当引用变为 0  的时候就会释放指向的内存，但也有该指针处理不了的情况，比如，两个 share_ptr 存在互指的情况。
    <br> 只要注意以上几点，share_ptr 还是能大大解放生产力的。
</li>

<li><strong>在资源管理类中提供对原始资源的访问</strong>
    <br> 你可能经常使用智能指针来管理你的内存资源，但可能有时候你会要使用到原始资源的部分。那么智能指针针对这种情况提供了 <code>get()</code> 方法。
        如果你想更加自然的使用，也可以使用含有隐式转换的 <code>-></code> 和 <code>*</code>。
    <br> 或者使用隐式转换
    <pre>
class A{
public:
    ...
    operator A() const{
        return origin_point;
    }
    ...
}
    </pre>
    <br> 但使用这种方法很容易导致指针的滥用，而智能指针又不能统计到这些资源的使用情况，这导致的情况就是，指针可能被释放，但还在其他地方被调用。
    <br> 因此如果遇到这种使用场景，那么最好的办法还是使用 <code>get()</code>, 至少你在使用的时候知道自己是获取了一个智能指针的原始资源。
    <br> 当然，如果你自己创建了一个资源管理类，你可能也需要考虑到这方面。
</li>

<li><strong>使用成对的 new 和 delete 时要采取相同形式</strong>
    <br> 因为编译器存在的差异，你使用 <code>new []</code> 创建的对象可能并不能使用 <code>delete</code> 进行删除，因为 <code>new</code> 和 <code>delete</code> 是配对的。
        而 <code>new []</code> 是和 <code>delete []</code> 配对的。
    <br> 而 typedef 定义式很容易掩盖原来的类型，因此在编写代码的时候很容易忘记这一点，因此我们不建议使用 typedef 来对数组数据类型来做 alias。
    <br> 另外一个方面，因为如果你在 class 内部使用指针规划成既可以指向数组，又可以指向普通对象，这时也要非常注意，在析构的时候需要妥善的做出处理。
    <br> 相反 C++ STL 中提供了非常多的特性来处理数组的情况，比如 <code>string</code>， <code>vector</code>
</li>·

<li><strong>以独立语句将 newd 对象置入智能指针</strong>
    <br> 加入有一个这样的两个函数：<code>int A();</code>, <code>void B( std::tr1::share_ptr&lt;C&gt; c, int a )</code>
    <br> 然后我们需要完成这样一个操作： <code>B( std::tr1::share_ptr&lt;C&gt;( new C ), A() )</code>
    <br> 但因为不同编译器的实现方式不同，<code>new C</code>, <code>std::tr1::share_ptr&lt;C&gt; c = </code>, <code>A()</code> 的调用顺序可能不一样
    <br> 加入 <code>A()</code> 如果存在异常的话，那么就有可能导致 <code>new C</code> 泄漏
    <br> 处理这种情况最妥善的办法就是将一二步骤独立出来，将上述表达式分成两个部分处理，如下所示：
    <pre>
std::tr1::share_ptr<C> c( new C );
B( c, A() );
    </pre>
</li>

</ol>

</div>


































<table><tr>
<td><img width="190" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_AliPay1.jpg" alt=""></td>
<td><img width="200" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_WeChatPa1.jpg" alt=""></td>
</tr></table>
<div class="div_2" id="AuthorizationWarning">
<div class="Text_ZZ">原创文章，版权所有，转载请获得作者本人允许并注明出处</div>
<div class="Text_LB">我是留白；我是留白；我是留白；（重要的事情说三遍）</div>
</div>
<div class="foot_panel" id="foot_panel">
    <div id="foot_panel_top" >
        <a href="#main_index" class="NoExternal">TOP</a>
    </div>
    <div id="foot_panel_bottom" >
        <a href="#AuthorizationWarning" class="NoExternal">BOT</a>
    </div>
</div>
</body>

<script src="../js/PrePost.js"></script>
</html>
