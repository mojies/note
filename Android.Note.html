<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title>Android 笔记</title>
</head>
<body>

<style id="style_area" >
a{
    text-decoration:none;
}
p{
    line-height: 1.4em;
    /* text-indent:2em; */
    margin-top: 0;
    margin-bottom: 0;
    padding: 0.3em 0;
}
li{
    padding: 0.3em 0;
}
.gray-line{
    color:#F77;
    font-weight: 100;
    font-style: oblique;
    font-size: 0.8em;
}
code{
    line-height: 24px;
    border-bottom: rgb(253, 191, 186) solid 2px;
    margin: 3px 0.5em;
    padding: 2px;

    font-weight: 400;
    font-size: 12px;
    font-style: oblique;
    border-radius: 3px;
    backdrop-filter: blur(2px);
    color: rgb(231,76,60);
}
/* code{
    line-height: 20px;
    margin: 3px;
    padding: 2px;
    border-radius: 3px;
    color: #eb3f2f;
    font-weight: bold;
    font-size: 12px;
    margin: 3px;
    background-color:#f0f0f0;
    border-right: 1px solid #a9a9a9;
    border-bottom: 1px solid #a9a9a9;
    backdrop-filter: blur(2px);
} */
pre{
    border-radius: 4px;
    background-color: rgb(247,247,247,0.3);
    border: 1px solid #aaa;
    line-height: 1.182em;
    overflow: auto;
    font-size: 11px;
    padding: 16px;
    margin: 10px;
}
img{
    opacity:1;
    margin: 10px;
}
.breadboard{
    box-shadow: 0 1px 4px 0 rgba(0,0,0,0.37);
    margin: 5px 2% 45px;
    padding: 10px;
}

.head_index{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: center;
}
.head_1{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 4px #133152 solid;
    width: 99%;
    margin-top: 1.5em;
}
.head_2{
    color: #163a60;
    font-size: 25px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 2px #163a60 solid;
    width: 99%;
    margin-top: 1.25em;
}
.head_3{
    color: #1a426e;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.head_4{
    color: #1d4a7b;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.div_2{
    margin: 5px 2% 45px;
    padding: 40px;
    height: 100px;
    text-align: center;

}

.img_center{
    text-align: center;
}
.img_left{
    text-align: left;
    margin-left: 4em;
}
.note_msg{
    color: #eb3f2f;
    font-weight: 600;
}

.offset_1em{margin-left: 1em;}
.offset_2em{margin-left: 2em;}
.offset_3em{margin-left: 3em;}
.offset_4em{margin-left: 4em;}
.offset_5em{margin-left: 5em;}
.offset_6em{margin-left: 6em;}
.offset_7em{margin-left: 7em;}
.offset_8em{margin-left: 8em;}
.offset_9em{margin-left: 9em;}
.offset_10em{margin-left: 10em;}

.green_text{
    color: green;
}
.red_text{
    color: red;
}
.purple_text{
    color: purple;
}

.limit_window_size{
    /* overflow:auto; */
    max-height:30em;
    overflow-y:auto;
    word-wrap:break-word;
    word-break: normal;
    white-space: pre-wrap;
    margin:10px;
}

.child_red2_key li strong{
    color: red;
}
.child_red1_key li strong{
    color: red;
}
.child_red2_key li strong{
    color: #F77;
}
.child_red3_key li strong{
    color: #Faa;
}

.foot_panel{
    position:fixed;
    right:3em;
    bottom: 3em;
    width:6em;
    height:30px;
    padding:15px 5px 5px 15px;
    background-color:rgb( 157, 157, 157, 0.618 );
    border-radius: 8px;
}
#foot_panel_top{
    display: inline;
    border-right: 5px solid #eee;
}
#foot_panel_top a{
    width:4em;
}
#foot_panel_bottom {
    display: inline;
    margin-left: 5px;
}
#foot_panel_top a{
    width:4em;
}

#main_index li{
    line-height: 17px;
    font-size: 16px;
}
</style>




<div class="breadboard">
<div class="head_index">目录</div>
<div><ol id="main_index">
</ol></div>
</div>












<div class="breadboard">
<div class="head head_1">基础</div>
<ul>
<li><strong>版本</strong>
    <br> Android 作業系統有預發行的內部版本，分別為原子小金剛（Astro）與機器人班亭（Bender，电视动画《乃出個未來》的角色）。
    從2009年5月開始，Android 的版本代號改以甜點來命名，且每個代號間的字首以英文字母序接續排列： Cupcake （紙杯蛋糕）、Donut（甜甜圈）、Eclair（閃電泡芙）、
    Froyo（優格冰淇淋）、Gingerbread（薑餅）、Honeycomb（蜂巢）[來源請求]、Ice Cream Sandwich（冰淇淋三明治）、Jelly Bean（雷根糖）、KitKat（奇巧巧克力）、
    Lollipop（棒棒糖）、Marshmallow（棉花糖）、Nougat（牛轧糖）、Oreo（奧利奧）、Pie（派）、Red Velvet Cake（11.0——紅色天鵝絨蛋糕）、Snow cone（12.0——杯套裝碎冰）。
    唯一不使用以甜品命名的版本為 Android 10，2019 年 8 月 23 日，Google 宣布從 Android Q 開始不再以甜品命名，且直接稱 Android Q 為 Android 10。 -- 摘自 WIKI-PEDIA 
    <br>  <img cllass="img_center" width="600px" src="https://images.cnblogs.com/cnblogs_com/mojies/2134079/o_220328160151_Android.version.png"/>
</li>

<li><strong>NDK 下载</strong>
    <br> NDK 的下载请访问：<a href="https://developer.android.com/ndk/downloads?hl=zh-cn">这里</a>。
</li>


</ul>
</div>










<div class="breadboard">
<div class="head head_1">Android stdio 开发</div>
<ul>

<li><strong>AndroidAPP 中指定 SDK and NDK</strong>
    <br> 工程 <code>local.properties</code> 文件中增加以下两行，其中路径该成你安装 SDK 和 NDK 的路径。
<pre>
sdk.dir=D\:\\AndroidSDK
ndk.dir=D\:\\AndroidSDK\\ndk\\24.0.8215888
</pre>

</li>

<li><strong>乱码</strong>
    <br> 方法1: <strong>双击 shift -> 搜索 <code>Edit Custom VM Options</code> -> 回车，没有则创建之 </strong>, 在打开的文件中加入配置： <code>-Dfile.encoding=UTF-8</code>, 然后 <strong>双击 shift -> 搜索 <code>restart IED</code> -> 回车 </strong>,
</li>

</ul>
</div>








<div class="breadboard">
<div class="head head_1">命令行工具</div>
<ul>
<li><strong>screencap 源码</strong>
    <br> 位置： <code>frameworks/base/cmds/screencap/</code>
</li>
<li><strong>dumpsys</strong>
    <br> 查询系统服务运行状态：命令格式 <code>dumpsys 服务名</code>, 服务名可以通过 <code>dumpsys -L</code> 或者 <code>service List</code> 查看。
    <br> 查看可以的 display <code>dumpsys SurfaceFlinger --display-id</code>
</li>
</ul>
</div>








<div class="breadboard">
<div class="head head_1">Android 系统编译框架</div>
<p>
    一般编译 Android 会首先要执行 <code>source build/envsetup.sh</code>, 该命令会将脚本中的一些脚本函数（操作流程）加载到当前的环境中。
    你可以通过直接调用函数名称来执行该过程。该脚本加载的函数包括：
</p>
<ul>
<li><strong>gettop</strong>（经常用到）
    <br> 获取当前工程的绝对路径
</li>
<li><strong>get_build_var</strong>（非常有用，有助于分析编译架构）
    <br> 获取某一个宏（变量 or 环境变量）对应对值。这个函数其实调用的是 <code>build/soong/soong_ui.bash --dumpvar-mode $1</code>。
    <br> 而 soong 则是变量 device 目录下的 <code>AndroidProducts.mk</code> 目录来获得该列表的。
</li>
<li><strong>hmm</strong>
    <br> 打印以下命令的帮助信息
</li>
<li><strong>lunch</strong>
    <br> 选择板级，你可以直接在该函数后带目标板级，也可以直接执行该函数。
    <br> 直接调用该函数之后，它会直接打印出当前 SDK 支持的板级，你选择好编号之后，也可选择初始化对应的板级。
    <br> 一般你在编译之前，都需要运行该命令，确定你编译的目标平台。
    <br> 执行完该命令之后，一般会设置下列几个主要的环境变量：<code>TARGET_PRODUCT</code>, <code>TARGET_BUILD_VARIANT</code>, <code>TARGET_PLATFORM_VERSION</code>
    <br> <code>BUILD_TYPE</code> 一般有三个可选的值： <code>user</code>， <code>userdebug</code>， <code>eng</code>。 其分别代表，开放给用限制权限的版本；带有开放 root 权限的可调式版本；带有开发工具/调试工具的版本。
</li>
<li><strong>tapas</strong>
    <br> 主要用于配置之前没有配置到板级中的应用。执行 <code>tapas</code> 或者 <code>hmm</code> 可以了解详情。
</li>
<li><strong>banchan</strong>
    <br> 和 tapas 类似，不过该命令用于配置模块。
</li>
<li><strong>croot</strong>
    <br> cd 到工程顶部目录。
</li>
<li><strong>m</strong>
    <br> 在 top 目录进行建构，其可指定特定的名称来建构指定模块
    <br> 这些名称在哪里找？
</li>
<li><strong>mm</strong> 和 <strong>mma</strong>
    构建当前目录中的工程
</li>
<li><strong>mmm</strong> 和 <strong>mmma</strong>
    构建和安装指定目录中的所有 modules 以及它们的依赖。可用 <code>mmm dir/:target1,target2</code> 来限制构建的对象。
</li>
<li><strong>provision</strong>
    Flash device with all required partitions. Options will be passed on to fastboot.
</li>
<li><strong>cgrep</strong>
    Greps on all local C/C++ files
</li>
<li><strong>ggrep</strong>
    Greps on all local Gradle files
</li>
<li><strong>gogrep</strong>
    Greps on all local Go files
</li>
<li><strong>jgrep</strong>
    Greps on all local Java files.
</li>
<li><strong>ktgrep</strong>
    Greps on all local Kotlin files
</li>
<li><strong>resgrep</strong>
    Greps on all local res/*.xml files
</li>
<li><strong>mangrep</strong>
    Greps on all local AndroidManifest.xml files
</li>
<li><strong>mgrep</strong>
    Greps on all local Makefiles and *.bp files
</li>
<li><strong>owngrep</strong>
    Greps on all local OWNERS files
</li>
<li><strong>rsgrep</strong>
    Greps on all local Rust files
</li>
<li><strong>sepgrep</strong>
    Greps on all local sepolicy files
</li>
<li><strong>sgrep</strong>
    Greps on all local source files
</li>
<li><strong>godir</strong>
    Go to the directory containing a file
</li>
<li><strong>allmod</strong>
    List all modules
</li>
<li><strong>gomod</strong>
    Go to the directory containing a module
</li>
<li><strong>pathmod</strong>
    Get the directory containing a module
</li>
<li><strong>outmod</strong>
    Gets the location of a module's installed outputs with a certain extension
</li>
<li><strong>dirmods</strong>
    Gets the modules defined in a given directory.
</li>
<li><strong>installmod</strong>
    Adb installs a module's built APK.
</li>
<li><strong>refreshmod</strong>
    Refresh list of modules for allmod/gomod/pathmod/outmod/installmod.
</li>
<li><strong>syswrite</strong>
    Remount partitions (e.g. system.img) as writable, rebooting if necessary
</li>

</ul>
<p>
    <code>envsetup.sh</code> 
</p>

<p>
    <code>TARGET_DEVICE_DIR</code> 保存当前板级编译配置的路径。
    比如我编译的板级为 <code>rk3588_firefly_itx_3588j-userdebug</code>， 那么 <code>TARGET_DEVICE_DIR</code> 的值为 <code>device/rockchip/rk3588/rk3588_firefly_itx_3588j</code>
</p>
</div>
    










<div class="breadboard">
<div class="head head_1">APP 下的 gradle</div>
<p>
    大体框架如下：
</p>
<pre>
apply plugin: 'com.android.application'
android{
    compileSdkVersion xx
    defaultConfig {
        applicationId 'com.xxx.xxx'
        minSdkVersion xx
        targetSdkVersion xx
        versionCode X
        versionName xx

        externalNativeBuild{
            cmake {

            }
            // or
            ndkBuild {

            }

        }
    }

    buildTypes {
        release {

        }
        debug {
            minifyEnable true/false
            proguarFiles
        }
    }

    externalNativeBuild {
        cmake {
            path '.../CMakeLists.txt'
            version '3.xx.x'
        }
    }
}

dependencies {
  ...
}
</pre>


<div class="head head_1">Android.mk</div>
<ul>
<li><strong>LOCAL_PATH := $(call my-dir)</strong>
    <br> LOCAL_PATH 将为当前 Android.mk 所在目录的位置
</li>
<li><strong>include $(CLEAR_VARS)</strong>
    <br> <code>CLEAR_VARS</code> 指向一个特殊的 Makefile（可能在这个路径 <code>./build/make/core/clear_vars.mk</code> ），该命令将会为你清除很多 <code>LOCAL_</code> 开头的变量
</li>
<li><strong>LOCAL_MODULE</strong>
    <br> 存储您要构建的模块的名称。在应用的每个模块中使用一次此变量，并且需要确保每一个模块明为唯一的，且不包含任何空格。
    <br> 构建系统在生成最终共享库文件时，会对您分配给 LOCAL_MODULE 的名称自动添加正确的前缀和后缀。比如如果是共享库，则会加上 <code>lib</code> 前缀和 <code>.so</code> 后缀。
</li>
<li><strong>LOCAL_SRC_FILES</strong>
    <br> 该变量包含要建构到该模块中的 C 或者 C++ 源文件
    <br> 每一个文件用空格分隔
</li>
<li><strong>include $(BUILD_SHARED_LIBRARY)</strong>
    <br> 这一行会运行一个特殊的 Makefile 构建出该模块。
    <br> 该变量指向的文件在 <code>./build/make/core/shared_library.mk</code>
</li>
<li><strong>LOCAL_SDK_VERSION</strong>
    <br> 我也没找到该变量的具体说明，但目前从经验来看，该变量制指定的是当前编译 Android 的 SDK 版本。
    <br> 而且如果你编写了 JNI， 那么你必须指定该变量，否则编译的时候可能会报告 <code>jni.h not found</code>（出现在 Android 12 某芯片厂商的工程中）。
    <br> 一般赋值为 <code>current</code> 即可。
    <br> 其可选值有：<code>current</code>， <code>system_current</code>, <code>test_current</code>, <code>core_current</code>，以及具体的版本编号，
</li>
</ul>
</div>








<div class="breadboard">
<div class="head head_1">Android init</div>
https://android.googlesource.com/platform/system/core/+/master/init/README.md
http://gityuan.com/2016/02/05/android-init/
https://segmentfault.com/a/1190000023184321
<p>
    init 程序的源码位于 <code>system/core/init</code> 中。而解析 init.rc 文件的函数入口为 <code>parse_config_file</code>。.rc 中的 service 信息会被存放在 server_list 中。
</p>
<p>
    Android Init 文件中主要存在五类对象： Actions、Commands、Services、Options 和 Imports。init 文件中可用 <code>#</code> 进行注释，并且可以使用 <code>${property.name}</code> 来使用系统属性
    （如：<code>import /init.recovery.${ro.hardware}.rc</code> ）。
</p>
<p>
    init 程序会在加载之后第一时间加载 <code>/system/etc/init/hw/init.rc</code> 中的配置，随后会加载 <code>/{system,system_ext,vendor,odm,product}/etc/init/</code> 中的 <code>.rc</code> 文件。
</p>
<p>
    其中，<code>/system/etc/init/</code> 中存放 Android 核心组件的一些启动配置文件；<code>/vendor/etc/init/</code> 用于存放厂商的核心 SoC 功能所需的操作或守护程序。
    而 <code>/odm/etc/init/</code> 目录则存放设备制造商的启动文件，如外设或者传感器的守护进程或初始化动作。
</p>
<p>
    Action 和 Service 指示一个 section 的开始，所有的命令或者选项都属于先前定义的最近一个 section , 第一个区块以前的命令和选项将会被忽略。
</p>
<p>
    另外 service 的名字必须被忽略，如果出现第二个同名的 service 名字，那么这个 service 将会被忽略，并且会答应 error 日志。
</p>
<p>
    之前对于 Legacy devices 没有 first stage mount 机制，因此可以在 mount_all 阶段去导入 init 脚本，但是在后续版本中该特性被作废了，并且不允许在 Q 之后启动设备。
</p>
<p>
    system / vendor / odm 分区的所有服务的可执行二进制文件或者脚本都应该在与之相关联的 .rc 文件都应该安装到所在分区的 <code>/etc/init</code> 目录中，并且每一个 .rc 文件应该包含其申明的服务的所有操作。
    文件可以申明在 Android.mk 的 <code>LOCAL_INIT_RC</code> 宏中，编译的时候会自动安装到相应的目录。Android.pb 的编译代码如下所示：
</p>
<pre>
prebuilt_etc {
    name: "init_recovery.rc",
    filename: "init.rc",
    src: "etc/init.rc",
    sub_dir: "init/hw",
    recovery: true,
}
</pre>
<p>
    一个 logcat 例子， logcat 的代码位于 <code>system/core/logcat</code> 目录， logcatd.rc 也在其中。
    在改目录下有一个  Android.mk 文件，文件中指定了 LOCAL_INIT_RC 宏，在编译的时候将 logcatd.rc 安装到 /system/etc/init 目录中。
    init 将在 mount_all 期间加载 logcatd.rc ，而其将会在系统启动过程的适当时机被执行。
</p>
<p>
    每个服务拥有自己 .rc 文件的方式优于以前一个大 init.rc 的方式，一方面在代码的管理方面，冲突会大大减少，另外 .rc 文件跟着工程走，这保证了我们可以非常方便的查找定位问题。 
</p>
<p>
    因为 APEX 会应用到多个 Android 主线版本上，此时不同版本的 init.rc 可能不一致，由此在 APEX 中以 init.#rc 的方式命名了各个不同版本的 init.rc 文件，其中 # 为支持的 SDK 版本号（比如 init.rc, init.32rc, init.35rc ）。
    而在编译的时候，编译器会找出最大的，最接近当前 SDK 版本的 init.rc 安装进去。(如果你的 SDK 为 32,33,34 则会选择 init.32rc, 而如果你的 SDK 版本 >= 35, 那么会选择 init.35rc)
</p>

<div class="head head_2">Actions</div>
<p>
    Action 是一系列指令的名字， Action 中有一个 trigger 字段，该字段标识该 action 在何时被调用。
    动作被添加到队列中并根据包含它们的文件被解析的顺序执行（参见 import 部分），然后在单个文件中按顺序执行。
</p>
<p>    
    Each action in the queue is dequeued in sequence and each command in that action is executed in sequence.
     Init handles other activities (device creation/destruction, property setting, process restarting) “between” the execution of the commands in activities.
</p>
<p>
    Action 的通用形式如下所示：
</p>
<pre>
on \trigger [&& \trigger]*
   \command
   \command
   \command
</pre>
<p>
    比如下面这个例子：
</p>
<pre>
on boot
   setprop a 1
   setprop b 2

on boot && property:true=true
   setprop c 1
   setprop d 2

on boot
   setprop e 1
   setprop f 2
</pre>
<p>
    当 属性 true 的值为 true 时，执行的顺序如下所示：
</p>
<pre>
    setprop a 1
    setprop b 2
    setprop c 1
    setprop d 2
    setprop e 1
    setprop f 2
</pre>

<div class="head head_2">Services</div>
<p>
    Services 是一个在开机时需要启动的一个程序，其可以指定是否在程序退出时，自动重启。 Service 的格式如下所示：
</p>
<pre>
service \name \pathname [ \argument ]*
   \option
   \option
   ...
</pre>

<div class="head head_2">Options</div>
<ul>
<li><strong>socket /name /type /perm [ /user [ /group [ /seclabel ] ] ]</strong>
    <br> 该选项将会创建一个 unix domain socket 给 init 脚本。位置在 <code>/dev/socket/name</code>
    <br> type 的值必须是 <code>dgram</code>， <code>stream</code>， <code>seqpacket</code> 这几个选项
    
    Create a UNIX domain socket named /dev/socket/name and pass its fd to the launched process. type must be “dgram”, “stream” or “seqpacket”. type may end with “+passcred” to enable SO_PASSCRED on the socket. User and group default to 0. ‘seclabel’ is the SELinux security context for the socket. It defaults to the service security context, as specified by seclabel or computed based on the service executable file security context. For native executables see libcutils android_get_control_socket().
</li>
</ul>

<div class="head head_2">参考文档</div>
<ul>
<li>
    <a href="https://android.googlesource.com/platform/system/core/+/master/init/README.md">Andrid init 官方说明文档。</a>
</li>
</ul>

</div>









<div class="breadboard">
<div class="head head_1">Service</div>
<p>
    了解 Service 你可能需要先了解 Binder, 这里有一篇解释 Binder 的文章写得还挺详细的：<a href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a>
</p>
<div class="head head_1">publishBinderService和publishLocalService区别</div>
<p>
    参考文档：<a href="https://blog.csdn.net/u010871962/article/details/120047716">publishBinderService和publishLocalService区别</a>
</p>
<p>
    摘要： 1. 通过 publishBinderService 方法发布的 Service 上层可以访问对应服务 Manager; 2. 通过 publishLocalService 方法发布的 Service, 上层不可以访问对应服务 Manager, 只能 System 进程访问。
</p>
<p>
    查看 Android 系统中启动的 service 可以使用： <code>service list</code>
</p>
<ul>
<li>

</li>
</ul>

<ul>
<li><strong>./frameworks/base/core/java/android/os/ServiceManager.java</strong>
    <br> <code>public static IBinder getService(String name)</code>
</li>
</ul>

</div>    







<div class="breadboard">
<div class="head head_1">Android NetD</div>
https://github.com/Dufre/Android-Settings-Ethernet
<p>
    Netd 是 Android 系统中专门负责网络管理和控制的后台 daemon 程序，主要三块功能。
</p>
<ul>
<li> 网络设置：
    设置防火墙 ( Firewall )、网络地址转换 ( NAT ) 、带宽控制、无线网卡软接入点 (Soft Access Point) 控制, 网络设备绑定 ( Tether ) 等。
</li>
<li> Android 系统中 DNS 信息的缓存和管理。
</li>
<li>服务：
    网络服务搜索 ( Net Service Discovery, 简称NSD ) 功能, 包括服务注册( Service Registration )、服务搜索( Service Browse )和服务名解析 ( Service Resolv )等。
</li>
</ul>

<p>
    Netd 启动的时候会创建这么几个 socket:
    netd / mdns -- Framework 层中的 NetworkManagementService 和 NsdService 将分别和 netd 及 mdns 监听 socket 建立链接并交互;
    dnsproxyd -- 每一个调用和域名解析相关的 socket API (如 getaddrinfo 或 gethostbyname 等) 的进程都会借由 dnsproxyd 监听 socket 与 netd 建立链接;
    fwmarkd -- fwmarkd 和底层 kernel 交互, 防火墙 firewall 会对进来的包做标记。
    如下所示：
</p>
<pre>
rk3588_firefly_itx_3588j:/system # cat etc/init/netd.rc
service netd /system/bin/netd
    class main
    capabilities CHOWN DAC_OVERRIDE DAC_READ_SEARCH FOWNER IPC_LOCK KILL NET_ADMIN NET_BIND_SERVICE NET_RAW SETUID SETGID
    socket dnsproxyd stream 0660 root inet
    socket mdns stream 0660 root system
    socket fwmarkd stream 0660 root inet
    onrestart restart zygote
    onrestart restart zygote_secondary
    # b/121354779: netd itself is not updatable, but on startup it dlopen()s the resolver library
    # from the DNS resolver APEX. Mark it as updatable so init won't start it until all APEX
    # packages are ready.
    updatable
</pre>

<p>
    Netd 接收并处理来自 Framework 层中 NetworkManagementService 或 NsdService 的命令。
    这些命令最终由 Netd 中对应的 Command 对象去处理。Net 接收并解析来自 Kernel 的 UEvent 消息, 然后再转发给 Framework 层中对应 Service 去处理。
</p>
<p>
    Netd 进程由 init 进程根据 init.rc 的对应配置项而启动。
</p>

<p>
    NetdService
</p>
<p>
    假定你已经熟悉 ServiceManager 相关知识，
    假定你已经熟悉基本的网络知识： ethnet, wifi, 七层架构，四层架构，路由，常规网络管理知识， IPV4/IPV6, DNS, DHCP ...
</p>

<ol>
<li><strong>./system/netd/server/binder/android/net/INetd.aidl</strong>
    <br> <code>./system/netd</code> 下定义了好几个版本的 INetd.aidl 请仔细甄别使用的是哪一个

</li>
<li><strong>./frameworks/base/services/net/java/android/net/util/NetdService.java</strong>
    <br> 返回 Netd service 实例： <code>final INetd netdInstance = INetd.Stub.asInterface(ServiceManager.getService(Context.NETD_SERVICE));</code>
</li>
<li><strong>./frameworks/libs/net/client-libs/netd/com/android/net/module/util/NetdUtils.java</strong>
    <br> 该类主要提供一些功能函数的封装，借由 netd 赖对 interface 进行一些基本的操作，其中包括： 获取和设置 interface 的配置 <code>getInterfaceConfigParcel</code> <code>setInterfaceConfig</code>,
         up/down interface <code>setInterfaceUp</code>, <code>setInterfaceDown</code>
</li>

<li><strong>./frameworks/opt/net/ethernet/java/com/android/server/ethernet/EthernetNetworkFactory.java</strong>
    <br> 提供操作 Ethnet 的一些基础函数，包括： <code>hasInterface</code>, <code>updateIpConfiguration</code>, <code>getIpAddress</code>, <code>getNetmask</code> ...
    <br> 其中 updateIpConfiguration 可以直接设置 Ethnet 的一些配置，比如说 DHCP
</li>

<li><strong>./frameworks/opt/net/ethernet/java/com/android/server/ethernet/EthernetTracker.java</strong>
    <br> 该类在创建之后调用 <code>void start()</code> 会调用 <code>mNMService.registerObserver(new InterfaceObserver());</code> 向 INetworkManagementService 注册 <code>BaseNetworkObserver</code> 观察者。
        该 Observer 主要用于监听网络的状态变化（如： <code>interfaceLinkStateChanged</code>, <code>interfaceAdded</code>, <code>interfaceRemoved</code> ）。
</li>


</ol>
<p>
    为解决的问题： framework 各个目录中 net 的关系是如何的
</p>

</div>    













<div class="breadboard">
<div class="head head_1">其他</div>
<ul>
<li><strong>将 system 以读写的方式挂载</strong>
    <pre>
adb root 
adb disable-verity
adb reboot
adb root
adb remount
    </pre>

</li>


<li><strong>向 toybox 中添加我们所需支持的命令</strong>
    <ol>
    <li>
        工具在 external/toybox 中，打开 Android.bp 文件，找到你需要增加的命令（比如 brctl ），然后找到该命令关联的文件，find -name "brctl*" , 现在找到这个文件 brctl.c
    </li>
    <li>
        将该文件添加到 Android.bp 的 device_srcs 中 -- 注意添加的顺序，这里面的文件都按照字母顺序排序。
    </li>
    <li>
        并且在 toybox_symlinks 中加入 brctl ，让编译工具在编译的时候自动创建 brctl 这个软连接文件。
    </li>
    <li>
        检查 Android.bp 中 cc_defaults，可以观察到与 Android 相关的配置头文件在 android/device 路劲中。
    </li>
    <li>
        因此我们还要在 android/device 路径的 generated/config.h 中将我们想要的命令添加到 toybox 中。如下所示：
        <pre>
-#define CFG_BRCTL 0
-#define USE_BRCTL(...)
+#define CFG_BRCTL 1         // 使能 brctl
+#define USE_BRCTL(...) __VA_ARGS__         // 将 brctl 添加到 toybox 中
        </pre>
    </li>
    </ol>
</li>

<li><strong>向 Android 工程中加入一个我们自己的程序</strong>
    <br> 首先你需要将你的代码仓库迁移到 extern 目录，比如 <code>brctl-utils</code>。
    <br>  其次你需要为该仓库编写 <code>Android.bp</code> 文件。<code>Android.bp</code> 如何编写可以参考本章下面 <code>Android.bp</code> 小节。
    <br> 如果你想将 <code>brctl-utils</code> 编进你的平台中，你需要在你平台相应的 <code>AndroidBoard.mk</code> 中的 <code>PRODUCT_PACKAGES</code> 变量加上该 package 名称。
        文件可能在一个类似于这样 <code>device/rockchip/rk3588/xxx</code> 的路径中。
</li>

<li><strong>Android.bp 文件格式</strong>
    <br> 以模块类型开头，模块类型参考 <a href="https://ci.android.com/builds/submitted/8499938/linux/latest/view/soong_build.html">该文档</a>，
        每个模块类型中需要设置相应的属性，点击参考文档里面相应的模块类型可以跳转到该类型的更加详细的说明。
    <br> 如下是一个集成 brctl-utils 的例子：
    <pre>
all_srcs = [
    "libbridge/libbridge_devif.c",
    "libbridge/libbridge_misc.c",
    "libbridge/libbridge_init.c",
    "libbridge/libbridge_if.c",
    "brctl/brctl.c",
    "brctl/brctl_cmd.c",
    "brctl/brctl_disp.c",
]

cc_binary {
    name: "brctl",
    // defaults: ["brctl-defaults"],
    host_supported: true,
    // recovery_available: true,
    vendor_ramdisk_available: true,
    srcs: all_srcs,

    cflags: [
        "-Os",
        "-Wall",
        "-Werror",
        "-Wno-unused-parameter",
        "-Wno-unused-result",
    ],

    // cppflags: [],

    local_include_dirs: [
        "libbridge"
    ],

    // header_libs: [ ],
    // static_libs: [ ],
    // shared_libs: [ ],
    // export_include_dirs: [ ],

    target: {
        android: {
            // local_include_dirs: [],

            // shared_libs: [],

            // symlinks: [],
        },
    },
}
    </pre>
</li>
<li><strong>APEX</strong>

</li>

<li><strong>内存测试</strong>
    <br> <a href="https://github.com/stressapptest/stressapptest">stressapptest</a>
    <br> 

</li>

<li><strong>Java 语言 ublic, protected, private, 不加修饰符 的区别</strong>
    <br>
    <table>
        <thead><tr><th>修饰符</th><th>类内部</th><th>同个包（package）</th><th>子类</th><th>其他范围</th></tr></thead>
        <tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
            <tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr>
            <tr><td>无修饰符</td><td>Y</td><td>Y</td><td>Y或者N(见说明)</td><td>N</td>
            </tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr></tbody></table>
    <br> 说明：需要特别说明“无修饰符”这个情况，子类能否访问父类中无修饰符的变量/方法，取决于子类的位置。如果子类和父类在同一个包中，那么子类可以访问父类中的无修饰符的变量/方法，否则不行。

</li>

<li><strong>Android 的启动流程</strong>
    <br> bootloader -> Linux 内核 -> init 进程 -> init 配置文件 -> zygote (JVM / JNI) -> SystemServer
    <br> SystemServer -> 开 Binder 线程池 + SystemServiceManager -> (AMS / WMS / PMS / CS / SS ...)
    <br>  AMS -> Lancher.java -> 
    <br> 应用启动： Lancher.java -> 冷启动/热启动 -> AMS -> Zygote ->fork -> ActivityThread.java
    <br>
    <br> init -> system/core/init -> init.cpp
    <br> init.rc -> system/core/rootdir
    <br> Android 的基础服务是从 init.zygote*.rc 配置中启动的
    <br> Lancher.java -> packages/apps/Lancher*
    <br> 冷启动用 Instramentation， 热启动用 bindler
    <br> AMS -> Instramentation -> Activity/fragment/application
    <br> <img src="https://images.cnblogs.com/cnblogs_com/mojies/2134079/o_220519153313_AndroidStartProcess.png" alt="" width=1000px class="img_center">
    
</li>
<li><strong>Android 的启动流程</strong>

</li>
<li><strong>Android 的启动流程</strong>

</li>
<li><strong>Android 的启动流程</strong>

</li>
<li><strong>Android 的启动流程</strong>

</li>

</ul>
</div>







<div class="breadboard">
<div class="head head_1">参考文档</div>
<ul>
<li><strong>toybox</strong>
    <br> <a href="http://landley.net/toybox/about.html">busybox 的替代品， License 是 BSD 的。现在广泛应用于 Android 系统中。</a>
</li>
<li><strong>Beyond Linux® From Scratch (System V Edition)</strong>
    <br> <a href="https://www.linuxfromscratch.org/blfs/view/svn/index.html">一个与 Linux kernel 强相关的资源网站，拥有</a>
    <br> <a href="https://www.linuxfromscratch.org/blfs/view/svn/basicnet/basicnet.html">Networking</a> 是这个网站网络部分的资料，
         <a href="https://www.linuxfromscratch.org/blfs/view/svn/basicnet/netprogs.html">Networking Programs </a> 网络工具。
</li>
<li><strong>NetD</strong>
    <br> <a href="https://blog.csdn.net/love_xsq/article/details/77983969">android netd的工作流程解析</a>

</li>
<li><strong>工具</strong>
    <br> <a href="https://github.com/pxb1988/dex2jar">dex2jar</a>
    <br> <a href="https://android.googlesource.com/platform/art/+/master/dex2oat">dex2aot`</a>
    <br> <a href="https://www.oracle.com/java/technologies/visual-garbage-collection-monitoring-tool.html">VisualGC</a>  Visual Garbage Collection Monitoring Tool

</li>

<li><strong> <a href="https://androidperformance.com/">Android Tech And Perf</a>   </strong>
    <br> 本博客内容主要集中在 Android 开发和优化相关的话题，包括一些性能工具的使用、Android App 优化知识、Android Framework 知识讲解，
        性能理论知识讲解等，这里整理了一份目录供大家参考，大家可以挑感兴趣的部分来看。这里不仅仅包含博客中的内容，
        一些我在 知乎 或者 知识星球 的回答也会放到这里,不过这个目录里面放的都是我原创的博客，另外还收集了一些优秀文章 , 我也会不定期更新 Android 性能优化必知必会
</li>

</ul>
</div>











<table><tr>
<td><img width="190" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_AliPay1.jpg" alt=""></td>
<td><img width="200" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_WeChatPa1.jpg" alt=""></td>
</tr></table>
<div class="div_2" id="AuthorizationWarning">
<div class="Text_ZZ">原创文章，版权所有，转载请获得作者本人允许并注明出处</div>
<div class="Text_LB">我是留白；我是留白；我是留白；（重要的事情说三遍）</div>
</div>
<div class="foot_panel" id="foot_panel">
    <div id="foot_panel_top" >
        <a href="#main_index" class="NoExternal">TOP</a>
    </div>
    <div id="foot_panel_bottom" >
        <a href="#AuthorizationWarning" class="NoExternal">BOT</a>
    </div>
</div>
</body>

<script src="../js/PrePost.js"></script>
</html>
