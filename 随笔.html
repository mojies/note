<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title>随笔</title>
 <!-- <script defer src="./js/katex.min.js" ></script> -->
 <link rel="stylesheet" href="katex/katex.min.css" >
 <link rel="stylesheet" href="js/bower_components/js-sequence-diagrams/dist/sequence-diagram-min.css"/>

 <script type="text/javascript" src="katex/katex.min.js" ></script>

 <script type="text/javascript" src="js/bower_components/bower-webfontloader/webfont.js"> </script>
 <script type="text/javascript" src="js/bower_components/snap.svg/dist/snap.svg-min.js"></script>
 <script type="text/javascript" src="js/bower_components/underscore/underscore-min.js"></script>
 <script type="text/javascript" src="js/bower_components/js-sequence-diagrams/dist/sequence-diagram-min.js"></script>

</head>
<body>

<style id="style_area" >
a{
    text-decoration:none;
}
p{
    line-height: 1.4em;
    /* text-indent:2em; */
    margin-top: 0;
    margin-bottom: 0;
    padding: 0.3em 0;
}
li{
    padding: 0.3em 0;
}
.gray-line{
    color:#F77;
    font-weight: 100;
    font-style: oblique;
    font-size: 0.8em;
}
code{
    line-height: 24px;
    border-bottom: rgb(253, 191, 186) solid 2px;
    margin: 3px 0.5em;
    padding: 2px;

    font-weight: 400;
    font-size: 12px;
    font-style: oblique;
    border-radius: 3px;
    backdrop-filter: blur(2px);
    color: rgb(231,76,60);
}
/* code{
    line-height: 20px;
    margin: 3px;
    padding: 2px;
    border-radius: 3px;
    color: #eb3f2f;
    font-weight: bold;
    font-size: 12px;
    margin: 3px;
    background-color:#f0f0f0;
    border-right: 1px solid #a9a9a9;
    border-bottom: 1px solid #a9a9a9;
    backdrop-filter: blur(2px);
} */
pre{
    border-radius: 4px;
    background-color: rgb(247,247,247,0.3);
    border: 1px solid #aaa;
    line-height: 1.182em;
    overflow: auto;
    font-size: 11px;
    padding: 16px;
    margin: 10px;
}
img{
    opacity:1;
    margin: 10px;
}
table, th, td {
    font-size: 12px;
    border: 1px solid #aaa;
    padding: 2px 0.5em;
    border-collapse: collapse;
}
th{
    font-size: 16px;
}
.breadboard{
    box-shadow: 0 1px 4px 0 rgba(0,0,0,0.37);
    margin: 5px 2% 45px;
    padding: 10px;
}

.head_index{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: center;
}
.head_1{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 4px #133152 solid;
    width: 99%;
    margin-top: 1.5em;
}
.head_2{
    color: #163a60;
    font-size: 25px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 2px #163a60 solid;
    width: 99%;
    margin-top: 1.25em;
}
.head_3{
    color: #1a426e;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.head_4{
    color: #1d4a7b;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.div_2{
    margin: 5px 2% 45px;
    padding: 40px;
    height: 100px;
    text-align: center;

}

.img_center{
    text-align: center;
}
.img_left{
    text-align: left;
    margin-left: 4em;
}
.note_msg{
    color: #eb3f2f;
    font-weight: 600;
}

.offset_1em{margin-left: 1em;}
.offset_2em{margin-left: 2em;}
.offset_3em{margin-left: 3em;}
.offset_4em{margin-left: 4em;}
.offset_5em{margin-left: 5em;}
.offset_6em{margin-left: 6em;}
.offset_7em{margin-left: 7em;}
.offset_8em{margin-left: 8em;}
.offset_9em{margin-left: 9em;}
.offset_10em{margin-left: 10em;}

.green_text{
    color: green;
}
.red_text{
    color: red;
}
.purple_text{
    color: purple;
}

.limit_window_size{
    /* overflow:auto; */
    max-height:30em;
    overflow-y:auto;
    word-wrap:break-word;
    word-break: normal;
    white-space: pre-wrap;
    margin:10px;
}

.child_red2_key li strong{
    color: red;
}
.child_red1_key li strong{
    color: red;
}
.child_red2_key li strong{
    color: #F77;
}
.child_red3_key li strong{
    color: #Faa;
}

.foot_panel{
    position:fixed;
    right:3em;
    bottom: 3em;
    width:6em;
    height:30px;
    padding:15px 5px 5px 15px;
    background-color:rgb( 157, 157, 157, 0.618 );
    border-radius: 8px;
}
#foot_panel_top{
    display: inline;
    border-right: 5px solid #eee;
}
#foot_panel_top a{
    width:4em;
}
#foot_panel_bottom {
    display: inline;
    margin-left: 5px;
}
#foot_panel_top a{
    width:4em;
}

#main_index li{
    line-height: 17px;
    font-size: 16px;
}
</style>




<div class="breadboard">
<div class="head_index">目录</div>
<div><ol id="main_index">
</ol></div>
</div>



<div class="fsd" id="diagram">
Andrew-China: Says Hello;
Note right of China: China thinks\nabout it;
China-->Andrew: How are you?;
Andrew->>China: I am good thanks!;
</div>










<div class="breadboard">
<div class="head head_1">编译相关</div>
<div class="head head_2">readelf</div>
<div class="head head_3">elf 文件格式</div>
<p>
    参考: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#:~:text=In%20computing%2C%20the%20Executable%20and,shared%20libraries%2C%20and%20core%20dumps. 
</p>

<div class="head head_3">readelf 支持的参数</div>
<p>
    参考：<code>man readelf</code>
</p>
<ul>
<li><code>-a, --all</code>
    <br> 相当于 -h -l -S -s -r -d -V -A -I 的集合
</li>

<li><code>-h, --file-header</code>
    <br> 显示 ELF 文件开始的文件头信息
</li>

<li><code>-l, --program-headers, --segments</code>
    <br> 显示 segments（段）头信息
</li>

<li><code>-S, --section-headers, --sections</code>
    <br> 显示 section 头信息
</li>

<li><code>-g, --section-groups</code>
    <br> 显示 section 的组信息
</li>

<li><code>-t, --section-details</code>
    <br> 显示 section 详细信息
</li>

<li><code>-e, --headers</code>
    <br> 显示全部头信息，相当于 -h -l -S
</li>

<li><code>-s, --syms, --symbols</code>
    <br> 包含静态符号表信息，显示符号表节信息，包含静态符号表信息 <code>.symtab</code>，和动态符号表信息 <code>.dynsym</code>。
    <br> 如果只关心动态符号表可以直接使用 <code>--dyn-syms</code> 
    <br> 如果符号有相应的版本信息，则会显示该版本信息
    <br> 版本字符串显示为符号名称的后缀，并以 @ 字符开头，例如 <code>foo@Ver_1</code>
    <br> 在解析未版本化引用的符号时，如果该版本是要使用的默认版本，则将显示为后缀，其后跟两个
</li>

<li><code>--dyn-syms</code>
    <br> 显示文件的动态符号表部分中的条目（如果有）。输出格式与 --syms 选项使用的格式相同。
</li>

<li><code>--lto-syms</code>
    <br> 显示文件中任何 LTO 符号表的内容。输出格式与 --syms 选项使用的格式相同。
</li>

<li><code>--sym-base=[0, 8, 10, 16]</code>
    <br> 强制符号表的大小字段使用给定的基数。
    <br> 任何无法识别的选项都将被视为“0”。
    <br> --sym-base=0 代表默认和旧的行为。 对于小于 100000 的数字，这会将大小输出为十进制。 对于大小 100000 和更大的十六进制符号，将使用 0x 前缀。
    <br> --sym-base=8 将以八进制给出符号大小。 --sym-base=10 将始终以十进制给出符号大小。 --sym-base=16 将始终以带有 0x 前缀的十六进制给出符号大小。
</li>

<li><code>--demangle=style, --no-demangle</code>
    <br> 将低级符号名称解码（解码）为用户级名称。 这使得 C++ 函数名称可读。 不同的编译器有不同的修饰风格。 可选的 demangling 样式参数可用于为您的编译器选择合适的 demangling 样式。
    <br> 参见 <a href="https://sourceware.org/binutils/docs/binutils/c_002b_002bfilt.html">c++filt</a> ，了解更多关于 demangling 的信息。 
</li>

<li><code>--quiet</code>
    <br> 禁止 “no symbols” 诊断。
</li>

<li><code>--recurse-limit, --no-recurse-limit, --recursion-limit, --no-recursion-limit</code>
    <br> 启用或禁用在对字符串进行分解时执行的递归量的限制。 由于名称修饰格式允许无限级别的递归，因此可以创建字符串，其解码将耗尽主机上可用的堆栈空间量，从而触发内存故障。 该限制试图通过将递归限制为 2048 级嵌套来防止这种情况发生。
    <br> 默认情况下启用此限制，但可能需要禁用它才能解开真正复杂的名称。 但是请注意，如果禁用递归限制，则可能会耗尽堆栈，并且任何有关此类事件的错误报告都将被拒绝。
</li>

<li><code>-U [d|i|l|e|x|h]</code> 或者 <code>--unicode=[default|invalid|locale|escape|hex|highlight]</code>
    <br> 控制标识符名称中非 ASCII 字符的显示。 默认（--unicode=locale 或--unicode=default）是将它们视为多字节字符并在当前语言环境中显示它们。
    <br> 此选项的所有其他版本将字节视为 UTF-8 编码值并尝试解释它们。 如果它们无法被解释或者如果使用了 --unicode=invalid 选项，那么它们将显示为十六进制字节序列，并用花括号括起来。
    <br> 使用 --unicode=escape 选项会将字符显示为 unicode 转义序列 (\uxxxx)。 使用 --unicode=hex 会将字符显示为用尖括号括起来的十六进制字节序列。
    <br> 使用 --unicode=highlight 会将字符显示为 unicode 转义序列，但它也会以红色突出显示它们，假设输出设备支持着色。 着色旨在提醒人们注意可能不存在的 unicode 序列。
    <br> 
</li>

<li><code>-n, --notes</code>
    <br> 显示 NOTE 段和/或部分的内容（如果有）。
</li>

<li><code>-r, --relocs</code>
    <br> 显示文件的重定位部分的内容（如果有的话）。
</li>

<li><code>-u, --unwind</code>
    <br> 显示文件展开部分的内容（如果有）。
    <br> 当前仅支持 IA64 ELF 文件的展开部分以及 ARM 展开表 (.ARM.exidx / .ARM.extab)。 如果您的架构尚未实现支持，您可以尝试使用 --debug-dump=frames 或 --debug-dump=frames-interp 选项转储 .eh_frames 部分的内容。
</li>

<li><code>-d, --dynamic</code>
    <br> 显示文件的动态部分的内容（如果有的话）。
</li>

<li><code>-V, --version-info</code>
    <br> 显示文件中版本部分的内容，（如果它们存在的话）。
</li>

<li><code>-A, --arch-specific</code>
    <br> 显示文件中特定于体系结构的信息（如果有）。
</li>

<li><code>-D, --use-dynamic</code>
    <br> 显示符号时，此选项使 readelf 使用文件动态部分中的符号哈希表，而不是符号表部分。
    <br> 显示重定位时，此选项使 readelf 显示动态重定位而不是静态重定位。
</li>

<li><code>-L, --lint, --enable-checks</code>
    <br> 显示有关正在检查的文件可能存在问题的警告消息。 如果单独使用，则将检查文件的所有内容。 如果与转储选项之一一起使用，则只会为正在显示的内容生成警告消息。
</li>

<li><code>-x &lt;number or name&gt;, --hex-dump=&lt;number or name&gt;</code>
    <br> 将指定部分的内容显示为十六进制字节。编号通过节表中的索引标识特定节；任何其他字符串标识目标文件中具有该名称的所有部分。
</li>

<li><code>-p &lt;number or name&gt;, --string-dump=&lt;number or name&gt;</code>
    <br> 将指定部分的内容显示为可打印字符串。编号通过节表中的索引标识特定节；任何其他字符串标识目标文件中具有该名称的所有部分。
</li>

<li><code>-R &lt;number or name&gt;, --relocated-dump=&lt;number or name&gt;</code>
    <br> 将指定部分的内容显示为十六进制字节。 编号通过节表中的索引标识特定节； 任何其他字符串标识目标文件中具有该名称的所有部分。 该部分的内容将在显示之前重新定位。
</li>

<li><code>-z, --decompress</code>
    <br> 请求由 x、R 或 p 选项转储的部分在显示之前解压缩。如果部分未压缩，则它们按原样显示。
</li>

<li><code>-c, --archive-index</code>
    <br> 显示包含在二进制归档文件头部分的文件符号索引信息。执行与 ar 的 t 命令相同的功能，但不使用 BFD 库。见 <a href="https://sourceware.org/binutils/docs/binutils/ar.html">ar</a>。
</li>

<li><code>-w[lLiaprmfFsoORtUuTgAck] </code> 或者 <code>--debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=str-offsets,=loc,=Ranges,=pubtypes,=trace_info,=trace_abbrev,=trace_aranges,=gdb_index,=addr,=cu_index,=links]</code>
    <br> 显示文件中 DWARF 调试部分的内容（如果存在）。 压缩的调试部分在显示之前会自动（临时）解压缩。 如果开关后面有一个或多个可选字母或单词，则只会转储那些类型的数据。 字母和单词指的是以下信息：
    <ul>
    <li><code>a</code>, <code>=abbrev</code>
        <br> 显示 “.debug_abbrev” 部分的内容。
        </li>
    <li><code>A</code>, <code>=addr</code>
        <br> 显示 “.debug_addr” 部分的内容。
        </li>
    <li><code>c</code>, <code>=cu_index  </code>
        <br> 显示 “.debug_cu_index” 和/或 “.debug_tu_index” 部分的内容。
        </li>
    <li><code>f</code>, <code>=frames</code>
        <br> 显示 “.debug_frame” 部分的原始内容。
        </li>
    <li><code>F</code>, <code>=frames-interp</code>
        <br> 显示 “.debug_frame” 部分的解释内容。
        </li>
    <li><code>g</code>, <code>=gdb_index</code>
        <br> 显示 “.gdb_index” 和/或 “.debug_names” 部分的内容。
        </li>
    <li><code>i</code>, <code>=info</code>
        <br> 显示 “.debug_info” 部分的内容。 注意：此选项的输出也可以通过使用 --dwarf-depth 和 --dwarf-start 选项来限制。
        </li>
    <li><code>k</code>, <code>=links</code>
        <br> 显示 “.gnu_debuglink”、 “.gnu_debugaltlink” 和 “.debug_sup” 部分的内容（如果存在）。 如果它们由 “.debug_info” 部分中的 DW_AT_GNU_dwo_name 或 DW_AT_dwo_name 属性指定，还显示指向单独的 dwarf 对象文件 (dwo) 的任何链接。
        </li>
    <li><code>K</code>, <code>=follow-links</code>
        <br> 显示在链接的单独调试信息文件中找到的任何选定调试部分的内容。 如果同一调试部分存在于多个文件中，这可能会导致显示多个版本。
        <br> 另外，在显示 DWARF 属性时，如果发现表单引用了单独的调试信息文件，那么也会显示引用的内容。
        <br> 注意 - 在某些发行版中，此选项默认启用。 它可以通过 N 调试选项禁用。 通过 --enable-follow-debug-links=yes 或 --enable-follow-debug-links=no 选项配置 binutils 时可以选择默认值。 如果不使用这些，则默认启用以下调试链接。
        </li>
    <li><code>N</code>, <code>=no-follow-links</code>
        <br> 禁用以下链接到单独的调试信息文件。
        </li>
    <li><code>l</code>, <code>=rawline</code>
        <br> 以原始格式显示“.debug_line”部分的内容。
        </li>
    <li><code>L</code>, <code>=decodedline</code>
        <br> 显示 “.debug_line” 部分的解释内容。
        </li>
    <li><code>m</code>, <code>=macro</code>
        <br> 显示 “.debug_macro” 和/或 “.debug_macinfo” 部分的内容。
        </li>
    <li><code>o</code>, <code>=loc</code>
        <br> 显示 “.debug_loc” 和/或 “.debug_loclists” 部分的内容。
        </li>
    <li><code>O</code>, <code>=str-offsets</code>
        <br> 显示 “.debug_str_offsets” 部分的内容。
        </li>
    <li><code>p</code>, <code>=pubnames</code>
        <br> 显示 “.debug_pubnames” 和/或 “.debug_gnu_pubnames” 部分的内容。
        </li>
    <li><code>r</code>, <code>=aranges</code>
        <br> 显示 “.debug_aranges” 部分的内容。
        </li>
    <li><code>R</code>, <code>=Ranges</code>
        <br> 显示 “.debug_ranges” 和/或 “.debug_rnglists” 部分的内容。
        </li>
    <li><code>s</code>, <code>=str</code>
        <br> 显示 “.debug_str”、“.debug_line_str” 和/或 “.debug_str_offsets” 部分的内容。
        </li>
    <li><code>t</code>, <code>=pubtype</code>
        <br> 显示 “.debug_pubtypes” 和/或 “.debug_gnu_pubtypes” 部分的内容。
        </li>
    <li><code>T</code>, <code>=trace_aranges</code>
        <br> 显示 “.trace_aranges” 部分的内容。
        </li>
    <li><code>u</code>, <code>=trace_abbrev</code>
        <br> 显示 “.trace_abbrev” 部分的内容。
        </li>
    <li><code>U</code>, <code>=trace_info</code>
        <br> 显示 “.trace_info” 部N分的内容。
        </li>
    </ul>
    <br> 注意：目前并不是所有平台都支持上面的这些指令。
</li>


<li><code>-P, --process-links</code>
    <br> 显示在链接到主文件的单独 debuginfo 文件中找到非调试部分的内容。此选项自动带 -wK 选项，并且仅显示其他命令行选项请求的部分。
</li>

<li><code>--dwarf-depth=n</code>
    <br> 将 .debug_info 部分的转储限制为 n 个子项。 这仅对 --debug-dump=info 有用。 默认打印所有DIE； n 的特殊值 0 也会产生这种效果。
    <br> 如果 n 为非零值，则不会打印 n 级或更深的 DIE。 n 的范围是从零开始的。
</li>

<li><code>--dwarf-start=n</code>
    <br> 仅打印以编号为 n 的 DIE 开头的 DIE。 这仅对 --debug-dump=info 有用。
    <br> 如果指定，此选项将禁止打印任何标题信息和编号为 n 的 DIE 之前的所有 DIE。 只会打印指定 DIE 的兄弟姐妹和孩子。
    <br> 这可以与 --dwarf-depth 结合使用。
</li>

<li><code>--ctf=section</code>
    <br> 显示指定 CTF 节的内容。 CTF 部分本身包含许多子部分，所有子部分都按顺序显示。
    <br> 默认情况下，显示名为 .ctf 的部分的名称，即 ld 发出的名称。
</li>

<li><code>--ctf-parent=section</code>
    <br> 如果 CTF 部分包含模糊定义的类型，它将包含许多 CTF 字典的存档，所有字典都继承自一个包含明确类型的字典。
    <br> 该成员默认命名为 .ctf，就像包含它的部分一样，但可以在链接时使用 ctf_link_set_memb_name_changer 函数更改此名称。
    <br> 当查看由使用名称更改器重命名父存档成员的链接器创建的 CTF 存档时，--ctf-parent 可用于指定用于父存档的名称。
</li>

<li><code>--ctf-symbols=section</code> and <code>--ctf-strings=section</code>
    <br> 指定 CTF 文件可以从中继承字符串和符号的另一个节的名称。 默认情况下，使用 .symtab 及其链接字符串表。
    <br> 如果指定了 --ctf-symbols 或 --ctf-strings 中的任何一个，则还必须指定另一个。
</li>

<li><code>-I, --histogram</code>
    <br> 在显示符号表的内容时显示桶列表长度的直方图。
</li>

<li><code>-v, --version</code>
    <br> 显示 readelf 的版本号。
</li>

<li><code>-W, --wide</code>
    <br> 不要打破输出行以适应 80 列。 默认情况下，readelf 会中断 64 位 ELF 文件的节标题和段列表行，以便它们适合 80 列。 此选项使 readelf 分别打印每个节标题。 每个段都是单行，在超过 80 列的终端上可读性更高。
</li>

<li><code>-T, --silent-truncation</code>
    <br> 通常，当 readelf 显示符号名称时，它必须截断名称以适应 80 列显示，它会在名称中添加 [...] 的后缀。 此命令行选项禁用此行为，允许再显示 5 个名称的字符并恢复 readelf 的旧行为（发布 2.35 之前）。
</li>

<li><code>-H, --help</code>
    <br> help info
</li>
</ul>
</div>










<div class="breadboard">
<div class="head head_1">DTS</div>
<div class="head head_2">DTS 是什么</div>
<div class="head head_2">DTS 如何在 Linux 中起作用的</div>
<div class="head head_2">DTS 如何编译出来的</div>
<div class="head head_2">DTS 存在 Linux 镜像的哪个位置</div>
<div class="head head_2">DTS 与 bootloader 的关系</div>
<div class="head head_2">DTS Linux 如何使用 DTS 中的配置</div>
<div class="head head_2">DTS 如何加载一个 DTS</div>

</div>











<div class="breadboard">
<div class="head head_1">网络相关</div>

<div class="head head_2">知识点</div>
<p>
    Netfilter
    IPSec
    ttl
    SCTP
    DCCP
    LTE
</p>
<ul>
<li><strong>ETH Protocol ID 在内核中的定义</strong>
    <br> 位置 <code>include/uapi/linux/if_ether.h</code>
    <br> 常用的一些定义有：
    <pre>
#define ETH_P_LOOP      0x0060          /* Ethernet Loopback packet     */
#define ETH_P_IP        0x0800          /* Internet Protocol packet     */
#define ETH_P_ARP       0x0806          /* Address Resolution packet    */
#define ETH_P_RARP      0x8035          /* Reverse Addr Res packet      */
#define ETH_P_8021Q     0x8100          /* 802.1Q VLAN Extended Header  */
#define ETH_P_IPX       0x8137          /* IPX over DIX                 */
#define ETH_P_IPV6      0x86DD          /* IPv6 over bluebook           */
    </pre>
</li>
<li><strong>WakeOnLine</strong>
    <br> WOL / LAN 是以太网的一个通过网络消息唤醒设备的机制
    <br> 消息通常由同一局域网的网络设备发起。当然也可以使用子网的定向广播或者 WoL 网关发起。
    <br> WoL 物理层通过识别 magic package 来判断是否有其他设备再唤醒本设备。包结构通常为 ( 6 * 0xFF + 16 * 唤醒机器的 MAC 地址 ) 总共 102 个字节。数据包通常以广播的方式发送出来。
    <br> WoL Magic 包发送有以下限制：
    <ul>
    <li>需要目标计算机的 MAC 地址（也可能需要 secure ON 的密码）</li>
    <li>不提供唤醒确认（被唤醒机器不提供应答）</li>
    <li>可能无法再本地网络之外工作</li>
    <li>需要目标计算机上的 LAN 硬件支持</li>
    <li>大多数 802.11 无线接口在低功耗状态下不维持链路并且无法接收魔术包</li>
    </ul>
    <br> 有时也可以通过 SDB （子网定向广播）将广播信号传播到子网的设备中。但也需要网关支持才行（可能会被过滤掉）。

    <br> Wake-on-LAN (WoL or WOL) is an Ethernet or Token Ring computer networking standard that allows a computer to be turned on or awakened by a network message.
    <br> The message is usually sent to the target computer by a program executed on a device connected to the same local area network.
        It is also possible to initiate the message from another network by using subnet directed broadcasts or a WoL gateway service.
    <br> Equivalent terms include wake on WAN, remote wake-up, power on by LAN, power up by LAN, resume by LAN, resume on LAN and wake up on LAN.
         If the computer being awakened is communicating via Wi-Fi, a supplementary standard called Wake on Wireless LAN (WoWLAN) must be employed.
    <br> The WoL and WoWLAN standards are often supplemented by vendors to provide protocol-transparent on-demand services, for example in the Apple Bonjour wake-on-demand (Sleep Proxy) feature.
    <br> <strong>Magic packet</strong> The magic packet is a frame that is most often sent as a broadcast and that contains anywhere within its payload 6 bytes of all 255 (FF FF FF FF FF FF in hexadecimal), 
        followed by sixteen repetitions of the target computer's 48-bit MAC address, for a total of 102 bytes.

</li>
</ul>


<div class="head head_2">proc 下和网络相关的一些配置</div>
<ul>
<li><strong>/proc/sys/net/ipv4/ip_forward</strong>
    <br> 设置 1 使能 ip_forward
    <br> Forward Packets between interfaces
    <br> 将此属性配置为 1 将导致所有的 <code>net.ipv4.conf.INTERFACE.forwarding</code> 都变成 1
</li>
<li><strong>net.ipv4.conf.INTERFACE.accept_local</strong>
    <br>
</li>
</ul>
https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt
https://sysctl-explorer.net/net/ipv4/
https://blog.csdn.net/wesleyflagon/article/details/80272696

<div class="head head_2">iperf3</div>
<div class="head head_3">介绍</div>
<p>
    iPerf3 是一种用于主动测量 IP 网络上可实现的最大带宽的工具。 它支持多种参数的调试，如 timing, buffers, protocols( TCP, UDP, IPv4 / IPv6 的 SCTP )。 
    对于每个测试，它都会报告带宽、丢包率和一些其他的参数。 这是一个新的实现，它与原始 iPerf 不共享任何代码，也不向后兼容。
    iPerf was orginally developed by NLANR/DAST. iPerf3 is principally developed by ESnet / Lawrence Berkeley National Laboratory. It is released under a three-clause BSD license。
    详细信息参考：
    <a href="https://iperf.fr/">iperf3 官网</a>
</p><p>
    iperf3 支持测试 TCP 的带宽, MSS/MTU, 另外还支持调整 socket buffer 和的窗口大小。对于 UDP, 支持测量带宽，丢包率, delay/jitter, 以及多播能力。
</p><p>
    其支持多种客户端可以直接再官网上下载 bin 文件或者自行编译： Windows, Linux, Android, MacOS X, FreeBSD, OpenBSD, NetBSD, VxWorks, Solaris,...
</p>

<div class="head head_2">参数列表</div>
<p>
    Linux 端支持的参数列表和 Windows 端支持的参数列表是不一样的，而这里仅仅支持常用的一些，对于各个平台的差异还请自己查询官方文档。
</p><p>
    下面介绍以 server 模式运行时的独有参数：
</p>
<ul>
<li><strong>-s</strong> / <strong>--server</strong>
    <br> 以 server 模式运行
</li>
<li><strong>-D</strong> / <strong>--daemon</strong>
    <br> 以 daemon 的形式与逆行 server
</li>
<li><strong>-1</strong> / <strong>--one-off</strong>
    <br> 处理完一个 client 之后就退出
</li>
</ul>

<p>
    下面介绍以 Client 模式运行时的独有参数：
</p>
<ul>
<li><strong>-c</strong> / <strong>--client</strong>
    <br> 以 client 模式运行，后指定 host 地址
</li>
<li><strong>-u</strong> / <strong>--udp</strong>
    <br> 测量 UDP 数据，否则测量 TCP 数据
</li>
<li><strong>-b</strong> / <strong>--bandwidth</strong>
    <br> 指定带宽，单位为 bits/seconds 
    <br> 可接受 [K/M/G] 单位（忽略大小写）
    <br> 如果不指定，默认 UDP 为 1M, TCP 无限制
    <br> 如果设置为 0 则代表不限制
    <br> 如果再 brust 模式，则可追加 [/#] 进行数据包计数
</li>
<li><strong>-t</strong> / <strong>--time</strong>
    <br> 指定测量事件，默认为 10s
    <br> 单位为 seconds
</li>
<li><strong>-n</strong> / <strong>--bytes</strong>
    <br> 指定总共传输多少个 byte , 该参数会覆盖 <code>-t</code>
    <br> 可接受 [K/M/G] 单位（忽略大小写）

</li>
<li><strong>-k</strong> / <strong>--blockcount</strong>
    <br> 指定传输多少个 blocks( packages )
    <br> 将会覆盖 <code>-t</code> 和 <code>-n</code> 两个参数
    <br> 可接受 [K/M/G] 单位（忽略大小写）
</li>
<li><strong>-l</strong> / <strong>--len</strong>
    <br> 指定读写 buffer
    <br> 默认 TCP 为 128KB, UDP 为 8KB
    <br> 可接受 [K/M/G] 单位（忽略大小写）
</li>
<li><strong>-cport</strong>
    <br> 指定绑定 client 端的端口
</li>
<li><strong>-P</strong> / <strong>--parallel</strong>
    <br> 指定并行运行的 client 数量
</li>
<li><strong>-R</strong> / <strong>--reservse</strong>
    <br> 工作在 server 发送 client 接收的模式
</li>
<li><strong>-w</strong> / <strong>--windwo</strong>
    <br> 指定窗口大小 / socket buffer size
    <br> 可接受 [K/M/G] 单位（忽略大小写）
</li>
<li><strong>-M</strong> / <strong>--set-mss</strong>
    <br> 指定 TCP/SCTO 的最大分段大小
</li>
<li><strong>-N</strong> / <strong>--no-delay</strong>
    <br> 设置 TCP/IP 的 no delay 模式， 禁止 Nagle's 算法
</li>
<li><strong>-4</strong> / <strong>--version4</strong>
    <br> only use IPv4
</li>
<li><strong>-6</strong> / <strong>--version6</strong>
    <br> only use IPv6
</li>
<li><strong>-S</strong> / <code>--tos</code>
    <br> 指定出战数据包的 `type-of-service` 字段（但注意，很多路由器会忽略这个字段）
    <br> IPTOS_LOWDELAY     minimize delay        0x10
    <br> IPTOS_THROUGHPUT   maximize throughput   0x08
    <br> IPTOS_RELIABILITY  maximize reliability  0x04
    <br> IPTOS_LOWCOST      minimize cost         0x02
</li>
<li><strong>-Z</strong> / <strong>--zerocopy</strong>
    <br> 使用零拷贝的方式来发送数据
</li>
<li><strong>-O</strong> / <strong>--omit</strong>
    <br> 忽略前 n 秒的数据
    <br> 主要跳过 TCP 的慢启动阶段
</li>
<li><strong>-T</strong> / <strong>--title</strong>
    <br> 给每一行测试数据加上前缀字符串
</li>
<li><strong>--get-server-output</strong>
    <br> 从 server 端获取测试结果
</li>
<li><strong>--udp-counters-64bit</strong>
    <br> 在 UDP 测试中使用 64bit 的计数器
</li>
</ul>

<p>
    下面介绍共有的一些参数：
</p>
<ul>
<li><strong>-v/--version</strong>
    <br> 展示版本号
</li>
<li><strong>-p</strong> / <strong>--port</strong>
    <br> 指定监听或者连接的端口
</li>
<li><strong>-f</strong> / <strong>--format</strong>
    <br> 报告格式
    <br> 可接受 [K/M/G] 单位（忽略大小写）
</li>
<li><strong>-i</strong> / <strong>--interval</strong>
    <br> 报告测试结果的间隔
    <br> 默认为 1 seconds
</li>
<li><strong>-F</strong> / <strong>--file</strong>
    <br> 指定发送或者接收的文件
</li>
<li><strong>-B</strong> / <strong>--bind</strong>
    <br> 指定绑定的 interface
</li>
<li><strong>-J</strong> / <strong>--json</strong>
    <br> 以 JSON 格式输出
</li>
</ul>

<div class="head head_2">使用方法</div>
<p>
    以下例子测试 TCP 传输性能，并在统计数据中去除前几秒的影响。
</p>
<pre>
// ---------------------------------------------------------------------------------> SERVER PART
pi@raspberrypi:~ $ iperf3 -s
-----------------------------------------------------------
Server listening on 5201
-----------------------------------------------------------

// ---------------------------------------------------------------------------------> CLIENT PART
$ ./iperf3.exe -c  172.16.20.74 -p 5201 -b 10M -O 3 --get-server-output
Connecting to host 172.16.20.74, port 5201
[  4] local 10.1.114.200 port 10908 connected to 172.16.20.74 port 5201
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.00   sec  1.25 MBytes  10.5 Mbits/sec                  (omitted)
[  4]   1.00-2.00   sec   512 KBytes  4.19 Mbits/sec                  (omitted)
[  4]   2.00-3.00   sec   384 KBytes  3.15 Mbits/sec                  (omitted)
[  4]   0.00-1.00   sec   512 KBytes  4.19 Mbits/sec
[  4]   1.00-2.00   sec   512 KBytes  4.19 Mbits/sec
[  4]   2.00-3.00   sec   512 KBytes  4.20 Mbits/sec
[  4]   3.00-4.00   sec   384 KBytes  3.14 Mbits/sec
[  4]   4.00-5.00   sec  0.00 Bytes  0.00 bits/sec
[  4]   5.00-6.00   sec   128 KBytes  1.05 Mbits/sec
[  4]   6.00-7.00   sec   512 KBytes  4.20 Mbits/sec
[  4]   7.00-8.00   sec   256 KBytes  2.10 Mbits/sec
[  4]   8.00-9.00   sec   896 KBytes  7.35 Mbits/sec
[  4]   9.00-10.00  sec   640 KBytes  5.24 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-10.00  sec  4.25 MBytes  3.56 Mbits/sec                  sender
[  4]   0.00-10.00  sec  4.17 MBytes  3.50 Mbits/sec                  receiver

Server output:
-----------------------------------------------------------
Server listening on 5201
-----------------------------------------------------------
Accepted connection from 10.1.114.200, port 10907
[  5] local 172.16.20.74 port 5201 connected to 10.1.114.200 port 10908
[ ID] Interval           Transfer     Bitrate
[  5]   0.00-1.00   sec  1.02 MBytes  8.53 Mbits/sec                  (omitted)
[  5]   1.00-2.00   sec   549 KBytes  4.49 Mbits/sec                  (omitted)
[  5]   2.00-3.00   sec   426 KBytes  3.49 Mbits/sec                  (omitted)
[  5]   0.00-1.00   sec   443 KBytes  3.63 Mbits/sec
[  5]   1.00-2.00   sec   492 KBytes  4.03 Mbits/sec
[  5]   2.00-3.00   sec   531 KBytes  4.34 Mbits/sec
[  5]   3.00-4.00   sec   369 KBytes  3.03 Mbits/sec
[  5]   4.00-5.00   sec  62.7 KBytes   514 Kbits/sec
[  5]   5.00-6.00   sec   118 KBytes   969 Kbits/sec
[  5]   6.00-7.00   sec   590 KBytes  4.84 Mbits/sec
[  5]   7.00-8.00   sec   171 KBytes  1.40 Mbits/sec
[  5]   8.00-9.00   sec   909 KBytes  7.44 Mbits/sec
[  5]   9.00-10.00  sec   580 KBytes  4.75 Mbits/sec
[  5]  10.00-10.08  sec  4.28 KBytes   436 Kbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate
[  5]   0.00-10.08  sec  4.17 MBytes  3.47 Mbits/sec                  receiver


iperf Done.
</pre>
<p>
    下面的例子用于测试 UDP 传输性能，并评估环境中的丢包率：
</p>
<pre>
$ ./iperf3.exe -c  172.16.20.74 -p 5201 -b 10M -u --get-server-output
Connecting to host 172.16.20.74, port 5201
[  4] local 10.1.114.200 port 63273 connected to 172.16.20.74 port 5201
[ ID] Interval           Transfer     Bandwidth       Total Datagrams
[  4]   0.00-1.00   sec  1.09 MBytes  9.10 Mbits/sec  139
[  4]   1.00-2.00   sec  1.27 MBytes  10.7 Mbits/sec  163
[  4]   2.00-3.00   sec  1.18 MBytes  9.90 Mbits/sec  151
[  4]   3.00-4.00   sec  1.24 MBytes  10.4 Mbits/sec  159
[  4]   4.00-5.00   sec  1.10 MBytes  9.25 Mbits/sec  141
[  4]   5.00-6.00   sec  1.20 MBytes  10.0 Mbits/sec  153
[  4]   6.00-7.00   sec  1.16 MBytes  9.76 Mbits/sec  149
[  4]   7.00-8.00   sec  1.30 MBytes  10.9 Mbits/sec  167
[  4]   8.00-9.00   sec  1.12 MBytes  9.37 Mbits/sec  143
[  4]   9.00-10.00  sec  1.23 MBytes  10.3 Mbits/sec  157
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams
[  4]   0.00-10.00  sec  11.9 MBytes  9.97 Mbits/sec  1.460 ms  919/1516 (61%)
[  4] Sent 1516 datagrams

Server output:
-----------------------------------------------------------
Server listening on 5201
-----------------------------------------------------------
Accepted connection from 10.1.114.200, port 11025
[  5] local 172.16.20.74 port 5201 connected to 10.1.114.200 port 63273
[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams
[  5]   0.00-1.00   sec  1.08 MBytes  9.04 Mbits/sec  0.987 ms  0/138 (0%)
[  5]   1.00-2.00   sec   432 KBytes  3.54 Mbits/sec  1.479 ms  88/142 (62%)
[  5]   2.00-3.00   sec   400 KBytes  3.28 Mbits/sec  1.317 ms  103/153 (67%)
[  5]   3.00-4.00   sec   408 KBytes  3.34 Mbits/sec  1.539 ms  101/152 (66%)
[  5]   4.00-5.00   sec   400 KBytes  3.28 Mbits/sec  0.851 ms  103/153 (67%)
[  5]   5.00-6.00   sec   400 KBytes  3.28 Mbits/sec  0.989 ms  103/153 (67%)
[  5]   6.00-7.00   sec   400 KBytes  3.28 Mbits/sec  1.466 ms  102/152 (67%)
[  5]   7.00-8.00   sec   400 KBytes  3.28 Mbits/sec  1.183 ms  103/153 (67%)
[  5]   8.00-9.00   sec   400 KBytes  3.28 Mbits/sec  5.698 ms  99/149 (66%)
[  5]   9.00-10.00  sec   392 KBytes  3.21 Mbits/sec  1.384 ms  107/156 (69%)
[  5]  10.00-10.34  sec  40.0 KBytes   953 Kbits/sec  1.460 ms  10/15 (67%)
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams
[  5]   0.00-10.34  sec  4.66 MBytes  3.78 Mbits/sec  1.460 ms  919/1516 (61%)  receiver


iperf Done.

</pre>

<div class="head head_3">Termis</div>
<ul>
<li><strong>MTU</strong>
    <br> 一个网络包的最大长度，以太网中一般为 1500 字节；
</li>
<li><strong>MSS</strong>
    <br> 去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；
    <br> IPV4 中 MSS 的大小为 MTU 的大小减去 40 bytes
</li>
</ul>





<div class="head head_2">iptables</div>
<div class="head head_3">iptables 如何实现的</div>

<div class="head head_3">iptables 的四个表</div>
<ul>
<li><strong>filter</strong>
    <br> This is the default table (if no -t option is passed). It contains the built-in chains INPUT (for packets destined to local sockets), FORWARD (for packets being routed through the box), and OUTPUT (for locally-generated packets).
    <br> 负责过滤数据包，确定是否放行该数据包（过滤）。包含三个规则链 INPUT、FORWARD、OUTPUT。
</li>
<li><strong>nat</strong>
    <br> This table is consulted when a packet that creates a new connection is encountered.  It consists of four built-ins: PREROUTING (for altering packets as soon as they come in), INPUT (for altering packets destined for local sockets), OUTPUT  (for altering locally-generated packets before routing), and POSTROUTING (for altering packets as they are about to go out).  IPv6 NAT support is available since kernel 3.7.
    <br> 
</li>
<li><strong>mangle</strong>
    <br> This  table  is used for specialized packet alteration.  Until kernel 2.4.17 it had two built-in chains: PREROUTING (for altering incoming packets before routing) and OUTPUT (for altering locally-generated packets before routing).  Since kernel 2.4.18, three other built-in chains are also supported: INPUT (for packets coming into the box itself), FORWARD (for altering packets being routed through the box), and POSTROUTING (for altering packets as they are about to go out).
    <br> 
</li>
<li><strong>raw</strong>
    <br> This table is used mainly for configuring exemptions from connection tracking in combination with the NOTRACK target.  It registers at the netfilter hooks with higher priority and is thus called before ip_conntrack, or any other IP tables.   It provides the following built-in chains: PREROUTING (for packets arriving via any network interface) OUTPUT (for packets generated by local processes)
    <br> 
</li>

<li><strong>security</strong>
    <br> This  table  is  used  for Mandatory Access Control (MAC) networking rules, such as those enabled by the SECMARK and CONNSECMARK targets.  Mandatory Access Control is implemented by Linux Security Modules such as SELinux.  The security table is called after the filter table, allowing any Discretionary Access Control (DAC) rules in the filter table to take effect before MAC rules.  This table provides the following built-in chains: INPUT (for packets coming into the box itself), OUTPUT (for altering locally-generated packets before routing), and FORWARD (for altering packets being routed through the box).
    <br> 
</li>
</ul>

<div class="head head_3">iptables 的五个内建 chain</div>
<p>
    五个内建的 chain 为： PREROUTING / POSTROUTING / FORWARD / INPUT / OUTPUT, 他们的关系如下图所示：
</p>
<img src="https://images.cnblogs.com/cnblogs_com/mojies/2171355/o_220606041259_iptables_chain_ralationship.png" alt="" class="img_center" width="600px">

<div class="head head_3">iptables 基本操作命令</div>
<ul>
<li><strong>查看当前防火墙规则</strong>
    <br> <code>iptables -nvL</code> or <code>iptables -L</code>
</li>
<li><strong>添加 Chain</strong>
    <br> <code>iptables -N CHAIN_NAME</code>
</li>
<li><strong>删除 chain</strong>
    <br> <code>iptables -X CHAIN_NAME</code>
</li>
<li><strong>重命名 chain</strong>
    <br> <code>iptables -E OLD_CHAIN_NAME NEW_CHAIN_NAME</code>
</li>
<li><strong>对 chain 规则做出修改（增删改查）</strong>
    <br> <code>iptables [-t table] {-A|-C|-D} OLD_CHAIN_NAME rule-specification</code>, <code>-A</code> 增加一条规则m, <code>-C</code> 检查规则是否存在, <code>-D</code> 删除某条规则
    <br> <code>ip6tables [-t table] {-A|-C|-D} OLD_CHAIN_NAME rule-specification</code>, 与上一致
    <br> <code>iptables [-t table] -I OLD_CHAIN_NAME [rulenum] rule-specification</code>, 插入一条规则
    <br> <code>iptables [-t table] -R OLD_CHAIN_NAME rulenum rule-specification</code>, 替换一条规则
    <br> <code>iptables [-t table] -D OLD_CHAIN_NAME rulenum</code>, 删除一条规则
    <br> <code>iptables [-t table] -S [OLD_CHAIN_NAME [rulenum]]</code>, 打印 chain 中的规则
    <br> <code>iptables [-t table] {-F|-L|-Z} [OLD_CHAIN_NAME [rulenum]] [options...]</code>, <code>-F</code> 清除 chain 中所有 rule, <code>-L</code> 列出 chain 中所有 rule, <code>-Z</code> 清除 chain 的包计数
    <br> <code>iptables [-t table] -P OLD_CHAIN_NAME target</code> 给 chain 指定默认行为
</li>
<li><strong>将 chain 应用于 chain</strong>
    <br> <code>iptables -A INPUT -p tcp -dport 80 -j CHAIN_NAME</code>
</li>
</ul>

<div class="head head_3">iptables 基本操作参数</div>
<ul>
<li><strong>--ipv4</strong> / <code>-4</code>

</li>
<li><strong>--ipv6</strong> / <code>-6</code>

</li>
<li><strong>-p</strong> / <code>--protocol</code>
    <br> 
    <br> The  protocol of the rule or of the packet to check.  The specified protocol can be one of tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh or the special keyword "all", or it can be a numeric value, representing one of these protocols or a differ‐
    ent one.  A protocol name from /etc/protocols is also allowed.  A "!" argument before the protocol inverts the test.  The number zero is equivalent to all. "all" will match with all protocols and is taken as default  when  this  option  is  omitted.
    Note  that,  in  ip6tables,  IPv6  extension headers except esp are not allowed.  esp and ipv6-nonext can be used with Kernel version 2.6.11 or later.  The number zero is equivalent to all, which means that you cannot test the protocol field for the
    value 0 directly. To match on a HBH header, even if it were the last, you cannot use -p 0, but always need -m hbh.
</li>
<li><strong>-s</strong> / <code>--source</code>
    <br> Source specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel.  Please note that specifying any name
    to  be  resolved with a remote query such as DNS is a really bad idea.  The mask can be either an ipv4 network mask (for iptables) or a plain number, specifying the number of 1's at the left side of the network mask.  Thus, an iptables mask of 24 is
    equivalent to 255.255.255.0.  A "!" argument before the address specification inverts the sense of the address. The flag --src is an alias for this option.  Multiple addresses can be specified, but this will expand to  multiple  rules  (when  adding
    with -A), or will cause multiple rules to be deleted (with -D).
</li>
<li><strong>-d</strong> / <code>--destination</code>
    <br> Destination specification.  See the description of the -s (source) flag for a detailed description of the syntax.  The flag --dst is an alias for this option.
</li>
<li><strong>-m</strong> / <code>--match</code>
    
</li>
<li><strong>-j</strong> / <code>--jump</code>

</li>
<li><strong>-g</strong> / <code>--goto</code>

</li>
<li><strong>-i</strong> / <code>--in-interface</code>
    <br> 接收数据包的 interface 名称（仅适用于进入 INPUT、FORWARD 和 PREROUTING 链的数据包）。
        当接口名前存在字符 “!” 的时候，将匹配除此接口的的所有数据。 如果接口名称以 “+” 结尾，那么任何以此名称开头的接口都将匹配。 如果省略此选项，则任何接口名称都将匹配。
</li>
<li><strong>-o</strong> / <code>--out-interface</code>
    <br> 发送数据包的 interface 名称（仅适用于进入 FORWARD, OUTPUT 和 POSTROUTING 链的数据包）。
        当接口名前存在字符 “!” 的时候，将匹配除此接口的的所有数据。 如果接口名称以 “+” 结尾，那么任何以此名称开头的接口都将匹配。 如果省略此选项，则任何接口名称都将匹配。
</li>
<li><strong>-f</strong> / <code>--fragment</code>
    <br> 
</li>
<li><strong>-c</strong> / <code>--set-counters</code>
    <br> 
</li>
</ul>

<div class="head head_3">参考资料</div>
<ul>
<li><a href="https://blog.csdn.net/weixin_51468875/article/details/114023012">Iptables防火墙策略详解</a></li>
<li>LINUX: man iptables</li>
<li><a href="https://wangchujiang.com/linux-command/c/iptables.html">iptables</a></li>
<li><a href=""></a></li>
</ul>


</div>
    








<div class="breadboard">
<div class="head head_1">图像</div>
<ul>
<li><strong>RGB 和 Ycrcb 转换</strong>
    <br> 转换公式一定要依据ITU的标准, 常看到的是 <code>ITU.BT-601</code> 和 <code>ITU.BT-709</code> 。
    <br> <a href="https://www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.601-7-201103-I!!PDF-E.pdf">ITU.BT-601</a>
    <br> <a href="https://www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.709-6-201506-I!!PDF-E.pdf">ITU.BT-709</a>

</li>
</ul>

</div>












<div class="breadboard">
<div class="head head_1">硬件</div>
<ul>
<li><strong>半导体集成电路第三代双倍数据速率同步动态随机存储器（DDR3 SDRAM）测试方法</strong>
    <br> <a href="https://www.cesa.cn/UpFileManage/bpgsManage/2017-10-24%20180021.pdf">链接地址</a>
    <br> 里面介绍了 TIS / TIH / TDS / TDH 这些参数的意义
</li>
<li><strong>Digi-Key</strong>
    <br> <a href="https://www.digikey.hk/en/products">Digi-Key 一个搜索硬件 IC 和模块的网站</a>

</li>
<li><strong>检测电路</strong>
    <br> 上下拉，开漏，推挽
    <br> JTAG
    <br> MIPI
    <br> I2S 主从
    <br> 外置晶振
    <br> 

</li>
</ul>

</div>







<div class="breadboard">
<div class="head head_1">工具</div>
<ul>
<li><strong>免费的 HexEdit</strong>
    <br> <a href="https://mh-nexus.de/en/hxd/">HexD</a>

</li>
<li><strong>glmark2</strong>
    <br> 图像测试工具
</li>
<li><strong>Android 端性能测试工具</strong>
    <br> <strong>AID64</strong>
    <br> <strong>Geekbench</strong>
    <br> <strong>OpenCL</strong>
    <br> <strong>Vulkan</strong>
    <br> <strong>CPDT Benchmark</strong>
    <br> <strong>Wild life Extreme Unlimited</strong>
    <br> <strong>PerfDog</strong>
    <br> <strong>inotifywatch</strong>： 监控某个目录的文件是否被访问了 <code>inotifywatch -a open /DIR_NAME</code>, 源码地址 <a href="https://github.com/inotify-tools/inotify-tools">inotify-tools</a>

</li>
</ul>

</div>    







<div class="breadboard">
<div class="head head_1">其他</div>
<ul>
<li><strong>介绍 ASOC 架构的文章</strong>
    <br> <a href="https://blog.csdn.net/yangjizhen1533?type=blog">Linux 音频驱动(一 -> 六)</a>

</li>
<li><strong>Ross Anderson 大牛的主页</strong>
    <br> <a href="https://www.cl.cam.ac.uk/~rja14/">https://www.cl.cam.ac.uk/~rja14/</a>

</li>
<li><strong>HTML 数学公式代码生成器</strong>
    <br> <a href="https://webdemo.myscript.com/views/math/index.html#">https://webdemo.myscript.com/views/math/index.html#</a>
    <br> <a href="https://www.mathmlcentral.com/Tools/ToMathML.jsp">https://www.mathmlcentral.com/Tools/ToMathML.jsp</a>
</li>
<li><strong>Latex</strong>
    <br> <a href="https://xjay.net/201902/latex-syntax-for-math-equation/">LaTeX 数学公式语法</a>

</li>
<li><strong>搜书网站</strong>
    <br> <a href="http://library.lol/">http://library.lol/</a>
    <br> <a href="http://libgen.rs/">http://libgen.rs/</a>
    <br> <a href="https://zh.3lib.net/">zlibrary</a>

</li>
<li><strong>jeanboydev 总结的一份 Android 系统开发分析</strong>
    <br> <a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode">https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode</a>

</li>
<li><code>katex 运用</code>
    <br>
    <span class="latex_str" >
        \overline{PSNR}=
            \sum^K_{k=1}min\left[
                 20\log 10\left(
                    \dfrac{255}{ \sqrt{
                        \dfrac{1}{M*N}
                        \sum^{M-1}_{i=0}
                        \sum^{N-1}_{j=0}
                        [Y_{origin}(i,j) - Y_{code}(i,j)]^{2} } }
                \right); 50
            \right]
    </span>
    

</li>
<li><strong>平替 Window jounal 的笔记工具</strong>
    <br> <a href="https://github.com/xournalpp/xournalpp/releases/tag/v1.1.1">https://github.com/xournalpp/xournalpp/releases/tag/v1.1.1</a>

</li>
<li><strong>buildroot CMake 添加头依赖</strong>
    <br> buildroot 中的安装包都会安装到 <code>buildroot/output/PLAT/host/TOOLCHAIN_NAME/sysroot/usr/include</code>, 如果实在找不到可以在 PLT 目录查找以下你想要的头文件，
        该目录也可以通过 <code>${CMAKE_SYSROOT}/usr/include</code> 定位到。
    <br> 因此在你的工程中你可以使用 <code>include_directories("${CMAKE_SYSROOT}/usr/include")</code> 引用该目录下的所有安装头文件。
</li>
<li><strong>Git 命令</strong>
    <br> git 命令行，查找某个人在某个目录提交的所有关联文件（如今还存在的）的命令
    <br> <code>git whatchanged  --author=${USERNAME} ${SEARCH_DIR} | grep "^:[0-9]" | awk '{print $6}' | sort| uniq | xargs -I {} sh -c "test -f {} && ls -lh {} " | awk '{print $5, "\t",$9}'</code>

</li>
<li><strong>C++ 静态检查：<code>clang</code></strong>
    <br> <a href="https://clang.llvm.org/get_started.html">clang 官网</a>
    <br> 为当前目录下的 CPP 文件执行 clang 语法检查 <code>find -name "*cpp" | xargs -I {} clang -fsyntax-only {}</code>
</li>
<li><strong>C++ 静态检查：<code>cppcheck</code></strong>
    <br> <a href="https://cppcheck.sourceforge.io/#premium">cppcheck 官网</a>
</li>
<li><strong>C++ 静态检查： <code>TscanCode</code></strong>
    <br> <a href="https://github.com/Tencent/TscanCode">Tscancode 仓库地址</a>

</li>
<li><strong>更多 CPP 检查工具网站</strong>
    <br> <a href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#Clang">Wikipedia -- List of tools for static code analysis</a>

</li>
<li><strong>下载 github 某一个仓库某一个目录的文件</strong>
    <br> <a href="https://minhaskamal.github.io/DownGit/#/home">https://minhaskamal.github.io/DownGit/#/home</a>
</li>
<li><strong>搜索 github 某一个仓库中的内容</strong>
    <br> <a href="https://sourcegraph.com/search">https://sourcegraph.com/search</a>
    <br> 比如： https://sourcegraph.com/search?q=context:global+repo:%5Egithub%5C.com/danmar/cppcheck%24+txt&patternType=standard
</li>

</ul>
<li><strong>为服务器添加一个用户</strong>
    <pre>
#!/bin/bash

echo "Please input user name:"
read NAME

IS_EXIST=$(cat /etc/passwd | grep "${NAME}")

if [ "${IS_EXIST}" = "" ]; then
    echo "USERNAME: ${NAME}"
else
    echo "This man is exist, please select another one"
    echo "/etc/passwd -> ${IS_EXIST}"
    exit -1
fi

echo "Please input select user base home dir:"
echo "1. /home"
echo "2. /home2"
echo "3. /home3"
echo "4. /home4"
read HOME_DIR

case ${HOME_DIR} in
1|/home)
    HOME_DIR="/home"
    ;;
2|/home2)
    HOME_DIR="/home2"
    ;;
3|/home3)
    HOME_DIR="/home3"
    ;;
4|/home4)
    HOME_DIR="/home4"
    ;;
*)
    echo "Not this option"
    exit -1
    ;;
esac

SMB_CONFIG_CONTENT="[${NAME}]\n   comment = A Shared Directory\n   path = ${HOME_DIR}/${NAME}\n   valid users = ${NAME}\n   public = no\n   writable = yes\n   max connections = 10\n"

echo "---"
echo "USER --> ${NAME}"
echo "PASSWORD --> ${NAME}"
echo "HOME_DIR --> ${HOME_DIR}"
echo "SAMBA PASSWORD --> ${NAME}"

echo "--- SMB CONFIG"
echo -e "${SMB_CONFIG_CONTENT}"

useradd -d ${HOME_DIR}/${NAME} -m -p $(openssl passwd -1 ${NAME}) -s /bin/bash ${NAME}
smbpasswd -a ${NAME} -w ${NAME}
echo -e "${SMB_CONFIG_CONTENT}" >> /etc/samba/smb.conf
systemctl  restart smbd
    </pre>

</li>
<li><strong>u-boot 启动流程</strong>
    <br> u-boot 的关联文件 <code>u-boot.lds</code> 可看出，启动函数即是 <code>_start</code> 函数，而该函数在 <code>start.s</code> 中，但你的工程里面大部分可能情况存在大量的 <code>start.S</code>,
    这时候你最重要的工作就是找到 start.s， 最简单的办法就是编译一次，看那个 <code>start.o</code> 被编译出来了
    <br> 随后你可能发现你的 <code>start.S</code> 里面非常多的宏，也不知道到底运行到哪里了，这时候最好的办法还是编译一次，然后使用 <code>objdump -S/-d start.o</code> 将之反编译，然后查看汇编文档，像我拿出来的汇编文档如下所示：
    <pre>
~/rk3588/u-boot develop
❯ ../prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-objdump -d arch/arm/cpu/armv8/start.o | sed 's/&lt;/\&amp;lt;/g' | sed 's/&gt;/\&amp;gt;/g'

arch/arm/cpu/armv8/start.o:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:   1400000a        b       28 &lt;reset&gt;
   4:   d503201f        nop

0000000000000008 &lt;_TEXT_BASE&gt;:
   8:   00200000        .word   0x00200000
   c:   00000000        .word   0x00000000

0000000000000010 &lt;_end_ofs&gt;:
        ...

0000000000000018 &lt;_bss_start_ofs&gt;:
        ...

0000000000000020 &lt;_bss_end_ofs&gt;:
        ...

0000000000000028 &lt;reset&gt;:
  28:   14000000        b       118 &lt;save_boot_params&gt;

000000000000002c &lt;save_boot_params_ret&gt;:
  2c:   10000000        adr     x0, 0 &lt;vectors&gt;
  30:   d5384241        mrs     x1, currentel
  34:   f100303f        cmp     x1, #0xc
  38:   540000a0        b.eq    4c &lt;save_boot_params_ret+0x20&gt;
  3c:   f100203f        cmp     x1, #0x8
  40:   54000160        b.eq    6c &lt;save_boot_params_ret+0x40&gt;
  44:   f100103f        cmp     x1, #0x4
  48:   540001a0        b.eq    7c &lt;save_boot_params_ret+0x50&gt;
  4c:   d51ec000        msr     vbar_el3, x0
  50:   d53e1100        mrs     x0, scr_el3
  54:   b2400c00        orr     x0, x0, #0xf
  58:   d51e1100        msr     scr_el3, x0
  5c:   d51e115f        msr     cptr_el3, xzr
  60:   58000600        ldr     x0, 120 &lt;save_boot_params+0x8&gt;
  64:   d51be000        msr     cntfrq_el0, x0
  68:   14000008        b       88 &lt;save_boot_params_ret+0x5c&gt;
  6c:   d51cc000        msr     vbar_el2, x0
  70:   d2867fe0        mov     x0, #0x33ff                     // #13311
  74:   d51c1140        msr     cptr_el2, x0
  78:   14000004        b       88 &lt;save_boot_params_ret+0x5c&gt;
  7c:   d518c000        msr     vbar_el1, x0
  80:   d2a00600        mov     x0, #0x300000                   // #3145728
  84:   d5181040        msr     cpacr_el1, x0
  88:   94000000        bl      94 &lt;apply_core_errata&gt;
  8c:   94000000        bl      b8 &lt;lowlevel_init&gt;

0000000000000090 &lt;master_cpu&gt;:
  90:   94000000        bl      0 &lt;_main&gt;

0000000000000094 &lt;apply_core_errata&gt;:
  94:   aa1e03fd        mov     x29, x30
  98:   d5380000        mrs     x0, midr_el1
  9c:   d344fc00        lsr     x0, x0, #4
  a0:   92402c00        and     x0, x0, #0xfff
  a4:   f1341c1f        cmp     x0, #0xd07
  a8:   54000060        b.eq    b4 &lt;apply_a57_core_errata&gt;
  ac:   aa1d03fe        mov     x30, x29
  b0:   d65f03c0        ret

00000000000000b4 &lt;apply_a57_core_errata&gt;:
  b4:   17fffffe        b       ac &lt;apply_core_errata+0x18&gt;

00000000000000b8 &lt;lowlevel_init&gt;:
  b8:   aa1e03fd        mov     x29, x30
  bc:   58000360        ldr     x0, 128 &lt;save_boot_params+0x10&gt;
  c0:   94000000        bl      0 &lt;gic_init_secure&gt;
  c4:   58000360        ldr     x0, 130 &lt;save_boot_params+0x18&gt;
  c8:   94000000        bl      0 &lt;gic_init_secure_percpu&gt;
  cc:   aa1d03fe        mov     x30, x29
  d0:   d65f03c0        ret

00000000000000d4 &lt;smp_kick_all_cpus&gt;:
  d4:   580002a0        ldr     x0, 128 &lt;save_boot_params+0x10&gt;
  d8:   14000000        b       0 &lt;gic_kick_secondary_cpus&gt;
  dc:   d65f03c0        ret

00000000000000e0 &lt;c_runtime_cpu_setup&gt;:
  e0:   10000000        adr     x0, 0 &lt;vectors&gt;
  e4:   d5384241        mrs     x1, currentel
  e8:   f100303f        cmp     x1, #0xc
  ec:   540000a0        b.eq    100 &lt;c_runtime_cpu_setup+0x20&gt;
  f0:   f100203f        cmp     x1, #0x8
  f4:   540000a0        b.eq    108 &lt;c_runtime_cpu_setup+0x28&gt;
  f8:   f100103f        cmp     x1, #0x4
  fc:   540000a0        b.eq    110 &lt;c_runtime_cpu_setup+0x30&gt;
 100:   d51ec000        msr     vbar_el3, x0
 104:   14000004        b       114 &lt;c_runtime_cpu_setup+0x34&gt;
 108:   d51cc000        msr     vbar_el2, x0
 10c:   14000002        b       114 &lt;c_runtime_cpu_setup+0x34&gt;
 110:   d518c000        msr     vbar_el1, x0
 114:   d65f03c0        ret

0000000000000118 &lt;save_boot_params&gt;:
 118:   14000000        b       2c &lt;save_boot_params_ret&gt;
 11c:   00000000        .inst   0x00000000 ; undefined
 120:   016e3600        .word   0x016e3600
 124:   00000000        .word   0x00000000
 128:   fe600000        .word   0xfe600000
 12c:   00000000        .word   0x00000000
 130:   fe680000        .word   0xfe680000
 134:   00000000        .word   0x00000000
    </pre>
    <br> 

</li>
</div>










<table><tr>
<td><img width="190" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_AliPay1.jpg" alt=""></td>
<td><img width="200" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_WeChatPa1.jpg" alt=""></td>
</tr></table>
<div class="div_2" id="AuthorizationWarning">
<div class="Text_ZZ">原创文章，版权所有，转载请获得作者本人允许并注明出处</div>
<div class="Text_LB">我是留白；我是留白；我是留白；（重要的事情说三遍）</div>
</div>
<div class="foot_panel" id="foot_panel">
    <div id="foot_panel_top" >
        <a href="#main_index" class="NoExternal">TOP</a>
    </div>
    <div id="foot_panel_bottom" >
        <a href="#AuthorizationWarning" class="NoExternal">BOT</a>
    </div>
</div>
</body>

<script src="js/PrePost.js"></script>



</html>
