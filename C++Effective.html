<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title>C++ Effective</title>
</head>
<body>

<style id="style_area" >
a{
    text-decoration:none;
}
p{
    line-height: 1.4em;
    text-indent:2em;
    margin-top: 0;
    margin-bottom: 0;
    padding: 0.3em 0;
}
li{
    padding: 0.3em 0;
}
.gray-line{
    color:#F77;
    font-weight: 100;
    font-style: oblique;
    font-size: 0.8em;
}
code{
    line-height: 24px;
    border-bottom: rgb(253, 191, 186) solid 2px;
    margin: 3px 0.5em;
    padding: 2px;

    font-weight: 400;
    font-size: 12px;
    font-style: oblique;
    border-radius: 3px;
    backdrop-filter: blur(2px);
    color: rgb(231,76,60);
}
/* code{
    line-height: 20px;
    margin: 3px;
    padding: 2px;
    border-radius: 3px;
    color: #eb3f2f;
    font-weight: bold;
    font-size: 12px;
    margin: 3px;
    background-color:#f0f0f0;
    border-right: 1px solid #a9a9a9;
    border-bottom: 1px solid #a9a9a9;
    backdrop-filter: blur(2px);
} */
pre{
    border-radius: 4px;
    background-color: rgb(247,247,247,0.3);
    border: 1px solid #aaa;
    line-height: 1.182em;
    overflow: auto;
    font-size: 11px;
    padding: 16px;
    margin: 10px;
}
img{
    opacity:1;
    margin: 10px;
}
.breadboard{
    box-shadow: 0 1px 4px 0 rgba(0,0,0,0.37);
    margin: 5px 2% 45px;
    padding: 10px;
}

.head_index{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: center;
}
.head_1{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 4px #133152 solid;
    width: 99%;
    margin-top: 1.5em;
}
.head_2{
    color: #163a60;
    font-size: 25px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 2px #163a60 solid;
    width: 99%;
    margin-top: 1.25em;
}
.head_3{
    color: #1a426e;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.head_4{
    color: #1d4a7b;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.div_2{
    margin: 5px 2% 45px;
    padding: 40px;
    height: 100px;
    text-align: center;

}

.img_center{
    text-align: center;
}
.img_left{
    text-align: left;
    margin-left: 4em;
}
.note_msg{
    color: #eb3f2f;
    font-weight: 600;
}

.offset_1em{margin-left: 1em;}
.offset_2em{margin-left: 2em;}
.offset_3em{margin-left: 3em;}
.offset_4em{margin-left: 4em;}
.offset_5em{margin-left: 5em;}
.offset_6em{margin-left: 6em;}
.offset_7em{margin-left: 7em;}
.offset_8em{margin-left: 8em;}
.offset_9em{margin-left: 9em;}
.offset_10em{margin-left: 10em;}

.green_text{
    color: green;
}
.red_text{
    color: red;
}
.purple_text{
    color: purple;
}

.limit_window_size{
    /* overflow:auto; */
    max-height:30em;
    overflow-y:auto;
    word-wrap:break-word;
    word-break: normal;
    white-space: pre-wrap;
    margin:10px;
}

.child_red2_key li strong{
    color: red;
}
.child_red1_key li strong{
    color: red;
}
.child_red2_key li strong{
    color: #F77;
}
.child_red3_key li strong{
    color: #Faa;
}

.foot_panel{
    position:fixed;
    right:3em;
    bottom: 3em;
    width:6em;
    height:30px;
    padding:15px 5px 5px 15px;
    background-color:rgb( 157, 157, 157, 0.618 );
    border-radius: 8px;
}
#foot_panel_top{
    display: inline;
    border-right: 5px solid #eee;
}
#foot_panel_top a{
    width:4em;
}
#foot_panel_bottom {
    display: inline;
    margin-left: 5px;
}
#foot_panel_top a{
    width:4em;
}

#main_index li{
    line-height: 17px;
    font-size: 16px;
}
</style>




<div class="breadboard">
<div class="head_index">目录</div>
<div><ol id="main_index">
</ol></div>
</div>









<div class="breadboard">
<div class="head head_1">基础知识</div>
<p>
    此处仅会记录我在学习过程中遇到的一些自己在某个阶段容易弄混的概念，因此这是一个并不完备的知识点集合，也是一个看上去有点混乱的集合。
</p>

<div class="head head_2">C++ 模板特化</div>
<p>
    首先摘抄一段模板的定义：“模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数， 从而实现了真正的代码可重用性。模版可以分为两类，一个是函数模版，另外一个是类模版。” From: 
    <a href="https://zhuanlan.zhihu.com/p/346400616">C++ 模板 全特化与偏特化</a>
</p>
<p>
    那么什么是模板的特化？模板特化是模板的一个特殊情况，比如说，你之前已经定义了一个模板，但是在定义的模板中并不支持某种特殊情况，那么这个时候可能我们需要对模板再这种特殊情况做特殊说明。
</p>
<p>
    举个例子，比如你先定义了一个求两个参数是否相等的模板，如下所示：
</p>
<pre>
template&lt;typename T&gt;
bool EQ(T a, T b){
    return a == b;
}
</pre>
<p>
    但你知道这个函数并不能处理 T == float 的情况，因此，此时我们需要对 float 类型做一个特殊的处理，如下所示：
</p>
<pre>
template&lt;&gt;
bool EQ(float a, float b)
{
 return ( abs(a-b) &lt; 10e-3 );
}
</pre>

<p>
    <strong>而模板分为函数模板和类模板，模板的特化分为全特化和偏特化，其中类模板支持全特化和偏特化，而函数模板仅支持全特化。</strong> 
</p>
<p>
    接下来介绍一下全特化和偏特化。全特化即需要制定模板中所有模板参数的具体类型，而片特化只需要制定其中的一部分。如下所示：
</p>
<pre>
存在模板
template&lt;typename T1, typename T2&gt;
class A{
public:
    void func1( T1 a, T2 b ){
        ...
    }
    ...
};

template&lt;typename T1, typename T2&gt;
void func1( T1 a, T2 b ){
    ...
}

// 全特化
template&lt;&gt;
class A&lt;float, int&gt;{
    void func1( float a, int b ){
        ...
    }
    ...
}

template&lt;&gt;
void func1( float a, int b ){
    ...
}

// 偏特化
template&lt;T&gt;
class A&lt;float, T&gt;{
    void func1( float a, T b ){
        ...
    }
    ...
}
</pre>
<p>
    此外，还找到一篇感觉讲解比较全的文章：<a href="https://sg-first.gitbooks.io/cpp-template-tutorial/content/jie_te_hua_yu_pian_te_hua.html">深入理解特化与偏特化</a>，
</p>

<div class="head head_2">C++ 11 <strong>default</strong></div>
<p>
    原文： <a href="https://blog.csdn.net/fengbingchun/article/details/52475155">https://blog.csdn.net/fengbingchun/article/details/52475155</a>
</p>
<p>
    在 C+11 中, 对于 defaulted 函数, 编译器会为其自动生成默认的函数定义体, 从而获得更高的代码执行效率, 也可免除程序员手动定义该函数的工作量。
</p>
<p>
    C++ 的类有四类特殊成员函数，它们分别是：<code>默认构造函数</code> / <code>析构函数</code> / <code>拷贝构造函数</code> / <code>拷贝赋值运算符</code>。
    这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。
    当存在用户自定义的特殊成员函数时，编译器将不会隐式的自动生成默认特殊成员函数，而需要程序员手动编写，加大了程序员的工作量。并且手动编写的特殊成员函数的代码执行效率比编译器自动生成的特殊成员函数低。
</p>
<p>
    C++11 标准引入了一个新特性: defaulted 函数。程序员只需在函数声明后加上 "=default", 就可将该函数声明为 defaulted 函数, 编译器将为显式声明的 defaulted 函数自动生成函数体。
</p>
<p>
    defaulted 函数特性仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。
</p>
<p>
    defaulted 函数既可以在类体里(inline)定义，也可以在类体外(out-of-line)定义。
</p>
<p>
    如下所示：
</p>
<pre>
class Foo
{
	Foo(int x);         // Custom constructor
	Foo() = default;    // The compiler will now provide a default constructor for class Foo as well
}
</pre>

</div>    












<div class="breadboard">
<div class="head head_1">《Effective C++》 笔记</div>
<p>
    这里记录的是我阅读 《Effective C++》这本书所做的一些笔记，下面目录的排版也按照原文的章节顺序排列，
    其中 1-4 点为 <strong>让自己习惯 C++</strong> 部分的内容，
    其中 5-12 点为 <strong>设计与声明</strong> 部分的内容，
    其中 13-17 点为 <strong>让自己习惯 C++</strong> 部分的内容，
    其中 26-31 点为 <strong>实现</strong> 部分的内容，
    其中 32-40 点为 <strong>集成与面向对象设计</strong> 部分的内容，
    其中 41-48 点为 <strong>模板与泛型编程</strong> 部分的内容，
    其中 49-52 点为 <strong>定制 new 与 delete</strong> 部分的内容，
    其中 53-55 点为 <strong>杂项讨论</strong> 部分的内容。
</p>

<div class="head head_2">1: 将 C++ 看成联邦语言</div>
<br> C++ 大体上可看坐 C, C with class, Temeplate, STL 的一个集合


<div class="head head_2">2: 尽量使用 <code>const</code>, <code>enum</code>, <code>inline</code>, <code>template</code> 代替宏定义 </div>
<br> 主要有以下三个问题：
<br> 1. 因为宏定义如果出现为题编译其很难定位问题点
<br> 2. 其次宏定义是全局性的无法进行区域化
<br> 3. 最后我们在设计宏定义表达式的时候很容易出问题

<div class="head head_2">3: 多用 const</div>
<br> const 语法虽然变化多端，但并不莫测高深。如果关键字 const 出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。
<br> const 修饰的函数，返回的值也应该是 const 类型的
<br> 如果一定要在 const 函数中修改成员，那么可以使用 <code>mutable</code> 修饰该成员。


<div class="head head_2">4: 确保所有的变量在使用前都初始化了</div>
<br> C part of C++ 类的变量不会确保初始化， non-C part of C++ 会确保初始化
<br> 但你很难确保你记住这些规则，最好的方法就是在使用前先初始化所有变量。
<br> 因为成员的初始化时更具申明的顺序来的，而不是根据初始化列表的顺序来的，这有时候会造成困惑，为了解决这种困惑，你应该尽量保证初始化列表中的顺序与类成员申明顺序一致。
<br> static 对象时再程序退出的时候才会被销毁。（即静态变量的析构函数时程序退出时才会调用）
<br> static 成员因为可能分布在程序中的任何位置，因此编译器要推断其合理的初始化顺序是几乎不可能的，因此一个消除这个问题的方法是将 non-local static 对象放到一个自己的专属函数内。
    这些函数返回一个支详该对象的 refrence 中。换句话说也就是 non-local static 被 local static 代替了。而 local static 对象会在“该函数被调用期间”“首次遇到该对象之定义式” 时被初始化。
    而这样又带来一个好处，如果该对象不被访问到，那么该变量的初始化永远不会被调用到（节省初始化资源消耗）。
<br> 如果 static 对象在多线程中访问，有可能会产生初始化竞态，从而导致不可知的程序错误，消除这种问题的一种方式是在对象单线程状态时，逐个调用一下每个静态函数的 refrence-returning 函数。


<div class="head head_2">5: 了解 C++ 默默编写并调用了哪些函数</div>
    <br> 如果你定义了一个类，即使你不对下列函数进行申明，但只要有人尝试调用它们，编译器会为你声明它们。这些函数有 default 构造函数, copy 构造函数, 析构函数, copy assignment 拷贝复制函数，如下所示：
<pre>
class Empty{
public:
    Empty();
    Empty(const Empty &);
    ~Empty();
    Empty & opterator=( const Empty & );
}
</pre>
    <br> non-static refrence 和 non-static const 对象都不能进行拷贝复制。
<pre>
main.cpp:6:7: error: non-static reference member ‘std::string& NameObject<int>::nameValue’, cannot use default assignment operator
main.cpp:6:7: error: non-static const member ‘const int NameObject<int>::objectValue’, cannot use default assignment operator
</pre>
    <br> non-static refrence 和 non-static const 只能在初始化列表进行初始化。


<div class="head head_2">6: 若不想使用编译器自动生成的函数，就该明确拒绝</div>
    <br> 将拷贝函数和拷贝复制函数申明为私有函数并不足以在所有条件下禁用编译自动生成的函数，因为友元函数和成员函数还是可以调用到。
    <br> 而解决办法就是，在申明为似有函数的基础上，不去实现此类函数。
    <br> 当然也可以去继承下面的类：
<pre>
class Uncopyable{
protect:
    Uncopyable();
    ~Uncopyable();
private:
    Uncopyable(const Uncopyable &);
    Uncopyable &operator=(const Uncopyable &);

}
</pre>


<div class="head head_2">7: 为多态墓类声明 virtual 析构函数</div>
    <br> 可能你将 new 的派生类给基类的指针，而在使用之后 delete 基类指针。此时如果基类析构函数为非虚函数，那么将会调用基类的析构函数，而不是派生类的析构函数。
    <br> 但是如果你将任何函数的析构函数都定义为虚函数，这会造成不必要的开销，因为一旦一个类中存在一个虚函数，则该类对象会存在一个析函数标指针。这将导致不必要的内存开销。
    <br> 此外 C++ 的很多内建类（比如 std::string ）的基类的析构函数都不是虚函数，因此如果你有类派生自这些内建类，千万要注意妥善的使用 delete。


<div class="head head_2">8: 到让异常逃离析构函数</div>
    <br> 如果你有一个装在对象的容器，再容器销毁的时候，该容器中所有的对象的析构函数都应该被调用，而此时如果有异常发生，那么系统再同一时刻出现两个异常会导致导致意想不到的问题。
    <br> 而最好的办法是，不要让异常暴漏到析构函数之外。对此有两种操作：
    <br> 1. 捕获该异常，打印报错信息，退出程序
    <br> 2. 捕获该异常，打印报错信息，不让之继续传播（吞下异常）
    <br> 如果你在运行某个操作时候可能发生异常，那么最好的办法是，在析构函数之外简历一个操作函数，确保在析构之前该函数被调用，并将异常处理放在该函数内。


<div class="head head_2">9: 不要再构造和析构过程中调用 virtual 函数</div>
    <br> 因为假设你的基类的构造函数内有调用虚函数，那么此时在你申明一个派生类的时候，构造函数内调用的虚函数并不是派生类里面的虚函数，而是基类里面的虚函数。这可能不是你意料中的。


<div class="head head_2">10: 让 <code>opterator=</code> 返回一个 <code>refrence to *this</code></div>
    <br> 这是实现连锁赋值的必要条件 ( a=b=c )，也是 C++ 内建库的通用规则
    <br> 该规则同样适用于 <code>+=</code>, <code>-=</code>, <code>*=</code> 等等


<div class="head head_2">11: 在 <code>operator=</code> 中处理自我复制</div>
    <br> 首先你得识别哪些是自我复制。第一种情况是指针和引用之间的复制，比如 <code>*a = *b;</code>, <code>ref_a = *b</code>, <code>a[n] = a[m]</code> ....
    <br> 如果拷贝构造和拷贝赋值是系统生成的，一般没有什么问题（虽然这种自我复制仅仅是在浪费资源）。
    <br> 但是一旦这两个函数是你自己编写的，那么很有可能因为你的疏忽导致非常严重的后果。比如下面这种情况：
<pre>
A &opterator=(const A &a){
    delete memp;
    memp = new mMem( *a.memp ); // a.memp 可能已经被自己释放
    return *this;
}
</pre>
    <br> 另外还一种情况时，当你的函数操作多个对象，而多个对象可能是同意对象的时候，要确保其行为依旧正确。 


<div class="head head_2">12: 复制对象时勿忘其每一个成员</div>
    <br> 第一种情况是你编写了自己的拷贝函数，很完美，但后续你可能又为该类增加了一些成员，但在拷贝的时候又忘记了，像下面这种情况：
<pre>
class A{
    int b;
    int c; 后面添加的
public:
    A( A &a ){
        b = a.b
    }
}
</pre>
    <br> 还有一种情况是你继承了类 A, 但是忘记在你的拷贝函数中执行 A 的拷贝函数了。如下所示：
<pre>
class B : public A{
    int d;
public:
    B( B &b )
        :A( b )    // 千万不要忘记这一行
    {
        d = b,d

        A( b );    // 或者这一行
    }

    B & operator=( const B &b ){
        d = b,d
        
        A::operator=( b )    // 也不要忘记这一行
    }
}
</pre>
    <br> 另外，记住，不要在拷贝复制函数里面调用拷贝函数，也不要在拷贝函数里面调用拷贝复制函数，这会有意想不到的问题。
        比较好又比较通用的做法是，创建一个 private 通用函数 ( 比如为 init ) ，然后让拷贝构造函数和拷贝函数都调用这个函数 ( init );



<div class="head head_2">13: 以对象管理资源</div>
    <br> 为了防止内存泄漏，（也就是你申请的指针忘记释放），C++ 准备了两种机制帮助你解决这一担忧，但这两种机制都有自己的限制，你需要仔细权衡。
    <br> 一个是 auto_ptr 一个是 tr1::share_ptr
    <br> 其中 auto_ptr 不能有多个 auto_ptr 指向同一指针。因为 auto_ptr 会在离开作用域，释放资源的时候调用析构函数 delete 掉申请的内存，如果有两个 auto_ptr 指向同一个指针，则会导致内存释放多次的异常情况。
    <br> 但这并不意味着你不可以将 auto_ptr A 赋值给 auto_ptr B, 在你赋值之后 auto_ptr A 指向的地址将会被设置为 NULL。
    <br> 另外一个就是引用计数型智慧指针 - RCSP - refrence-counting smart pointer -- tr1::share_ptr
    <br> share_ptr 会对指针的引用进行计数，当引用变为 0  的时候就会释放指向的内存，但也有该指针处理不了的情况，比如，两个 share_ptr 存在互指的情况。
    <br> 只要注意以上几点，share_ptr 还是能大大解放生产力的。


<div class="head head_2">14: 在资源管理类中小心 copy 行为</div>
    <br> 在某些时候我们可能需要自己创建资源管理类，为了确保资源被合理的利用，我们必须保证资源不会被提前释放或者泄露。因此这本书总结了几个原则：
    <br> 1. 不允许拷贝（可以参考第六点），不会被拷贝，资源就不会存在管理资源泄露的风险
    <br> 2. 如果允许多个对象持有一个资源，那么我们可能需要统计资源的使用情况（比如计数），当资源计数为 0 的时候自动将资源释放掉。需要特别注意的是，复制的时候你要带上公共的资源管理区域。
    <br> 3. 如果你允许对资源进行复制，那么你需要确保对你管理的资源进行深度复制。
    <br> 4. 如果你需要实现类似 auto_ptr 的功能，即统一时刻只允许一个对象持有资源，那么你需要妥善的做好资源的转移工作。


<div class="head head_2">15: 在资源管理类中提供对原始资源的访问</div>
    <br> 你可能经常使用智能指针来管理你的内存资源，但可能有时候你会要使用到原始资源的部分。那么智能指针针对这种情况提供了 <code>get()</code> 方法。
        如果你想更加自然的使用，也可以使用含有隐式转换的 <code>-></code> 和 <code>*</code>。
    <br> 或者使用隐式转换
    <pre>
class A{
public:
    ...
    operator A() const{
        return origin_point;
    }
    ...
}
    </pre>
    <br> 但使用这种方法很容易导致指针的滥用，而智能指针又不能统计到这些资源的使用情况，这导致的情况就是，指针可能被释放，但还在其他地方被调用。
    <br> 因此如果遇到这种使用场景，那么最好的办法还是使用 <code>get()</code>, 至少你在使用的时候知道自己是获取了一个智能指针的原始资源。
    <br> 当然，如果你自己创建了一个资源管理类，你可能也需要考虑到这方面。


<div class="head head_2">16: 使用成对的 new 和 delete 时要采取相同形式</div>
    <br> 因为编译器存在的差异，你使用 <code>new []</code> 创建的对象可能并不能使用 <code>delete</code> 进行删除，因为 <code>new</code> 和 <code>delete</code> 是配对的。
        而 <code>new []</code> 是和 <code>delete []</code> 配对的。
    <br> 而 typedef 定义式很容易掩盖原来的类型，因此在编写代码的时候很容易忘记这一点，因此我们不建议使用 typedef 来对数组数据类型来做 alias。
    <br> 另外一个方面，因为如果你在 class 内部使用指针规划成既可以指向数组，又可以指向普通对象，这时也要非常注意，在析构的时候需要妥善的做出处理。
    <br> 相反 C++ STL 中提供了非常多的特性来处理数组的情况，比如 <code>string</code>， <code>vector</code>
</li>·

<div class="head head_2">17: 以独立语句将 newd 对象置入智能指针</div>
    <br> 假如有一个这样的两个函数：<code>int A();</code>, <code>void B( std::tr1::share_ptr&lt;C&gt; c, int a )</code>
    <br> 然后我们需要完成这样一个操作： <code>B( std::tr1::share_ptr&lt;C&gt;( new C ), A() )</code>
    <br> 但因为不同编译器的实现方式不同，<code>new C</code>, <code>std::tr1::share_ptr&lt;C&gt; c = </code>, <code>A()</code> 的调用顺序可能不一样
    <br> 加入 <code>A()</code> 如果存在异常的话，那么就有可能导致 <code>new C</code> 泄漏
    <br> 处理这种情况最妥善的办法就是将一二步骤独立出来，将上述表达式分成两个部分处理，如下所示：
    <pre>
std::tr1::share_ptr<C> c( new C );
B( c, A() );
    </pre>


<div class="head head_2">18: 让接口容易被正确的使用，不容易被错误使用</div>
    <br> 原文给的是一个关于设置日期的例子，如：<code>Data( int year, int day, int month )</code>, 而这个接口中参数类型都为 int 类型，因此调用的时候很容易写混，而且很容易也很越界。
        我们当然可以在这个函数内部进行边界检查，而且这一般也是必要的，但是这一般要到运行时才发现。而如果这些参数是动态生成，测试程序覆盖不全面，有可能还会导致潜在的缺陷。
    <br> 因此，一个比较好的方式是我们为每一个参数都设计一个独特的类型，让用户在编译阶段就将问题发现出来。
    <br> 比如我们可以将这个接口设计成这样：<code>Data( const Year &. const Day &, const Month & )</code>。这从一方面规避了参数顺序弄混的问题：
    <br> 而针对 Month 这种只有有限个数值的类型，我们甚至可以将数值封装成函数。进而将数值限定到固定的值域中，这种方法主要用于代替 enum, 因为 enum 实际上是一个整形，可以从整形强制转换得到。
        方式如下：
    <pre>
class Month{
public:
    static Month Jan(){ return Month(1); };
    static Month Feb(){ return Month(2); };
    ...
    static Month Dec(){ return Month(12); };
    int getInt( void ) const{
        return month;
    }
private:
    int month;
    explicit Month( int val ):
        month( val ){
        
    };
}
// 可以直接这样调用
Date( Month::Jan(), Day(30), Year(2015) );
    </pre>
    <br> 当然我们上面只是我们处理数据的一种方式，在 Day 和 Year 中可能还是得加参数检查才行。
    <br>
    <br> 另外一个让我们的代码更意使用的一点是，尽量保证代码风格一致，当然这离不开程序员对代码领域的熟练度。举几个很通用的例子：
    <br> 1. STL 中的容器，同意义的操作基本上接口名称都一致，比如: <code>push_back</code>, <code>size()</code> ...
    <br> 2. 在标准库字符串处理库中，靠前的参数为输出参数，靠后的参数为输入参数， 比如: <code>strcpy( dest, source )</code>, <code>snprintf( buf, len, patten, params... )</code>
    <br> 当然使用正确的变量名和函数名称也是非常重要的。
    <br>
    <br> 最后，如果你有一个接口，这个接口会创建个对象，并返回其指针，那么怎么去释放该对象是你需要仔细考虑的问题。
        而文中给出的答案就是，返回类型为 <code>tr1::share_ptr&lt;T&gt;</code>。 这至少会让调用者意识到，该指针需要而且可能会被回收。


<div class="head head_2">19: 设计 class 犹如设计 type</div>
    <br> 在你设计一个 class 的时候，你要意识到，重载，操作符，内存的分配和归还，对象的初始化和终结都是需要你考虑的，因此按照原文的说法：“你要带着和语言设计者当初设计原始内存时一样谨慎的态度来设计你的 class”。
    <br> 下面是一个不完全的检查清单：
    <ul>
    <li>
        对象应该如何被创建和销毁？
    </li>
    <li>
        对象的初始化和对象的赋值应该有什么样的差别？这可能会涉及到：构造函数，赋值函数，拷贝复制函数
    </li>
    <li>
        对象应该是以 passed by value 来传递还是 passed by refrence of const 来传递。
    </li>
    <li>
        对象中属性的值域，函数入参的边界检查是否都准备妥善？
    </li>
    <li>
        是是否继承了其他的 class, 你是否有遵守你继承 class 的规范 ( virtual, non-virtual )? 你的 class 是否会被其他 class 继承？如果可能被继承你是否要考虑你的函数申明（比如析构函数）？
    </li>
    <li>
        你新的 type 需要怎样的转换？ 如果你需要，那么你是否有编写类型转换函数？比如你的构造函数可能被标注为 explicit
    </li>
    <li>
        你的 class 应该具备那些操作符，和函数？你需要仔细思考这些操作符/函数的意义。
    </li>
    <li>
        编译器默认给你生成的函数是你需要的吗？
    </li>
    <li>
        什么是新 class 的"未声明接口" (undeclared interface)? 它对效率、异常安全性〈见条款 29) 以及资源运用(例如多任务锁定和动态内存)提供何种保证?
        你在这些方面提供的保证将为你的 class 实现代码加上相应的约束条件。-- 原文复制
    </li>
    <li>
        的新 class 有多么一般化? 或许你其实并非定义一个新 class, 而是定义一整个 class 家族。果真如此你就不该定义一个新 class, 而是应该定义一个新的 class template。-- 原文复制
    </li>
    <li>
        真的需要一个新 class 吗? 如果只是定义新的 derived class 以便为既有的 class 添加机能，那么说不定单纯定义一或多个 non-member 函数或 templates. 更能够达到目标。-- 原文复制
    </li>
    </ul>



<div class="head head_2">20: 宁以 pass-by-refrence-to-const 替换 pass-by-value</div>
    <br> 原因很简单，就是 <code>pass-by-refrence-to-const</code> 在底层的实现为指针的传递，而 <code>pass-by-value</code> 则是需要通过拷贝构造函数生成一个新的对象进行传递。
    <br> 原因之一是：在大部分场景下你的 class 执行一次拷贝构造函数的开销往往是要远远大于指针的传递的，而且别忘了你在离开函数作用域的时候还需要调用析构函数
    <br> 原因之二是：如果你有一个派生类对象，而你想把这个对象传递给一个基类对象类型的函数，这是，在传递参数时调用的就是基类的拷贝构造函数，而最后构造出来的对象可能已经和你之前传递进去的那个对象相距甚远了。
    <br> 但是这也有一些例外的情况，比如 int 类型。



<div class="head head_2">21: 必须返回对象时，别妄想返回其 refrence</div>
    <br> 这里我们先用反正法。你可能可以以下面的方式返回 refrence, 但都会在一些场景存在问题。如下所示：
    <pre>
// 1
T &func(){
    T a;
    return a;    
}
// 该函数返回值早已经释放，其行为是未定义的

// 2
T &func(){
    T *a = new T;
    return *a;
}
// 该函数会存在两个问题
// a. 该地址由谁释放
// b. 存在 T a = func(b) * func(c) * func(d); 这种场景，会存在内存泄露


// 3
T &func(){
    static T a;
    // or private T a in your class
    return a;
}
// 假如 a 和 b 都是该函数返回的 refrence, 在这种场景下会存在问题 ( a*b == c*d )
    </pre>



<div class="head head_2">22: 将成员都声明为 private</div>
    <br> 1. 首先声明为 private 是为了类的封装性，如果被设置成 public, 那么成员将会在任何时间出现任何值，这将大大增加误用和异常的概率。
    <br> 2. 其次大部分情况下成员的读和写是不同角色操作的，这时候我们可能需要为成员设置只读，只写。读写来管理成员的访问权限。
    <br> 3. 如果我们将成员以函数的形式暴露出去，即便以后表达该成员的意义存在变化（比如说之前只需要一个成员表达，后续可能需要通过一系列函数进行推导），
        那么对于使用者而言，都不需要做任何其他的操作。（比如说一个图形应用项目初期，你可能只需要展示一张静态的背景图片，而到后期，你可能需要根据不同的条件现实不同的背景图片）
    <br> 4. 如果你的类会有一大批继承者，那么这个时候如果你需要修改或者取消一个成员，想想这会牵扯多大的改动？？？我想这应该是你不愿意看到的。
    <br> 另外，对成员标注成 protected 在继承情况下的效用其实和 public 是一样的，因此给你的选择是将你的成员函数设置成 private 吧。



<div class="head head_2">23: 宁以 non-member, non-friend 替换 member 函数</strong> </div>
    <br> 注意，并不是完全抛弃成员函数，按照之前的规则， class 不能抛出成员变量，然后 class 又不能从 class 中抛出接口函数，这个 class 就与世隔绝了。
    <br> 这里的观点主要是说明，如果一个成员，或者一个过程，已经被抛出一次了，那么你应该尽量少的在额外的接口涉及到这些成员或者过程。
    <br> 这里主要涉及的是 class 的封装性，一旦一个成员或者过程被从越多的接口暴露，那么用户就会有更多的途径来访问这些封装的资源，这主要会有两个问题：
    <br> 1. 如果以后你要修改这些资源，你会要花更多的尽力去检查你的改动是否合理（因为分支变多了）
    <br> 2. 因为你从多个角度为一个资源提供了访问接口，此时 class 的封装性会大大降低，这也会限制 class 的可扩展性
    <br> 而文中提供的方法即是将那些必要的逻辑放到 class 的 namespace 空间中。
    <br> 而文中列举的例子如下： 
    <pre>
namespace A_SPACE{

class A{
    ...
    void B(){

    };
    void C(){

    };
    void D(){

    };
    ...
    // F 并不明智
    void F(){
        B();
        C();
        D();
    }
}

// 这个 F_... 更明智
void F_inspace( A &a ){
    a.B();
    a.C();
    a.D();
}

}
    </pre>
    <br> 但我觉得这一跳有点牵强，因为大部分的其他语言都不允许在 class  之外建立函数。虽然以上两点是实际开发中会遇到的问题，但是对于熟悉 java 开发者，这可能有点做过头了。
    <br>


<div class="head head_2">24: 如果有大量的参数需要类型转换，请使用 non-member 函数</div>
    <br> 虽然该条规则从表面上看是一个普世规则，但是这本书中提到的例子却是一个特例，而我又没有更多这方面的经验，因此先将该例子标注在这里，以后遇到此类问题，万一还记得的话，再完善之。
    <br> 虽然在构造函数一般推荐标注为显示的（ <code>explicit</code> ), 但是在数值计算领域却是一个特例，因为隐式转换经常会让你的表达式看起来非常的简洁美观，当然也更方便开发去运用。
    <br> 但在实际设计类的时候也很容易想到面向对象的原则，但这个原则在实现操作符号的时候可能存在一个问题，例子如下：
    <pre>


class A{
    A( int val );
    
    ...
    A operation*( A &t );
    ...

}

int a = 1;
A b( 2 );
A c = a*t; // 成功
A d = t*a; // 失败，因为编译器找不到 int::operation*( A ) 的方法，也找不到 ::operation( T t, A a ) 的方法
    </pre>
    <br> 因此，这个时候我们用 A 的非成员函数（ non-membere ) 可以非常轻易的解决这个问题，如下：
    <pre>
A operation( int val, A a ){
    ...
};

A operation( A a, int val ){
    ...
};

// 或者使用模板，前提条件是 A 要实现可能的从 T 到对象 A 的构造函数
template&lt; typename T &gt;
A operation( T val, A a ){
    ...
};

A operation( A a, T val ){
    ...
};

    </pre>


<div class="head head_2">25: 考虑写出一个不抛异常的 swap 函数</div>
    <br> swap 即置换两个对象，意思是将两个对象的值赋予对方。默认情况下该动作是由标准程序库提供的 swap 算法完成的。其典型的实现如下所示：
    <pre>
namespace std{
    template&lt;typename T&gt;
    void swap( T& a, T& b ){
        T temp(a);          // 该处用到了赋值函数
        a = b;              // 该处用到了拷贝赋值
        b = temp;           // ...
    }

}
    </pre>
    <br> 你可能注意到，默认 swap 函数会直接调用 copy 和 copy assignment 函数进行交换。但在你的应用场景中很可能你的 class 只有极少数需要交换的属性，那使用系统默认的方法可能导致你的 swap 过程浪费过多的系统资源，
        甚至你还要承受 temp 对象的构造与析构过程。此时你可能想要编写一个定制化的 swap 函数。此时你需要做的事情如下所示。
    <ol>
    <li>
        提供一个 public swap 成员函数，让之高效的置换你的类型的两个对象的值。
    </li>
    <li>
        在你的 class 或者 template 所在的命名空间提供一个非成员( non-member ) swap 并令之调用上述 swap 成员函数。
    </li>
    <li>
        如果你调用 swap, 可以使用一个 <code>using namespace_name::swap</code> 来暴漏你定义的方法，之后你可以在当前的作用域中不加 namespace 的方式来调用该 swap 函数。
    </li>
    </ol>
    <br> 最后看起来可能想这样：
    <pre>
narnespace WidgetStuff {
    ...

    template<typenarne T>
    class Widget { ... };

    ...

    template<typenarne T>
    void swap( Widget<T>& a ,
                Widget<T>& b){
        a.swap(b) ;
    }
}

template<typename T>
void doSomething(T& objl, T& obj2)
{
using std:: swap; // 令 std::swap 在此函数内可用

...
swap(objl, obj2);
...

}

    </pre>


<div class="head head_2">26: 尽可能延后变量定义式的出现时间</div>
    <br> 该条规则比较容易理解，原文如下：
    <br> 只要你定义了一个变量而其类型带有一个构造函数或析构函数，那么当程序的控制流 (control flow) 到达这个变量定义式时，你便得承受构造成本:当这个变量离开其作用域时，你便得承受析构成本。
        即使这个变量最终并未被使用，仍需耗费这些成本，所以你应该尽可能避免这种情形。
    <br> PS: 但对于传统 C 语言开发者可能会遇到一个问题，如果你用的编译器是 C99 以前的编译器（比如 C89 ），那么如果你要考虑 C/C++ 代码的可复用性，你必须将所有的变量定义在其他逻辑操作之前。


<div class="head head_2">27: 尽量少做转型动作</div>
    <br> C++ 规则的设计目标之一是，保证"类型错误"绝不可能发生。理论上如果你的程序很"干净地"通过编译，就表示它并不企图在任何对象身上执行任何不安全、无意义、愚蠢荒谬的操作。这是一个极具价值的保证，可别草率地放弃它。 -- 原文
    <br> 不幸的是，转型 (casts) 破坏了类型系统 (type system) 。那可能导致任何种类的麻烦，有些容易辨识，有些非常隐晦。如果你来自 C / Java / C# 阵营，请特别注意，
        因为那些语言中的转型 ( casting ) 比较必要而无法避免，也比较不危险(与 C++ 相较)。但 C++ 不是 C ，也不是 Java 或 C#。在 C++ 中转型是一个你会想带着极大尊重去亲近的一个特性。
    <br> C++ 支持 C 的转型风格，如 <code>(T)expression</code> ；也支持函数转型风格，如 <code>T(expression)</code>。 这两种形式并无太大的区别，纯粹是小括号摆放位置不同。
    <br> 同时 C++ 还支持四种新的转型方式( C++11 引入 ): <code>const_cast&lt;T&gt;(expression)</code>, <code>dynamic_cast&lt;T&gt;(expression)</code>, 
        <code>reinterpret_cast&lt;T&gt;(expression)</code>, <code>static_cast&lt;T&gt;(expression)</code>
    <br> canst_cast 通常被用来将对象的常量性转除( cast away the constness )。它也是唯一有此能力的 C++-style 转型操作符。
    <br> dynamic_cast 主要用来执行 "安全向下转型" ( safe downcasting )，也就是用来决定某对象是否归属继承体系中的某个类型。
        它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作(稍后细谈〉。
    <br> reinterpret_cast 意图执行低级转型，实际动作(及结果)可能取决于编译器，这也就表示它不可移植，例如将一个 pointer to int 转型为一个 int。
        这一类转型在低级代码以外很少见。本书只使用一次，那是在讨论如何针对原始内存 (raw memory) 写出一个调试用的分配器 (debugging allocator) 时，见条款 50。
    <br> static_cast 用来强迫隐式转换 (implicit conversions) ，例如将 non-const 对象转为 const 对象(就像条款 3 所为) ，或将 int 转为 double 等等。
        它也可以用来执行上述多种转换的反向转换, 例如将 void* 指针转为 typed* 指针，将 pointer-to-base 转为 pointer-to-derived。
        但它无挂将 const 转为 non-canst (这个动作只有 canst cast 才办得到）。

    <br>
    <br> 为什么要搞这么复杂？老式转型不香吗？原因其一在于将在开发过程中我们会将转型进行人为的分类，从而在类型转换出问题的时候更加方便定位问题；
        原因之二是方便编译器诊断错误（比如，你不能在无意识的情况下将一个 const 类型转化为 non-const 类型， 除非你使用 const_cast ）。
    <br> 程序员往往会存在一个误区，认为转型只是告诉编译器如何处理代码，但实际上其实不是。举一个很简单的例子， int 和 double 在内存中的表示方式完全不同，因此编译器在编译的过程中会为止生成一个转换过程，如下所示：
    <pre>
int i = 0;
double y = static_cast&lt;T&gt;(i);
    </pre>
    <br> 或许这个例子非常的明显，但是下面这两个例子嘞？派生类指向的地址可不能直接赋值给基类指针（往往会存在偏移）。
    <pre>
// 这个嘞
class base{...};
class derived: public base{...};
derived d;
base *b = &amp;b;  // err, 因为基类中可能存在虚函数

// 上面那个不够明显那么这个嘞
// 这个嘞， 不会 base1 和 base2 的指针都是一个吧
class base1{...};
class base2{...};
class derived: public base{...};
derived d;
base1 *b1 = &amp;b; // err
base2 *b2 = &amp;b; // err
    </pre>
    <br> 下面是原文中一段发人深省的一段话：“但请注意，我说的是有时候需要一个偏移量。对象的布局方式和它们的地址计算方式随编译器的不同而不同，
        那意味"由于知道对象如何布局"而设计的转型，在某一平台行得通，在其他平台并不一定行得通。这个世界有许多悲惨的程序员，他们历经千辛万苦才学到这堂课。”

    <br>
    <br> 有时候我们还会写一些误认为正确的代码，比如下面这样：
    <pre>
class A{
public:
    int a;
    virtual void set_a(void){
        a = 10;
    }

};

class B: public A{
public:
    int a;

    void set_a(void){
        a = 1;
        static_cast&lt;A&gt;(*this).set_a();
        std::cout &lt;&lt; a &lt;&lt; std::endl; // err; variable a still equal 1
    }
};

// 如果上面不明显，那么下面这样写嘞？
class B: public A{
public:
    int a;

    void set_a(void){
        A ca = static_cast&lt;A&gt;(*this);
        ca.set_a();
        std::cout &lt;&lt; a &lt;&lt; std::endl;
        std::cout &lt;&lt; ca.a &lt;&lt; std::endl;
    }
};
    </pre>

    <br>
    <br> 在探究 dynamic_cast设计意涵之前值得注意的是, dynamic_cast 的许多实现版本执行速度相当慢。 例如有一个很普遍的版本基于 "class 名称之字符串比较" 来确定转换地址的版本,
        如果你在四层深的单继承体系内的某个对象身上执行 dynamic cast, 每一次 dynamic cast 可能会耗用多达四次的 strcmp 调用，用以比较 class 名称。-- 原文
    <br> 但是有时候你可能手里只有一个指向派生类的基类地址指针，但此时你可能想要访问派生类的某些特性（这时你可能马上想到了 dynamic_cast )。慢着，你其实有两种方式可以避免使用 dynamic_cast :
    <br> 方式一：使用容器，并在其中存储直接指向派生类的指针（通常是智能指针），当然，你可能无法在一个容器内存储所有的派生类指针；
    <br> 方式二：在基类中为所有可能从基类访问派生类的方法都建立一个虚函数 ( virtual function );
    
    <br>
    <br> 当然，我们可能无法完全不用转型，但优良的 C++ 代码总时很少使用转型的。



<div class="head head_2">28: 避免返回 handles 指向对象内部成分</div>
    <br> 该规则没有上一条那么复杂，仅仅是因为，如何你返回了指向对象内部成分的 handler ( refrence / point / iterator ) 之后, 外部的函数可能通过一些特殊的方法修改到内部的成员，而这会破坏类的封装性。
        还有一个原因是，有可能在外部通过 handler 访问内部数据的时候，内部数据被释放了，从而可能导致程序进入不可知的状态，甚至崩溃。
    <br> 一个稍微可以缓解外部修改内部函数的方法即使在在返回 handler 的函数，对返回参数加上 const 进行修饰如下所示：
    <pre>
class A{
public:
    T value;
    ...
    T &func_return_value( void ) const{

    }; // 危险，返回的 T 有可能被 修改

};

class A{
public:
    T value;
    ...
    const T &func_return_value( void ) const{

    }; // 稍微安全，去除 handler 的写权限， 如果是指针，有可能被强转

};
    </pre>
    <br> 但除非万不得已，还是不建议将类的内部成员暴漏出来。



<div class="head head_2">29: 为 “异常安全” 而努力是值得的</div>
    <br> 任何使用动态内存的东西（例如所有的 STL 容器），如果无法找到够的内存以满足需求，通常都会抛出一个 <code>bad_alloc</code> 的异常。
    <br> 异常安全的三个保证：
    <br> 基本承诺：如果抛出异常，程序内的任何事物任保持在有效状态下。没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态（例如所有的 class 约束条件都继续获得满足)。
    <br> 强烈保证：如果异常被抛出，程序状态不改变。调用这样的函数需有这样的认知：如果函数成功，就是完全成功，如果函数失败，程序会回复到 “调用函数之前” 的状态。
    <br> 不抛掷异常 ( nothrow ) 保证：承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。作用于内置类型(例如 ints ，指针等等 ) 身上的所有操作都提供 nothrow 保证。这是异常安全码中一个必不可少的关键基础材料。
    <br> 接下来是一些帮助我们应付开发过程中防止异常发生的例子：
    <br> 1. 内存的释放可以使用 share_ptr, 在指针赋值的过程中，上一个存在 share_ptr 实例中的对象将会被释放；
    <br> 2. lock_guard 如果你用到了互斥锁， lock_guard 会帮助你在异常发生的时候确保你的锁被释放；
    <br> 3. copy - and - swap, 但我觉得 copy - modify - swap 更加合适点，这几乎是异常安全强烈保证的绝对可行的一个方案，但问题就是有些耗资源。
    <br> 最后，虽然你会小心翼翼的确保你的程序不出问题，但难免你会松懈，但你需要记住一点，你的程序异常安全做得有多好，依赖于你做得最不安全的那部分代码有多安全。



<div class="head head_2">30: 透彻了解 inlining 的里里外外</div>
    <br> 1. inline 像函数，动作像函数，但是比宏好用得多，可以调用它们又不需蒙受函数调用所招致的额外开销。--原文
    <br> 2. 编译器通常会分析 inline 的语义从而免除调用，浓缩代码。
    <br> 3. inline 的会增加目标代码大小，一台内存有限的机器上，过度热衷 inlining 会造成程序体积太大(对可用空间而言)。即使拥有虚内存, inline 造成的代码膨胀亦会导致额外的换页行为 ( paging ),
        降低指令高速缓存装置的击中率 (instruction cache hit rate) ，以及伴随这些而来的效率损失。换个角度说, 如果 inline 函数的本体很小，编译器针对 "函数本体" 所产出的码可能比针对"函数调用"所产出的码更小。
        果真如此, 将函数 inlining 确实可能导致较小的目标码(object code) 和较高的指令高速缓存装置击中率!
    <br> 4. inline 可被隐喻提出（将函数写在 class 定义式内），也可被明确提出（在函数定义式前 + inline 修饰符）。
    <br> 5. inline 通常放置在头文件中，因为编译器在编译阶段会进行 inlining( 将函数替换成被调用的本体 ), 此时编译器必须知道本体长什么样子。
        Templates 通常也被置于头文件内，因为它一旦被使用，编译器为了将它具现化，需要知道它长什么样子。 
    <br> 6. Template 的具现化与 inlining 无关。如果你正在写一个 template, 而你认为所有根据此 template 具现出来的函数都应该 inlined, 请将此 template 声明为 <code>inline</code>
    <br> 7. 并不是所有申明为 inline 的函数都会被 inlining, 比如包含复杂调用的（循环/递归），或者大部分虚函数。这些叙述整合起来的意思就是:
        一个表面上看似 inline 的函数是否真是 inline, 取决于你的建置环境，主要取决于编译器。幸运的是大多数编译器提供了一个诊断级别: 如果它们无法将你要求的函数 inline 化，会给你一个警告信息(见条款 53) 。
    <br> 8. 有时候虽然编译器有意愿 inlining 某个函数，还是可能为该函数生成一个函数本体。比如被函数指针指向的一个 inline 函数。
    <br> 9. 将构造和析构函数设置成 inline 是不合适的，因为编译器在构造和析构的时候可能做一些你没有显示定义的过程。
    <br> 10. 最后一个建议是：大多数 inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级 (binary upgradability) 更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。


<div class="head head_2">31: 将文件间的编译依赖关系降至最低</div>
    <br> 将该条目列举再这里的主要原因时加快你的编译速度，避免你改动了一个 class 结果导致大量的代码需要进行重新建构。
    <br> 而避免这一现象出现的手段即使，防止易改动的头文件在大量的文件中被引用。
    <br> 而解决这个问题的方法有这么几个：
    <br> 1. 前置声明，但这一方法只适用于你的类只使用了 refrence 和 指针的场景。
    <br> 2. 程序库头文件应当 “完全而且仅有声明式” 的形式存在。这种作物无论是否涉及 template 都适用。
    <br> 个人在项目中还没有遇到项目大到会影响编译心情的问题，因此对这条感触不深，感觉一味的追求这种效率，对工程进度反而时一种弊端。


<div class="head head_2">32: 确定你的 public 继承服从 <code>is a</code> 的关系</div>
    <br> 如果你令 class D ("Derived门以 public 形式继承 class B ("Base") ，你便是告诉 C++ 编译器(以及你的代码读者)说，每一个类型为 D 的对象同时也是一个类 型为 B 的对象，反之不成立。
        说人话：每个学生都是人，但并不是每个人都是学生。


<div class="head head_2">33: 避免覆盖继承带来的名称</div>
    <br> 有时候你会有意无意的覆盖调基类中的函数，像下面这种情况，
    <pre>
#include &lt;iostream&gt;
using namespace std;

class A{
public:
    int a;
    virtual void func1(void) = 0;
    virtual void func1( int val ){
        a = 2;
    }
};

class B: public A{
public:
    using A::func1;
    virtual void func1(void){
        a = 3;
    }
};

int main( int argc, char *argv[] ){
    B b;

    b.func1();
    b.func1( 0 );
    return 0;
}
    </pre>
    <br> 如果你忘记加上 <code>using A::func1;</code>, 那 <code>b.func1( 0 )</code> 就会调用失败。而且无论 func1 是虚函数还是非虚函数都会出现这种现象。
    <br> 而其原因就是 C++ 中以作用域为基础的 “名称遮掩规则” ，因此基类中的 func1 被派生类的 func1 遮蔽住了。
    <br> 但我觉得这不是一个很大的问题，因为如果你真的遇到了这个问题，编译器在编译阶段就会给你像下面这样的提醒，但前提是你需要知道产生这个错误的原因，否则你可能会深深陷入抱怨 C++ 的心境了。
    <pre>
> g++ -o test main.cpp&& ./test
main.cpp: In function ‘int main(int, char**)’:
main.cpp:30:12: error: no matching function for call to ‘B::func1(int)’
   30 |     b.func1( 0 );
      |     ~~~~~~~^~~~~
main.cpp:18:18: note: candidate: ‘virtual void B::func1()’
   18 |     virtual void func1(void){
      |                  ^~~~~
main.cpp:18:18: note:   candidate expects 0 arguments, 1 provided
    </pre>
    <br> 当然，有时候基类可能为我们准备了非常多的重载函数，但在派生类中我们可能并不需要，并不想要继承这么多函数，那使用上面的方法可能就显得不妥了，而自己实现一遍似乎也是非常低效的。
        此时此刻，我们需要用到一个名为 "转交函数" 的技术（ forwarding function ）。如下所示：
    <pre>
#include &lt;iostream&gt;
using namespace std;

class A{
public:
    int a;

    A():a(0){
    }
    virtual void func1(void){
        a = 1;
    };
    virtual void func1( int val ){
        a = 2;
    }
    virtual void func1( double val ){
        a = 3;
    }
};

class B: public A{
public:
    // using A::func1;
    virtual void func1(void){
        A::func1( 0.1 );        // forwarding function
        // a == 3;
    }
};

int main( int argc, char *argv[] ){
    B b;
    b.func1();
    return 0;
}
    </pre>



<div class="head head_2">34: 区分接口继承和实现继承</div>
    <br> 类的继承可拆分为两个维度，继承接口和继承实现。在设计类的时候我们需要清楚的考虑好我们自己的需求：
    <br> 如果我们仅仅想要派生类集成接口，那么我们可以将该函数设计为纯虚函数；
    <br> 如果我们想要派生类继承接口，但必要的时候也可以提供默认函数供调用。那么此时我们可以有两种方案。
        第一种是提供一个纯虚函数，另外提供一个 protected 的默认非虚函数，如果用户想要调用默认实现，则可以直接调用；
        第二种是提供一个纯虚函数，并且提供一个纯虚函数，并为之提供一个默认的实现（是的，你没看错，纯虚函数也可以被实现，编译器不会被报错，只是调用该实现的时候一定要制定类名）。
    <br> （其实是有三种方案，还有一种是将接口定义为一个非纯虚的虚函数，只不过这种很容易被误调用）
    <br> 最后，如果我们不想要派生类重新实现某个函数，我们可以将该函数设置为非虚函数。（当然你可以重写非虚函数，但这会造成你用基类指针调用派生类时产生相当可怕的灾难）。
    <br> 其实最后一项还体现在变量上，如果在基类和派生类中同时申明了同名变量，这时使用基类指针访问到的是基类的变量，而派生类 hander 访问到的是派生类的变量。
        而对于这一点，很可惜，我们没有什么可应付的技术。



<div class="head head_2">35: 考虑虚函数以外的其他选择</div>
    <br> 虚函数主要用于，派生类可能需要依照自身特性来改变基类默认行为的场合，而这个需求有几种替代方案，有时不妨考虑一下：
    <br> 方案一：使用非虚 public 函数调用 private 的虚函数，基类依据自身场景看是否需要重写虚函数的默认实现，这种方法主要用于可能需要在虚函数提供的功能前后执行某些调用过程，
        比如权限访问控制，锁控制，日志记录等场景。
        当然虚函数也不一定是要 private 的，但为了防止某些代码越界调用，破坏系统的整体设计，最好还是设计成 private。
    <br> 方案二： 使用函数指针替换虚函数，基类可在构造函数中依具体情况设置默认实现，或者接受派生类的替换，甚至在运行时可动态切换方法；
    <br> 方案三： 使用 <code>tr::function</code> 替换虚函数，该方案是方案二的增强版本，该方案可兼容存在隐式转换的各种函数，如：（普通的函数指针可达不到此效果）
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tr1/functional&gt;

using namespace std;

int func1( const char *str ){
    cout &lt;&lt; str &lt;&lt; endl;
    return 1;
}

short func2( const char *str ){
    cout &lt;&lt; str &lt;&lt; endl;
    return 2;
}

short func3( string str ){
    cout &lt;&lt; str &lt;&lt; endl;
    return 3;
}


int main( int argc, char *argv[] ){

    <strong>tr1::function&lt;int (const char *)&gt; f1;</strong>

    f1 = func1;
    cout &lt;&lt; "test func1 ret -&gt; " &lt;&lt; f1( "Enter func1" ) &lt;&lt; endl;

    f1 = func2;
    cout &lt;&lt; "test func2 ret -&gt; " &lt;&lt; f1( "Enter func2" ) &lt;&lt; endl;

    f1 = func3;
    cout &lt;&lt; "test func3 ret -&gt; " &lt;&lt; f1( "Enter func3" ) &lt;&lt; endl;

}
    </pre>
    <br> 方案四： 如果一个方法需要派生类重新定义，那么是否有可能该方法并不属于该类，或者可以单独抽象成另外一个方法类？
        该方案即是将方法做成一个单独的类，之后再将该方法类申明为原来那个类的成员，派生类可以将该成员替换成自己的实现。
        (我能想到的一个例子是 java 中的线程类)
    <br> 这里需要注意的是，将功能从类中迁移到类外的一个缺点是方法不能再访问到类内部的成员了。


<div class="head head_2">36: 绝不重新定义继承而来的 non-virtual 函数</div>
    <br> 这一点很好理解，像下面这个例子，当你以基类指针访问派生类对象的一个非虚（ non-virtual ）函数时候，你可能以为你访问的是派生类的非虚函数，而你实际上访问的是基类的非虚函数，
        原因是因为非虚函数都是静态绑定的，在编译的时候就已经计算好调用的函数地址，而从基类指针进行访问的函数，很明显会被编译器识别为基类对象的某个函数，
    <pre>
class A{
public:
    void func1(void){
        // do something
    }
};
class B: public A{
public:
    void func1( void ){
        // do other thing
    }
};
    </pre>


<div class="head head_2">37: 绝不重新定义继承而来的默认参数值</div>
    <br> 这一点与 36 点类似，默认值是静态绑定的，像下面这个例子， 当你以基类指针去调用派生类对象的某个拥有默认参数的虚函数的时候，调用的过程是派生类的，但给的默认参数是基类的，
        我想这应该不是你想看到的效果。
    <pre>
class A{
public:
    virtual void func1( int val = 1 ){
        cout &lt;&lt; "A def count: " &lt;&lt; val &lt;&lt; endl;
    }
};
class B: public A{
public:
    virtual void func1( int val = 2 ){
        cout &lt;&lt; "B def count: " &lt;&lt; val &lt;&lt; endl;
    }
};
B b;
A *a;
a = &amp;b;
a-&gt;func1();

// 输出：
//    B def count: 1
    </pre>


<div class="head head_2">38: Model <code>has-a</code> or <code>is-implemented-in-terms-of</code> through composition</div>
    <br> 我觉得中文翻译太晦涩了，因此在此处我保留英文的原文
    <br> A 继承 B, 可能意味着 A 是一种 B ( 规则 32 ), 但也可能表示 A 包含 B ( has-a ), 比如每个人都有一个地址，但我们不能说人是一个地址。
    <br> 另一个概念是， A 是由 B 实现出来的 ( is-implemented-in-terms-of ), 比如我们可以使用链表实现一个集合（请查看原文）


<div class="head head_2">39: 明智而审慎的使用 private 继承</div>
    <br> 对于 private 继承，编译器并不会自动的将一个派生类对象转换为基类对象；
    <br> 而且基类内所有 public 和 protected 的属性都将变成 private 属性，并且无法访问基类中 private 成员；
    <br> 一般而言， private 继承是非必须的，因为这可以通过在类中定义某个类的变量来实现，如下所示，其中 B 和 C 都能达到同样的效果：
    <pre>
class A{
public:
    void func1( void ) {
        printf( "A func1" );
    }
};

class B: private A{
public:
    void func4( void ) {
        func1();
    }
};

class C{
    A a;
public:
    void func4( void ) {
        a.func1();
    }
};
    </pre>
    <br> 当然可能如果基类中存在虚函数，并且你需要继承并实现该类，这可能是你使用 private 的一个好理由，但是也并不是没有解决方法。
        同样，如果你想调用 protected 属性方法，也可通过这种方式进行操作，如下所示：
    <pre>
class C{
public:
    virtual void func5( void ) = 0;
protected:
    int var_1;
};

class D{
    class E: public C{
    public:
        virtual void func5( void ) {
            printf( "func5\n" );
            var_1 = 1;
        }
        int get_var_1(void){
            return var_1;
        }
    };

    E e;
public:
    void func6(){
        e.func5();
        printf( "var_1 = %d\n", e.get_var_1() );
    }
};
    </pre>
    <br> 最后一个可能成为我们使用 private 的一个情况可能是处于内存空间考虑，因为对于无成员函数的类，如果使用上述定义的方法，
        编译器势必要给目标类分配空间，而如果使用 private 继承的话就可节省这一两个字节的空间。
    <br> 我个人的观点是最好不使用 private 继承，我的原因是 private 继承并没有带来 public 继承那么大的有点，
        而且继承之后内部的属性和方法与派生类的属性方法交织使用的时候，其实给其他合作者造成理解上的麻烦。


<div class="head head_2">40: 明智而审慎的使用多重继承</div>
    <br> 多重继承是复杂的，但并不是不可用的，一个典型的例子是 <code>IOFile</code> <code>InputFile</code> <code>OutputFile</code> <code>File</code>
    <br> 多重继承一定程度上会增加代码的复杂度，增加理解代码的难度。而且一般能用多重继承能解决的问题我们也能找到单继承的方案，因此在使用多重继承前先确定问自己一个问题 “这是否是必须的”。
    <br> 如果多继承出现钻石型继承的情况下，其公共基类的派生类最好以虚继承的方式继承基类，但使用虚基类一个会使类消耗的内存变大，另一个问题是，访问基类的函数代价便高（变慢）。
    <br> 虚继承在以下几个模式是比较有合理性的：
    <br> 1. public 继承缝合怪： A 继承 B 和 C , A 即使 B, 也是 C。(比如 A 是一年级学生， B 是人， C 是学生)
    <br> 2. public + private 缝合怪： A 是 B, 但是 A 具有 C 技能。
    <br> 3. private 缝合怪： A 拥有 B 和 C 的技能（或者特性）


<div class="head head_2">41: 了解隐式接口和编译器多态</div>



<div class="head head_2">42: 了解 typename 的双重意义</div>



<div class="head head_2">43: 学习处理模板化基类内的名称</div>



<div class="head head_2">44: 将与参数无关的代码抽离 templates</div>



<div class="head head_2">45: 运用成员函数模板，接受所有兼容类型</div>



<div class="head head_2">46: 需要类型转换时请为模板定义非成员函数</div>



<div class="head head_2">47: 请用 traits classes 表现类型信息</div>



<div class="head head_2">48: 认识 template 元编程</div>



<div class="head head_2">49: 了解 new-handler 的行为</div>



<div class="head head_2">50: 了解 new 和 delete 的合理替换时机</div>



<div class="head head_2">51: 编写 new 和 delete 时需固守常规</div>



<div class="head head_2">52: 写了 placement new 也要写 placement delete</div>



<div class="head head_2">53: 不要轻易忽视编译器警告</div>



<div class="head head_2">54: 让自己熟悉 TR1 在内的标准程序库</div>



<div class="head head_2">55: 让自己熟悉 bootst</div>


</div>









<div class="breadboard">
<div class="head head_1">其他</div>
<ul>

<div class="head head_2">string</strong> 并不是一个类</div>
    <br> string 是 <code>basic_string&lt;char&gt;</code> 的一个 typedef。


<div class="head head_2">RAII ( Resource Acquisition Is Initialization ) 获取资源即初始化</div>
    <br> C++ 中管理资源的一种技术，即在构造函数中创建资源，然后析构函数中创建资源
    <br> 这种技术有个好处，就是，就算发生了异常， C++ 也能够保证资源的释放。
    <br> 常见的 RAII 类有，<code>std::lock_guard</code>, <code>std::auto_ptr</code>, <code>std::tr1::share_ptr</code> ...
    <br> 用户也可以创建自己的 RAII 类。



<div class="head head_2">多重继承中同名函数</div>
    <br> 


</ul>
</div>    























<table><tr>
<td><img width="190" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_AliPay1.jpg" alt=""></td>
<td><img width="200" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_WeChatPa1.jpg" alt=""></td>
</tr></table>
<div class="div_2" id="AuthorizationWarning">
<div class="Text_ZZ">原创文章，版权所有，转载请获得作者本人允许并注明出处</div>
<div class="Text_LB">我是留白；我是留白；我是留白；</div>
</div>
<div class="foot_panel" id="foot_panel">
    <div id="foot_panel_top" >
        <a href="#main_index" class="NoExternal">TOP</a>
    </div>
    <div id="foot_panel_bottom" >
        <a href="#AuthorizationWarning" class="NoExternal">BOT</a>
    </div>
</div>
</body>

<script src="js/PrePost.js"></script>
</html>
