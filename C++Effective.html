<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title>C++ Effective</title>
</head>
<body>

<style id="style_area" >
a{
    text-decoration:none;
}
p{
    line-height: 1.4em;
    text-indent:2em;
    margin-top: 0;
    margin-bottom: 0;
    padding: 0.3em 0;
}
li{
    padding: 0.3em 0;
}
.gray-line{
    color:#F77;
    font-weight: 100;
    font-style: oblique;
    font-size: 0.8em;
}
code{
    line-height: 24px;
    border-bottom: rgb(253, 191, 186) solid 2px;
    margin: 3px 0.5em;
    padding: 2px;

    font-weight: 400;
    font-size: 12px;
    font-style: oblique;
    border-radius: 3px;
    backdrop-filter: blur(2px);
    color: rgb(231,76,60);
}
/* code{
    line-height: 20px;
    margin: 3px;
    padding: 2px;
    border-radius: 3px;
    color: #eb3f2f;
    font-weight: bold;
    font-size: 12px;
    margin: 3px;
    background-color:#f0f0f0;
    border-right: 1px solid #a9a9a9;
    border-bottom: 1px solid #a9a9a9;
    backdrop-filter: blur(2px);
} */
pre{
    border-radius: 4px;
    background-color: rgb(247,247,247,0.3);
    border: 1px solid #aaa;
    line-height: 1.182em;
    overflow: auto;
    font-size: 11px;
    padding: 16px;
    margin: 10px;
}
img{
    opacity:1;
    margin: 10px;
}
.breadboard{
    box-shadow: 0 1px 4px 0 rgba(0,0,0,0.37);
    margin: 5px 2% 45px;
    padding: 10px;
}

.head_index{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: center;
}
.head_1{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 4px #133152 solid;
    width: 99%;
    margin-top: 1.5em;
}
.head_2{
    color: #163a60;
    font-size: 25px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 2px #163a60 solid;
    width: 99%;
    margin-top: 1.25em;
}
.head_3{
    color: #1a426e;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.head_4{
    color: #1d4a7b;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.div_2{
    margin: 5px 2% 45px;
    padding: 40px;
    height: 100px;
    text-align: center;

}

.img_center{
    text-align: center;
}
.img_left{
    text-align: left;
    margin-left: 4em;
}
.note_msg{
    color: #eb3f2f;
    font-weight: 600;
}

.offset_1em{margin-left: 1em;}
.offset_2em{margin-left: 2em;}
.offset_3em{margin-left: 3em;}
.offset_4em{margin-left: 4em;}
.offset_5em{margin-left: 5em;}
.offset_6em{margin-left: 6em;}
.offset_7em{margin-left: 7em;}
.offset_8em{margin-left: 8em;}
.offset_9em{margin-left: 9em;}
.offset_10em{margin-left: 10em;}

.green_text{
    color: green;
}
.red_text{
    color: red;
}
.purple_text{
    color: purple;
}

.limit_window_size{
    /* overflow:auto; */
    max-height:30em;
    overflow-y:auto;
    word-wrap:break-word;
    word-break: normal;
    white-space: pre-wrap;
    margin:10px;
}

.child_red2_key li strong{
    color: red;
}
.child_red1_key li strong{
    color: red;
}
.child_red2_key li strong{
    color: #F77;
}
.child_red3_key li strong{
    color: #Faa;
}

.foot_panel{
    position:fixed;
    right:3em;
    bottom: 3em;
    width:6em;
    height:30px;
    padding:15px 5px 5px 15px;
    background-color:rgb( 157, 157, 157, 0.618 );
    border-radius: 8px;
}
#foot_panel_top{
    display: inline;
    border-right: 5px solid #eee;
}
#foot_panel_top a{
    width:4em;
}
#foot_panel_bottom {
    display: inline;
    margin-left: 5px;
}
#foot_panel_top a{
    width:4em;
}

#main_index li{
    line-height: 17px;
    font-size: 16px;
}
</style>




<div class="breadboard">
<div class="head_index">目录</div>
<div><ol id="main_index">
</ol></div>
</div>










<div class="breadboard">
<div class="head head_1">原则</div>

<ol>

<li><strong>将 C++ 看成联邦语言</strong>
    <br> C++ 大体上可看坐 C, C with class, Temeplate, STL 的一个集合
</li>

<li><strong>尽量使用 <code>const</code>, <code>enum</code>, <code>inline</code>, <code>template</code> 代替宏定义 </strong>
    <br> 主要有以下三个问题：
    <br> 1. 因为宏定义如果出现为题编译其很难定位问题点
    <br> 2. 其次宏定义是全局性的无法进行区域化
    <br> 3. 最后我们在设计宏定义表达式的时候很容易出问题
</li>

<li><strong>多用 const</strong>
    <br> const 语法虽然变化多端，但并不莫测高深。如果关键字 const 出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。
    <br> const 修饰的函数，返回的值也应该是 const 类型的
    <br> 如果一定要在 const 函数中修改成员，那么可以使用 <code>mutable</code> 修饰该成员。
</li>

<li><strong>确保所有的变量在使用前都初始化了</strong>
    <br> C part of C++ 类的变量不会确保初始化， non-C part of C++ 会确保初始化
    <br> 但你很难确保你记住这些规则，最好的方法就是在使用前先初始化所有变量。
    <br> 因为成员的初始化时更具申明的顺序来的，而不是根据初始化列表的顺序来的，这有时候会造成困惑，为了解决这种困惑，你应该尽量保证初始化列表中的顺序与类成员申明顺序一致。
    <br> static 对象时再程序退出的时候才会被销毁。（即静态变量的析构函数时程序退出时才会调用）
    <br> static 成员因为可能分布在程序中的任何位置，因此编译器要推断其合理的初始化顺序是几乎不可能的，因此一个消除这个问题的方法是将 non-local static 对象放到一个自己的专属函数内。
        这些函数返回一个支详该对象的 refrence 中。换句话说也就是 non-local static 被 local static 代替了。而 local static 对象会在“该函数被调用期间”“首次遇到该对象之定义式” 时被初始化。
        而这样又带来一个好处，如果该对象不被访问到，那么该变量的初始化永远不会被调用到（节省初始化资源消耗）。
    <br> 如果 static 对象在多线程中访问，有可能会产生初始化竞态，从而导致不可知的程序错误，消除这种问题的一种方式是在对象单线程状态时，逐个调用一下每个静态函数的 refrence-returning 函数。
</li>

<li><strong>了解 C++ 默默编写并调用了哪些函数</strong>
    <br> 如果你定义了一个类，即使你不对下列函数进行申明，但只要有人尝试调用它们，编译器会为你声明它们。这些函数有 default 构造函数, copy 构造函数, 析构函数, copy assignment 拷贝复制函数，如下所示：
<pre>
class Empty{
public:
    Empty();
    Empty(const Empty &);
    ~Empty();
    Empty & opterator=( const Empty & );
}
</pre>
    <br> non-static refrence 和 non-static const 对象都不能进行拷贝复制。
<pre>
main.cpp:6:7: error: non-static reference member ‘std::string& NameObject<int>::nameValue’, cannot use default assignment operator
main.cpp:6:7: error: non-static const member ‘const int NameObject<int>::objectValue’, cannot use default assignment operator
</pre>
    <br> non-static refrence 和 non-static const 只能在初始化列表进行初始化。
</li>

<li><strong>若不想使用编译器自动生成的函数，就该明确拒绝</strong>
    <br> 将拷贝函数和拷贝复制函数申明为私有函数并不足以在所有条件下禁用编译自动生成的函数，因为友元函数和成员函数还是可以调用到。
    <br> 而解决办法就是，在申明为似有函数的基础上，不去实现此类函数。
    <br> 当然也可以去继承下面的类：
<pre>
class Uncopyable{
protect:
    Uncopyable();
    ~Uncopyable();
private:
    Uncopyable(const Uncopyable &);
    Uncopyable &operator=(const Uncopyable &);

}
</pre>
</li>

<li><strong>为多态墓类声明 virtual 析构函数</strong>
    <br> 可能你将 new 的派生类给基类的指针，而在使用之后 delete 基类指针。此时如果基类析构函数为非虚函数，那么将会调用基类的析构函数，而不是派生类的析构函数。
    <br> 但是如果你将任何函数的析构函数都定义为虚函数，这会造成不必要的开销，因为一旦一个类中存在一个虚函数，则该类对象会存在一个析函数标指针。这将导致不必要的内存开销。
    <br> 此外 C++ 的很多内建类（比如 std::string ）的基类的析构函数都不是虚函数，因此如果你有类派生自这些内建类，千万要注意妥善的使用 delete。
</li>

<li><strong>到让异常逃离析构函数</strong>
    <br> 如果你有一个装在对象的容器，再容器销毁的时候，该容器中所有的对象的析构函数都应该被调用，而此时如果有异常发生，那么系统再同一时刻出现两个异常会导致导致意想不到的问题。
    <br> 而最好的办法是，不要让异常暴漏到析构函数之外。对此有两种操作：
    <br> 1. 捕获该异常，打印报错信息，退出程序
    <br> 2. 捕获该异常，打印报错信息，不让之继续传播（吞下异常）
    <br> 如果你在运行某个操作时候可能发生异常，那么最好的办法是，在析构函数之外简历一个操作函数，确保在析构之前该函数被调用，并将异常处理放在该函数内。
</li>

<li><strong>不要再构造和析构过程中调用 virtual 函数</strong>
    <br> 因为假设你的基类的构造函数内有调用虚函数，那么此时在你申明一个派生类的时候，构造函数内调用的虚函数并不是派生类里面的虚函数，而是基类里面的虚函数。这可能不是你意料中的。
</li>

<li><strong>让 <code>opterator=</code> 返回一个 <code>refrence to *this</code></strong>
    <br> 这是实现连锁赋值的必要条件 ( a=b=c )，也是 C++ 内建库的通用规则
    <br> 该规则同样适用于 <code>+=</code>, <code>-=</code>, <code>*=</code> 等等
</li>

<li><strong>在 <code>operator=</code> 中处理自我复制</strong>
    <br> 
</li>

</ol>

</div>


































<table><tr>
<td><img width="190" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_AliPay1.jpg" alt=""></td>
<td><img width="200" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_WeChatPa1.jpg" alt=""></td>
</tr></table>
<div class="div_2" id="AuthorizationWarning">
<div class="Text_ZZ">原创文章，版权所有，转载请获得作者本人允许并注明出处</div>
<div class="Text_LB">我是留白；我是留白；我是留白；（重要的事情说三遍）</div>
</div>
<div class="foot_panel" id="foot_panel">
    <div id="foot_panel_top" >
        <a href="#main_index" class="NoExternal">TOP</a>
    </div>
    <div id="foot_panel_bottom" >
        <a href="#AuthorizationWarning" class="NoExternal">BOT</a>
    </div>
</div>
</body>

<script src="../js/PrePost.js"></script>
</html>
