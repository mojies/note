<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title>随笔</title>
 <!-- <script defer src="./js/katex.min.js" ></script> -->
 <link rel="stylesheet" href="katex/katex.min.css" >
 <link rel="stylesheet" href="js/bower_components/js-sequence-diagrams/dist/sequence-diagram-min.css"/>

 <script type="text/javascript" src="katex/katex.min.js" ></script>

 <script type="text/javascript" src="js/bower_components/bower-webfontloader/webfont.js"> </script>
 <script type="text/javascript" src="js/bower_components/snap.svg/dist/snap.svg-min.js"></script>
 <script type="text/javascript" src="js/bower_components/underscore/underscore-min.js"></script>
 <script type="text/javascript" src="js/bower_components/js-sequence-diagrams/dist/sequence-diagram-min.js"></script>

</head>
<body>

<style id="style_area" >
a{
    text-decoration:none;
}
p{
    line-height: 1.4em;
    /* text-indent:2em; */
    margin-top: 0;
    margin-bottom: 0;
    padding: 0.3em 0;
}
li{
    padding: 0.3em 0;
}
.gray-line{
    color:#F77;
    font-weight: 100;
    font-style: oblique;
    font-size: 0.8em;
}
code{
    line-height: 24px;
    border-bottom: rgb(253, 191, 186) solid 1px;
    margin: 3px 0.5em;
    padding: 2px;

    font-weight: 400;
    font-size: 13px;
    /* font-style: oblique; */
    border-radius: 3px;
    backdrop-filter: blur(2px);
    color: rgb(231,76,60);
    background-color:#c7c7c7;
}
/* code{
    line-height: 20px;
    margin: 3px;
    padding: 2px;
    border-radius: 3px;
    color: #eb3f2f;
    font-weight: bold;
    font-size: 12px;
    margin: 3px;
    background-color:#f0f0f0;
    border-right: 1px solid #a9a9a9;
    border-bottom: 1px solid #a9a9a9;
    backdrop-filter: blur(2px);
} */
pre{
    border-radius: 4px;
    background-color: rgb(247,247,247,0.3);
    border: 1px solid #aaa;
    line-height: 1.182em;
    overflow: auto;
    font-size: 11px;
    padding: 16px;
    margin: 10px;
}
img{
    opacity:1;
    margin: 10px;
}
table, th, td {
    font-size: 12px;
    border: 1px solid #aaa;
    padding: 2px 0.5em;
    border-collapse: collapse;
}
th{
    font-size: 16px;
}
.breadboard{
    box-shadow: 0 1px 4px 0 rgba(0,0,0,0.37);
    margin: 5px 2% 45px;
    padding: 10px;
}

.head_index{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: center;
}
.head_1{
    color: #133152;
    font-size: 30px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 4px #133152 solid;
    width: 99%;
    margin-top: 1.5em;
}
.head_2{
    color: #163a60;
    font-size: 25px;
    font-weight: bold;
    text-align: left;

    padding-bottom: 10px;
    border-bottom: 2px #163a60 solid;
    width: 99%;
    margin-top: 1.25em;
}
.head_3{
    color: #1a426e;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.head_4{
    color: #1d4a7b;
    font-size: 20px;
    font-weight: bold;
    text-align: left;
    margin: 32px 0 10px 0;
}

.div_2{
    margin: 5px 2% 45px;
    padding: 40px;
    height: 100px;
    text-align: center;

}

.img_center{
    text-align: center;
}
.img_left{
    text-align: left;
    margin-left: 4em;
}
.note_msg{
    color: #eb3f2f;
    font-weight: 600;
}

.offset_1em{margin-left: 1em;}
.offset_2em{margin-left: 2em;}
.offset_3em{margin-left: 3em;}
.offset_4em{margin-left: 4em;}
.offset_5em{margin-left: 5em;}
.offset_6em{margin-left: 6em;}
.offset_7em{margin-left: 7em;}
.offset_8em{margin-left: 8em;}
.offset_9em{margin-left: 9em;}
.offset_10em{margin-left: 10em;}

.green_text{
    color: green;
}
.red_text{
    color: red;
}
.purple_text{
    color: purple;
}

.limit_window_size{
    /* overflow:auto; */
    max-height:30em;
    overflow-y:auto;
    word-wrap:break-word;
    word-break: normal;
    white-space: pre-wrap;
    margin:10px;
}

.child_red2_key li strong{
    color: red;
}
.child_red1_key li strong{
    color: red;
}
.child_red2_key li strong{
    color: #F77;
}
.child_red3_key li strong{
    color: #Faa;
}

.foot_panel{
    position:fixed;
    right:3em;
    bottom: 3em;
    width:6em;
    height:30px;
    padding:15px 5px 5px 15px;
    background-color:rgb( 157, 157, 157, 0.618 );
    border-radius: 8px;
}
#foot_panel_top{
    display: inline;
    border-right: 5px solid #eee;
}
#foot_panel_top a{
    width:4em;
}
#foot_panel_bottom {
    display: inline;
    margin-left: 5px;
}
#foot_panel_top a{
    width:4em;
}

#main_index li{
    line-height: 17px;
    font-size: 16px;
}
</style>




<div class="breadboard">
<div class="head_index">目录</div>
<div><ol id="main_index">
</ol></div>
</div>








<div class="breadboard">
<div class="head head_1">u-boot 启动</div>
<p>
    首先我们要找到 <code>LDSCRIPT</code> ，因为 <code>LDSCRIPT</code> 会指定你目标平台的 lds 文件，
    而 lds 文件将为我们指定函数的入口，在生成目标镜像的时候将会根据该 lds 文件中的配置进行链接。
</p><p>
    <code>LDSCRIPT</code> 的默认定义一般会在相应芯片架构的 KConfig 目录中，如果 u-boot 的硬件板级和默认的不一样，
    则会在板级配置（ xxx_defconfig ） 还会存在一个定义。
    最后，如果发现板级配置中没有指定， Makefile 文件中有一个默认的逻辑，自动的选用对应平台的 lds 文件。
    如下所示：
</p>
<pre>
# vi arch/arm/mach-rockchip/Kconfig
...
config TPL_LDSCRIPT
    default "arch/arm/mach-rockchip/u-boot-tpl.lds"
...
</pre><pre>
# vi .config
...
CONFIG_SPL_LDSCRIPT="arch/arm/cpu/armv8/u-boot-spl.lds
...
</pre><pre>
# vi Makefile
...
ifndef LDSCRIPT
        ifeq ($(wildcard $(LDSCRIPT)),)
                LDSCRIPT := $(srctree)/board/$(BOARDDIR)/u-boot.lds
        endif
        ifeq ($(wildcard $(LDSCRIPT)),)
                LDSCRIPT := $(srctree)/$(CPUDIR)/u-boot.lds
        endif
        ifeq ($(wildcard $(LDSCRIPT)),)
                LDSCRIPT := $(srctree)/arch/$(ARCH)/cpu/u-boot.lds
        endif
endif
...
</pre>
<p>
    下面我们来看一下 <code>u-boot-spl.lds</code>, ( 有关 lds 文件的更多信息可以参考：
    <a href="http://web.mit.edu/rhel-doc/3/rhel-ld-en-3/index.html">Red Hat Enterprise Linux 3</a> 第四章的描述 )
</p>


</div>








<div class="breadboard">
<div class="head head_1">编译相关</div>

<div class="head head_2">arm64 平台汇编解读</div>
<div class="head head_3">一个例子</div>
<p>下面我们看一个简单的例子，C 原型如下所示：</p>
<pre>
int main( int argc, char *argv[] ){
    int a = 1, b, c ;
    a = 1;
    a = 2;
    b = a;
    c = a*b;
    if ( a == b )
        c = 3;
    else
        c = 4;
    return 0;
}
</pre>
<p>
    然后将只编译成汇编文件： <code>gcc -S main.c</code> 或者 <code>clang -S main.c</code>。
    下面我们看一下生成的文件：（注意，不同编译器编译生成的汇编代码会有差异，而且还可能和参数相关，因此你不必在意是否和我生成的代码是否一致）
</p>
<pre>
    .text                                   # 代码段
    .file       "main.c"                        # 
    .globl      main                            # 声明 main 为全局变量
    .p2align    4, 0x90                 # 将代码移动到以四字节对齐的位置
    .type       main,@function                  # 声明 main 为一个函数类型
main:                                       # @main 代码段开始
    .cfi_startproc                          # 与 cfi_endproc 呼应， 标识一个 function 的开始
# %bb.0:
    pushq   %rbp                            # 将之前的 rbp 地址压栈（rsp），防止丢失栈指针
    .cfi_def_cfa_offset 16
    .cfi_offset %rbp, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register %rbp
    movl    $0, -4(%rbp)
    movl    %edi, -8(%rbp)
    movq    %rsi, -16(%rbp)
                                            # a 在栈 -20 的位置
                                            # b 在栈 -24 的位置
                                            # c 在栈 -28 的位置
                                            # 注意不同的编译器，编译出来的相对位置会有些许不同

    movl    $1, -20(%rbp)                   # 将立即数 1 赋值给 a       对应 int a = 1;
    movl    $1, -20(%rbp)                   # 将立即数 1 赋值给 a       对应 a = 1;
    movl    $2, -20(%rbp)                   # 将立即数 2 赋值给 a       对应 a = 2;

    movl    -20(%rbp), %eax                 # 取 a 的值赋值给 eax       
    movl    %eax, -24(%rbp)                 # 将 eax 赋值给 b
                                            # 以上两行对应 b = a

    movl    -20(%rbp), %eax                 # 取 a 的值赋值给 eax 
    imull   -24(%rbp), %eax                 # 取 b 的与 eax 的值相乘并赋值给 eax
    movl    %eax, -28(%rbp)                 # 取 eax 地址中的值给 c
                                            # 以上三行对应 c = a * b

    movl    -20(%rbp), %eax                 # 取 a 的值赋值给 eax
    cmpl    -24(%rbp), %eax                 # 比较 b 的值与 eax 的值
    jne     .LBB0_2                         # 如果不相等则跳转到 .LBB0_2

# %bb.1:                                    # 相等
    movl    $3, -28(%rbp)                   # 将立即数 3 赋值给 c
    jmp     .LBB0_3                         # 跳转到 .LBB0_3
.LBB0_2:
    movl    $4, -28(%rbp)                   # 将立即数 4 赋值给 c

.LBB0_3:
    xorl    %eax, %eax                      # 清空 eax 防止信息泄漏
    popq    %rbp                            # （从 rsp 中）恢复栈指针
    .cfi_def_cfa %rsp, 8
    retq
.Lfunc_end0:
    .size   main, .Lfunc_end0-main
    .cfi_endproc
                                    # -- End function
    .ident  "Android (7284624, based on r416183b) clang version 12.0.5 (https://android.googlesource.com/toolchain/llvm-project c935d99d7cf2016289302412d708641d52d2f7ee)"
    .section        ".note.GNU-stack","",@progbits
    .addrsig
</pre>
<p>
    如果没看懂，也没关系，你可以先看下面的内容，然后再回过头来看前面的这部分代码，就会一目了然了。
</p><p>
    首先我们得知道下面这几个概念：
</p><p>
    首先我们知道，函数的局部变量都存放在栈内，而我们访问定义的局部变量时都是依当前栈加偏移取访问的，因为机器并不懂那个变量时 a/b/c, a/b/c 是给人看的，编译器在帮我们做转换。
    而机器懂的只是，在那个地址，取多少位数据。而如果你写汇编代码，你就一定要记住，那个地址，存放的是什么什么属性的值。
    通常我们会使用 <strong>基地址指针寄存器</strong> 的值加上偏移值取索引对应的局部变量。
    而这里的基地址指针寄存器在 16 位系统中名 <code>bp</code>, 32 位系统 <code>ebp</code>, 64 位系统 <code>rbp</code>。
</p><p>
    另外这里面在进入函数的时候调用了一个 <code>pushq</code>, 出函数之前调用了 <code>popq</code> ，这里分别代表将后叙寄存器的值压栈和将栈顶的值弹到寄存器中（如下所示），为什么要这样操作嘞？
    因为调用函数的时候，函数很有可能会修改 bp 的指针，如果不对其进行恢复，则会影响掉调用方之后函数作用域内变量的访问。
    而这里的栈指针寄存器在 16 位系统中名 <code>sp</code>, 32 位系统 <code>esp</code>, 64 位系统 <code>rsp</code>。
</p>
<pre>
# pushq %rbp
subq $8, %rsp
movq %rbp, (%rsp)

# popq %rbp
movq (%rsp), %rbp
addq $8, %rsp
</pre>
<p>
    然后是大名鼎鼎的指令寄存器：16 位系统中名 <code>ip</code>, 32 位系统 <code>eip</code>, 64 位系统 <code>rip</code>。
    和段地址寄存器 <code>ss</code>。
</p>



<div class="head head_3">编译</div>
<p>
    汇编代码可以通过 <code>as</code> + <code>ld</code> 生成可执行文件，也可以使用 <code>gcc</code> 一部生成，如下所示：
</p>
<pre>
as program.s -o program.o
ld program.o -o program

# or
gcc -o program program.s
</pre>

<ul>
<li>
    <a href="https://developer.arm.com/documentation/dui0742/g/Migrating-ARM-syntax-assembly-code-to-GNU-syntax/Overview-of-differences-between-ARM-and-GNU-syntax-assembly-code">ARM Compiler Migration and Compatibility Guide Version 6.6</a>
</li>
<li>
    <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md">chromium 整理的各个平台 syscalls 清单</a>
</li>
<li>
    <a href="https://www.qemu.org/documentation/">qume -- 一个模拟免费的可执行硬件虚拟化的（hardware virtualization）开源仿真器（Emulator）</a>
</li>
<li>
    <a href="https://cpulator.01xz.net/?sys=arm">一个可以在线调试 asm 程序的网站</a>
</li>
</ul>

<div class="head head_2">LDS Script</div>
<p>
    我们都知道程序的编译分成四个阶段：预处理，编译，汇编，链接。
    比如说一个 <code>.c</code> 文件预处理之后会生成 <code>.i</code> 文件，之后会编译成为汇编文件 <code>.s</code> , 
    汇编文件最后通过汇编生成 <code>.o</code> 文件，然后所有的 <code>.o</code> 文件将通过链接器链接成一个可执行文件。
</p><p>
    这里我们要介绍链接器，链接器是受 LDS 控制的，但大部分情况下我们都不需要指明 LDS 文件，因为链接器会有一个默认的 lds 配置，除非我们需要定制我们的生成文件格式。一个比较常见的场景就是在 u-boot 和 kernel 的编译中。
    你会在这两个工程中发现很多 lds 文件，而这些文件就是配置链接方式的配置文件。
</p>

<p>
    如果你想查看 object 中的 <code>section</code> 字段，你可以使用 <code>objdump</code> 加 <code>-h</code> 选项查看。
</p>
<p>
    如果你想查看 程序 中的 <code>symbols</code> ，你可以使用 <code>nm</code> 或者 <code>objdump</code> 加 <code>-t</code> 选项查看。
</p>

<div class="head head_2">GNU Compiler Collection</div>
<p>
    GNU Compiler Collection 提供了 C, C++, Objective-C, Fortran, Ada, Go, and D 预言的前端，
    同时也提供了以来的基础库（比如 libstdc++ ...）。
    而 GCC 原本是作为开发 GNU operating system 的编译工具。
    而 GUN 操作系统为 100% free 的软件，意在 100% 的遵从开发者的意愿。
</p><p>
    我们努力提供定期的、高质量的版本，我们希望这些版本在各种本机和跨目标（包括 GNU/Linux）上运行良好，并鼓励每个人贡献更改或帮助测试 GCC。
    我们的资源可通过 Git 和每周快照轻松免费获得。
</p><p>
    关于 GCC 的重大决定由指导委员会在使命宣言的指导下做出。
    宣言参考该网站： <a href="https://gcc.gnu.org/gccmission.html">https://gcc.gnu.org/gccmission.html</a>,
    关于 GCC 指导委员会的一些资料参考： <a href="https://gcc.gnu.org/steering.html">https://gcc.gnu.org/steering.html</a>。
</p>

<div class="head head_2">GNU Binutils</div>
<p>
    GNU 工具集主要提供如下工具：
</p>
<div class="tb_format">
    {
        "head": [ "指令", "说明" ],
        "data": [
        ["as", "汇编编译器"],
        ["ld", "连接器"],
        ["gprof", "程序动态分析"],
        ["addr2line", "将程序指令地址转换为所对应的函数名、以及函数所在的源文件名和行号，<br/>将程序指令地址转换为所对应的函数名、以及函数所在的源文件名和行号"],
        ["ar", "创建, 修改, 解压打包文件（不过目前很多情况下都已经被 tar 取代）"],
        ["c++filt", "用解析 C++ 和 Java 中被修饰的变量/函数名"],
        ["dlltool", "创建 Windows DLL 的工具"],
        ["gold", "ELF 文件的可选替代"],
        ["nlmconv", "目标文件转换为 NetWare 可加载模块 ( NetWare Loadable Module )( NetWare 是 Novell 公司发布的网络操作系统 )"],
        ["nm", "列出 .o, .a, .so 中的符号信息，包括诸如符号的值、符号类型以及符号名称等。所谓符号，通常指定义出的函数、全局变量等等。"],
        ["objcopy", "用于拷贝 object 文件"],
        ["objdump", "dump object 文件中的信息"],
        ["ranlib", "生成档案索引 ( 为了兼容，效果与 ar -S 一致 )"],
        ["readelf", "和 nm 功能类似（目前我还不知道这两个之间的差异）"],
        ["size", "文件大小"],
        ["strings", "列出一个文件中的所有可打印字符串"],
        ["strip", "删除 elf obj 中的 symobols "],
        ["windmc", "generates Windows message resources"],
        ["windres", "compiler for Windows resource files"]
        ]
    }
</div>
<p>
    <code>addr2line</code> 典型用法如下所示：
</p>
<pre>
# addr2line -e adb 0x2a3af0 -fapC
0x00000000002a3af0: adb::tls::SHA256BitsToHexString(std::__1::basic_string_view&lt;char, std::__1::char_traits&lt;char&gt; &gt;) at crtstuff.c:?
</pre>
<p>
    <code>c++filt</code> 的典型用法如下所示：
</p>
<pre>
# c++filt _Z5printRKSs
print(std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&)
</pre><p>
    查看动态库的 symbol table 的时候可以使用 <code>nm -D</code> 或者 <code>readelf -s</code>。

    You can see symbols in the dynamic symbol table with nm -D or readelf -s.
</p>




<div class="head head_2">gdb</div>
<p>
    GDB 调试的程序需要在编译的时候加上 <code>-g</code> 选项，否则无法使用 gdb 调试。
    (PS: 较早以前的 C 语言编译器也允许使用 -gg 选项来产生调试信息，但是现在版本的 GDB 不再支持这种格式产生的调试信息，所以不建议使用 -gg 选项。)
</p><p>
    GCC 编译器支持 -O（等于同 -O1，优化生成的目标文件）和 -g 一起参与编译。GCC 编译过程对进行优化的程度可分为 5 个等级，分别为 O0~O4，O0 表示不优化（默认选项），从 O1 ~ O4 优化级别越来越高，O4 最高。
    所谓优化，例如省略掉代码中从未使用过的变量、直接将常量表达式用结果值代替等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。
    而相对于 -O -g 选项，对 GDB 调试器更友好的是 -Og 选项，-Og 对代码所做的优化程序介于 O0 ~ O1 之间，真正可做到“在保持快速编译和良好调试体验的同时，提供较为合理的优化级别”。
</p>

<div class="head head_3">四种 gdb 调试方式</div>
<p>
    一般我们会直接调用 <code>gdb $exename</code> 来调试程序，因为启动的时候会打印一堆免责条款，因此你也可以使用 <code>gdb $exename --silence</code> 屏蔽这些打印信息，当然也可以使用 <code>-q / --quit</code> 。
    如果启动程序的时候需要指定一些参数，则可以使用 <code>--args $exename $args1 $args2 ...</code> 进行个设置。
    如果我们已经进入 GDB 调试模式了，还想修改启动参数的时候，可以通过 <code>set args $args1 $args2</code> 来设置,
    也可以在执行 <code>run</code> / <code>start</code> 的时候将参数接在后面：
    <code>run $args1 $args2 ...</code> or <code>start $args1 $args2 ...</code>
</p><p>
    还有一种情况是，我们已经进入 gdb 环境了，但是需要重新制定调试程序，这时可以使用那个 <code>file</code> 来重新制定调试应用。
</p><p>
    当然如果支持 gdb 调试的程序正在运行中，我们也可以通过 <code>gdb --attach ${PID}</code> 来调试正在运行的程序。
    进入调试模式之后，如果想退出，可以使用 <code>detach</code> 命令使 GDB 调试器和程序分离。
</p><p>
    最后一种，当程序发生崩溃的时候，如果我们配置在程序崩溃的时候产生 coredump，关于如何开启 core dump 功能，可以参考
    <a href=""></a> 。
    调试 core dump 文件需要使用 <code>gdb $exename $core-dump-file</code>，如果我们在调试交叉编译的程序，则可能还需在调试的时候制定 sysroot, 如下所示：
</p>
<pre>
(gdb) set sysroot /sys/root/abs/path
</pre>

<div class="head head_3">gdb 基本调试命令</div>
<p>
    下面列举了一些基本的 gdb 调试命令：
</p>
<div class="tb_format offset_1em">
    {
        "head": [ "指令", "说明" ],
        "data": [
        ["break xxx<br/>b xxx", "在源代码指定的某一行设置断点，其中 xxx 用于指定具体打断点的位置"],
        ["tbreak", "和 break 功能类似，但是该指令仅仅会在断点处暂停一次，暂停一次之后该断点会自动消失"],
        ["run <br/>r", "执行被调试的程序，其会自动在第一个断点处暂停执行。"],
        ["continue <br/>c", "当程序在某一断点处停止运行后，使用该指令可以继续执行，直至遇到下一个断点或者程序结束。"],
        ["next <br/>n", "令程序一行代码一行代码的执行。"],
        ["print <code>xxx</code> <br/> p <code>xxx</code> ", "打印指定变量的值，其中 <code>xxx</code> 指的就是某一变量名。"],
        ["list <br/>l", "显示源程序代码的内容，包括各行代码所在的行号。"],
        ["quit <br/>q", "终止调试。"],
        ["file <br/>exec-file", "指定需要调试的程序"],
        ["detatch", "当我们 attach 到一个正在执行的应用中时，使用该命令可以让 GDB 调试器和程序分离"],
        ["cd", "切换工作目录"],
        ["xxx", "xxx"]
        ]
    }
</div>
<p>
    <code>break</code> 设置断点方式有以下几种：
</p>
<div class="tb_format offset_1em">
    {
        "head": [ "参数类型", "说明" ],
        "data": [
            [ "linenum", "表示要打断点处代码的行号。查看程序原信息可可通过执行 <code>l</code>(小写的) <code>L</code> 查看" ],
            [ "filename:linenum", "filename 表示源程序文件名； linenum 为整数，表示具体行数。<br/>即表示在文件 filename 中的第 linenum 行打断点。" ],
            [ "+offset <br/>-offset", "正整数代表当前暂停位置向下 offset 行，负数则为向上 offset 行。<br/>比如当前暂停在 10 行，设置 +2 则代表在 12 行处打一个断点" ],
            [ "function", "function 表示程序中包含的函数的函数名，即将断点设置为该函数的第一行代码处。" ],
            [ "filename:function", "filename 表示远程文件名， function 表示程序中函数的函数名。<br/>整体的意思是在指定文件 filename 中 function 函数的开头位置打断点。" ]
        ]
    }
</div>
<p>
    <code>break</code> / <code>tbreak</code> 具体有两种形式： <code>(gdb) break xxx</code> <code>(gdb) break ... if cond</code>。
    其中 cond 是一个表达式，比如假如我们有源程序如下所示：
</p>
<pre>
#include &lt;stdio.h>
main()
{ 
     int i = 0;
     for(i=0;i&lt;7;++i)
        printf("%d\n", i);

     return 0;
}
</pre><p>
    如果我们想要在 i == 5 的时候停下，我们可以在 gdb 里面使用如下命令设置断点：
</p><pre>
(gdb) break iter.c:6 if i == 5
</pre>

<div class="head head_3">参考资料</div>
<ol>
<li><a href="https://www.sourceware.org/gdb/">GDB 官方网站</a></li>
<li><a href="https://www.hiyu.space/2021/02/24/GDB%E5%85%A5%E9%97%A8/">GDB入门</a></li>
<li><a href="http://c.biancheng.net/view/8123.html">GDB 是什么</a></li>
</ol>

<div class="head head_2">readelf</div>
<div class="head head_3">elf 文件格式</div>
<p>
    参考: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#:~:text=In%20computing%2C%20the%20Executable%20and,shared%20libraries%2C%20and%20core%20dumps. 
</p>

<div class="head head_3">readelf 支持的参数</div>
<p>
    参考：<code>man readelf</code>
</p>
<ul>
<li><code>-a, --all</code>
    <br> 相当于 -h -l -S -s -r -d -V -A -I 的集合
</li>

<li><code>-h, --file-header</code>
    <br> 显示 ELF 文件开始的文件头信息
</li>

<li><code>-l, --program-headers, --segments</code>
    <br> 显示 segments（段）头信息
</li>

<li><code>-S, --section-headers, --sections</code>
    <br> 显示 section 头信息
</li>

<li><code>-g, --section-groups</code>
    <br> 显示 section 的组信息
</li>

<li><code>-t, --section-details</code>
    <br> 显示 section 详细信息
</li>

<li><code>-e, --headers</code>
    <br> 显示全部头信息，相当于 -h -l -S
</li>

<li><code>-s, --syms, --symbols</code>
    <br> 包含静态符号表信息，显示符号表节信息，包含静态符号表信息 <code>.symtab</code>，和动态符号表信息 <code>.dynsym</code>。
    <br> 如果只关心动态符号表可以直接使用 <code>--dyn-syms</code> 
    <br> 如果符号有相应的版本信息，则会显示该版本信息
    <br> 版本字符串显示为符号名称的后缀，并以 @ 字符开头，例如 <code>foo@Ver_1</code>
    <br> 在解析未版本化引用的符号时，如果该版本是要使用的默认版本，则将显示为后缀，其后跟两个
</li>

<li><code>--dyn-syms</code>
    <br> 显示文件的动态符号表部分中的条目（如果有）。输出格式与 --syms 选项使用的格式相同。
</li>

<li><code>--lto-syms</code>
    <br> 显示文件中任何 LTO 符号表的内容。输出格式与 --syms 选项使用的格式相同。
</li>

<li><code>--sym-base=[0, 8, 10, 16]</code>
    <br> 强制符号表的大小字段使用给定的基数。
    <br> 任何无法识别的选项都将被视为“0”。
    <br> --sym-base=0 代表默认和旧的行为。 对于小于 100000 的数字，这会将大小输出为十进制。 对于大小 100000 和更大的十六进制符号，将使用 0x 前缀。
    <br> --sym-base=8 将以八进制给出符号大小。 --sym-base=10 将始终以十进制给出符号大小。 --sym-base=16 将始终以带有 0x 前缀的十六进制给出符号大小。
</li>

<li><code>--demangle=style, --no-demangle</code>
    <br> 将低级符号名称解码（解码）为用户级名称。 这使得 C++ 函数名称可读。 不同的编译器有不同的修饰风格。 可选的 demangling 样式参数可用于为您的编译器选择合适的 demangling 样式。
    <br> 参见 <a href="https://sourceware.org/binutils/docs/binutils/c_002b_002bfilt.html">c++filt</a> ，了解更多关于 demangling 的信息。 
</li>

<li><code>--quiet</code>
    <br> 禁止 “no symbols” 诊断。
</li>

<li><code>--recurse-limit, --no-recurse-limit, --recursion-limit, --no-recursion-limit</code>
    <br> 启用或禁用在对字符串进行分解时执行的递归量的限制。 由于名称修饰格式允许无限级别的递归，因此可以创建字符串，其解码将耗尽主机上可用的堆栈空间量，从而触发内存故障。 该限制试图通过将递归限制为 2048 级嵌套来防止这种情况发生。
    <br> 默认情况下启用此限制，但可能需要禁用它才能解开真正复杂的名称。 但是请注意，如果禁用递归限制，则可能会耗尽堆栈，并且任何有关此类事件的错误报告都将被拒绝。
</li>

<li><code>-U [d|i|l|e|x|h]</code> 或者 <code>--unicode=[default|invalid|locale|escape|hex|highlight]</code>
    <br> 控制标识符名称中非 ASCII 字符的显示。 默认（--unicode=locale 或--unicode=default）是将它们视为多字节字符并在当前语言环境中显示它们。
    <br> 此选项的所有其他版本将字节视为 UTF-8 编码值并尝试解释它们。 如果它们无法被解释或者如果使用了 --unicode=invalid 选项，那么它们将显示为十六进制字节序列，并用花括号括起来。
    <br> 使用 --unicode=escape 选项会将字符显示为 unicode 转义序列 (\uxxxx)。 使用 --unicode=hex 会将字符显示为用尖括号括起来的十六进制字节序列。
    <br> 使用 --unicode=highlight 会将字符显示为 unicode 转义序列，但它也会以红色突出显示它们，假设输出设备支持着色。 着色旨在提醒人们注意可能不存在的 unicode 序列。
    <br> 
</li>

<li><code>-n, --notes</code>
    <br> 显示 NOTE 段和/或部分的内容（如果有）。
</li>

<li><code>-r, --relocs</code>
    <br> 显示文件的重定位部分的内容（如果有的话）。
</li>

<li><code>-u, --unwind</code>
    <br> 显示文件展开部分的内容（如果有）。
    <br> 当前仅支持 IA64 ELF 文件的展开部分以及 ARM 展开表 (.ARM.exidx / .ARM.extab)。 如果您的架构尚未实现支持，您可以尝试使用 --debug-dump=frames 或 --debug-dump=frames-interp 选项转储 .eh_frames 部分的内容。
</li>

<li><code>-d, --dynamic</code>
    <br> 显示文件的动态部分的内容（如果有的话）。
</li>

<li><code>-V, --version-info</code>
    <br> 显示文件中版本部分的内容，（如果它们存在的话）。
</li>

<li><code>-A, --arch-specific</code>
    <br> 显示文件中特定于体系结构的信息（如果有）。
</li>

<li><code>-D, --use-dynamic</code>
    <br> 显示符号时，此选项使 readelf 使用文件动态部分中的符号哈希表，而不是符号表部分。
    <br> 显示重定位时，此选项使 readelf 显示动态重定位而不是静态重定位。
</li>

<li><code>-L, --lint, --enable-checks</code>
    <br> 显示有关正在检查的文件可能存在问题的警告消息。 如果单独使用，则将检查文件的所有内容。 如果与转储选项之一一起使用，则只会为正在显示的内容生成警告消息。
</li>

<li><code>-x &lt;number or name&gt;, --hex-dump=&lt;number or name&gt;</code>
    <br> 将指定部分的内容显示为十六进制字节。编号通过节表中的索引标识特定节；任何其他字符串标识目标文件中具有该名称的所有部分。
</li>

<li><code>-p &lt;number or name&gt;, --string-dump=&lt;number or name&gt;</code>
    <br> 将指定部分的内容显示为可打印字符串。编号通过节表中的索引标识特定节；任何其他字符串标识目标文件中具有该名称的所有部分。
</li>

<li><code>-R &lt;number or name&gt;, --relocated-dump=&lt;number or name&gt;</code>
    <br> 将指定部分的内容显示为十六进制字节。 编号通过节表中的索引标识特定节； 任何其他字符串标识目标文件中具有该名称的所有部分。 该部分的内容将在显示之前重新定位。
</li>

<li><code>-z, --decompress</code>
    <br> 请求由 x、R 或 p 选项转储的部分在显示之前解压缩。如果部分未压缩，则它们按原样显示。
</li>

<li><code>-c, --archive-index</code>
    <br> 显示包含在二进制归档文件头部分的文件符号索引信息。执行与 ar 的 t 命令相同的功能，但不使用 BFD 库。见 <a href="https://sourceware.org/binutils/docs/binutils/ar.html">ar</a>。
</li>

<li><code>-w[lLiaprmfFsoORtUuTgAck] </code> 或者 <code>--debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=str-offsets,=loc,=Ranges,=pubtypes,=trace_info,=trace_abbrev,=trace_aranges,=gdb_index,=addr,=cu_index,=links]</code>
    <br> 显示文件中 DWARF 调试部分的内容（如果存在）。 压缩的调试部分在显示之前会自动（临时）解压缩。 如果开关后面有一个或多个可选字母或单词，则只会转储那些类型的数据。 字母和单词指的是以下信息：
    <ul>
    <li><code>a</code>, <code>=abbrev</code>
        <br> 显示 “.debug_abbrev” 部分的内容。
        </li>
    <li><code>A</code>, <code>=addr</code>
        <br> 显示 “.debug_addr” 部分的内容。
        </li>
    <li><code>c</code>, <code>=cu_index  </code>
        <br> 显示 “.debug_cu_index” 和/或 “.debug_tu_index” 部分的内容。
        </li>
    <li><code>f</code>, <code>=frames</code>
        <br> 显示 “.debug_frame” 部分的原始内容。
        </li>
    <li><code>F</code>, <code>=frames-interp</code>
        <br> 显示 “.debug_frame” 部分的解释内容。
        </li>
    <li><code>g</code>, <code>=gdb_index</code>
        <br> 显示 “.gdb_index” 和/或 “.debug_names” 部分的内容。
        </li>
    <li><code>i</code>, <code>=info</code>
        <br> 显示 “.debug_info” 部分的内容。 注意：此选项的输出也可以通过使用 --dwarf-depth 和 --dwarf-start 选项来限制。
        </li>
    <li><code>k</code>, <code>=links</code>
        <br> 显示 “.gnu_debuglink”、 “.gnu_debugaltlink” 和 “.debug_sup” 部分的内容（如果存在）。 如果它们由 “.debug_info” 部分中的 DW_AT_GNU_dwo_name 或 DW_AT_dwo_name 属性指定，还显示指向单独的 dwarf 对象文件 (dwo) 的任何链接。
        </li>
    <li><code>K</code>, <code>=follow-links</code>
        <br> 显示在链接的单独调试信息文件中找到的任何选定调试部分的内容。 如果同一调试部分存在于多个文件中，这可能会导致显示多个版本。
        <br> 另外，在显示 DWARF 属性时，如果发现表单引用了单独的调试信息文件，那么也会显示引用的内容。
        <br> 注意 - 在某些发行版中，此选项默认启用。 它可以通过 N 调试选项禁用。 通过 --enable-follow-debug-links=yes 或 --enable-follow-debug-links=no 选项配置 binutils 时可以选择默认值。 如果不使用这些，则默认启用以下调试链接。
        </li>
    <li><code>N</code>, <code>=no-follow-links</code>
        <br> 禁用以下链接到单独的调试信息文件。
        </li>
    <li><code>l</code>, <code>=rawline</code>
        <br> 以原始格式显示“.debug_line”部分的内容。
        </li>
    <li><code>L</code>, <code>=decodedline</code>
        <br> 显示 “.debug_line” 部分的解释内容。
        </li>
    <li><code>m</code>, <code>=macro</code>
        <br> 显示 “.debug_macro” 和/或 “.debug_macinfo” 部分的内容。
        </li>
    <li><code>o</code>, <code>=loc</code>
        <br> 显示 “.debug_loc” 和/或 “.debug_loclists” 部分的内容。
        </li>
    <li><code>O</code>, <code>=str-offsets</code>
        <br> 显示 “.debug_str_offsets” 部分的内容。
        </li>
    <li><code>p</code>, <code>=pubnames</code>
        <br> 显示 “.debug_pubnames” 和/或 “.debug_gnu_pubnames” 部分的内容。
        </li>
    <li><code>r</code>, <code>=aranges</code>
        <br> 显示 “.debug_aranges” 部分的内容。
        </li>
    <li><code>R</code>, <code>=Ranges</code>
        <br> 显示 “.debug_ranges” 和/或 “.debug_rnglists” 部分的内容。
        </li>
    <li><code>s</code>, <code>=str</code>
        <br> 显示 “.debug_str”、“.debug_line_str” 和/或 “.debug_str_offsets” 部分的内容。
        </li>
    <li><code>t</code>, <code>=pubtype</code>
        <br> 显示 “.debug_pubtypes” 和/或 “.debug_gnu_pubtypes” 部分的内容。
        </li>
    <li><code>T</code>, <code>=trace_aranges</code>
        <br> 显示 “.trace_aranges” 部分的内容。
        </li>
    <li><code>u</code>, <code>=trace_abbrev</code>
        <br> 显示 “.trace_abbrev” 部分的内容。
        </li>
    <li><code>U</code>, <code>=trace_info</code>
        <br> 显示 “.trace_info” 部N分的内容。
        </li>
    </ul>
    <br> 注意：目前并不是所有平台都支持上面的这些指令。
</li>


<li><code>-P, --process-links</code>
    <br> 显示在链接到主文件的单独 debuginfo 文件中找到非调试部分的内容。此选项自动带 -wK 选项，并且仅显示其他命令行选项请求的部分。
</li>

<li><code>--dwarf-depth=n</code>
    <br> 将 .debug_info 部分的转储限制为 n 个子项。 这仅对 --debug-dump=info 有用。 默认打印所有DIE； n 的特殊值 0 也会产生这种效果。
    <br> 如果 n 为非零值，则不会打印 n 级或更深的 DIE。 n 的范围是从零开始的。
</li>

<li><code>--dwarf-start=n</code>
    <br> 仅打印以编号为 n 的 DIE 开头的 DIE。 这仅对 --debug-dump=info 有用。
    <br> 如果指定，此选项将禁止打印任何标题信息和编号为 n 的 DIE 之前的所有 DIE。 只会打印指定 DIE 的兄弟姐妹和孩子。
    <br> 这可以与 --dwarf-depth 结合使用。
</li>

<li><code>--ctf=section</code>
    <br> 显示指定 CTF 节的内容。 CTF 部分本身包含许多子部分，所有子部分都按顺序显示。
    <br> 默认情况下，显示名为 .ctf 的部分的名称，即 ld 发出的名称。
</li>

<li><code>--ctf-parent=section</code>
    <br> 如果 CTF 部分包含模糊定义的类型，它将包含许多 CTF 字典的存档，所有字典都继承自一个包含明确类型的字典。
    <br> 该成员默认命名为 .ctf，就像包含它的部分一样，但可以在链接时使用 ctf_link_set_memb_name_changer 函数更改此名称。
    <br> 当查看由使用名称更改器重命名父存档成员的链接器创建的 CTF 存档时，--ctf-parent 可用于指定用于父存档的名称。
</li>

<li><code>--ctf-symbols=section</code> and <code>--ctf-strings=section</code>
    <br> 指定 CTF 文件可以从中继承字符串和符号的另一个节的名称。 默认情况下，使用 .symtab 及其链接字符串表。
    <br> 如果指定了 --ctf-symbols 或 --ctf-strings 中的任何一个，则还必须指定另一个。
</li>

<li><code>-I, --histogram</code>
    <br> 在显示符号表的内容时显示桶列表长度的直方图。
</li>

<li><code>-v, --version</code>
    <br> 显示 readelf 的版本号。
</li>

<li><code>-W, --wide</code>
    <br> 不要打破输出行以适应 80 列。 默认情况下，readelf 会中断 64 位 ELF 文件的节标题和段列表行，以便它们适合 80 列。 此选项使 readelf 分别打印每个节标题。 每个段都是单行，在超过 80 列的终端上可读性更高。
</li>

<li><code>-T, --silent-truncation</code>
    <br> 通常，当 readelf 显示符号名称时，它必须截断名称以适应 80 列显示，它会在名称中添加 [...] 的后缀。 此命令行选项禁用此行为，允许再显示 5 个名称的字符并恢复 readelf 的旧行为（发布 2.35 之前）。
</li>

<li><code>-H, --help</code>
    <br> help info
</li>
</ul>
</div>








<div class="breadboard">
<div class="head head_1">linux 内核</div>
<div class="head head_2">内核初始化模块</div>
<p>
    可参考 <code>init/main.c start_kernel(void)</code> 函数，参考 CSDN 上博主 <code>HZero.chen</code> 写的 <a href="https://blog.csdn.net/jasonactions/article/details/111715545">kernel启动流程-xxx</a> 系列。
    （本来想字节写的，但是别人已经写得非常详细，就不再重复了）
</p>

<div class="head head_2">platform_driver</div>
<p>
    platform 框架的初始化流程( 以 arm 平台为例子 )：
    <code>arch/arm/kernel/vmlinux.lds: ENTRY(stext)</code> ->
    <code>arch/arm/kernel/{head.S, head-common.S}： stext -> __mmap_switched</code>
    <code>init/main.c: asmlinkage __visible void __init start_kernel(void)</code> ->
    <code>init/main.c: static noinline void __ref rest_init(void)</code> -> 
    <code>init/main.c: static int __ref kernel_init(void *unused)</code> ->
    <code>init/main.c: static noinline void __init kernel_init_freeable(void)</code> ->
    <code>init/main.c: static void __init do_basic_setup(void)</code> -> 
    <code>drivers/base/init.c： void __init driver_init(void)</code> ->
    <code>drivers/base/platform.c：int __init platform_bus_init(void)</code>
</p><p>

</p>
<p>
    下面是编写 platform 驱动程序最关键的两个结构体：
</p>
<pre>
// include/linux/platform_device.h
struct platform_device {
    const char                          *name;
    int                                 id;
    bool                                id_auto;
    struct device                       dev;
    u32                                 num_resources;
    struct resource                     *resource;

    const struct platform_device_id     *id_entry;
    char                                *driver_override; /* Driver name to force a match */

    /* MFD cell pointer */
    struct mfd_cell                     *mfd_cell;

    /* arch specific additions */
    struct pdev_archdata                archdata;
};

</pre>

<pre>
// include/linux/mod_devicetable.h
struct platform_device_id{
    char                name[PLATFORM_NAME_SIZE];
    kernel_ulong_t      driver_data;
}

// include/linux/platform_device.h
struct platform_driver {
    int     (*probe)(struct platform_device *);
    int     (*remove)(struct platform_device *);
    void    (*shutdown)(struct platform_device *);
    int     (*suspend)(struct platform_device *, pm_message_t state);
    int     (*resume)(struct platform_device *);
    struct device_driver                driver;
    const struct platform_device_id     *id_table;
    bool                                prevent_deferred_probe;
};
</pre>
<p>
    内核根据 <code>platform_device.name</code> 和 <code>platform_driver.id_table.name</code> 来匹配设备和驱动。如果 id_table 不存在，则会匹配 <code>platform_driver.driver</code> 中的名字。
</p>

</div>    











<div class="breadboard">
<div class="head head_1">Device Tree Linux</div>
<p>
    了解 dt 最好的文档就是 Linux <a href="https://elinux.org/Device_Tree_Linux">官方的文档</a> 。
</p><p>
    为什么有 dt 嘞？我们都知道 Linux 为应用层提供了统一的访问硬件接口，而需要让应用层能够控制硬件，我们就需要通过驱动将（open read write close ioctl ...）接口的请求转换成对应的硬件操作逻辑，然后和硬件沟通。
</p><p>
    早期，Linux 的驱动分为两个部分，一部分是业务（Driver），另外一部分是配置（硬件资源，Device）。这也很好理解，因为，一般同一个硬件的业务逻辑都是高度相似的。
    比如： GPIO 口控制的指示灯，高电平点亮，低电平熄灭，或者高电平熄灭，低电平点亮。这里我们就可以分成两个部分。一个部分是控制 GPIO 口反转的部分，这部分就是控制灯光的业务逻辑部分。另外一部分就是定义 GPIO 的引脚状态，和与灯亮灭相关对应的电平。
    这是一个简单的例子，但是对应到复杂一点的情况实际上也是这样的，比如统一平台的 USB 协议都是一样的，只是不同硬件其对应的 DMA 或者外部定义的 GPIO 配置不一样。
</p><p>
    而早先的 Linux 也是将业务和配置部分分开编写的。但是当我们的硬件发生变化的时候还是需要重新编译整个内核或者驱动。
</p><p>
    如果我们需要将重新编译的这个步骤优化掉，那么我们应该如何做嘞？
    以前的办法是把配置编译成具体的静态数据，整合到整个驱动或者镜像中？
    我们是否可以借鉴一下数据库的概念？我们创造一个数据库的编译器和解析器，然后将我们的硬件配置序列化编译成数据库文件，在开机的时候将之加载到内存中，然后驱动程序直接调用解析器提取当前硬件的配置。
    这就是 dt 的核心逻辑。
</p><p>
    了解 dt 还需要了解几种文件类型：dts, dtsi, dtb， dtc。
    其中 dtsi 一般当作 dts 的引用文件，dts 则为生成 dtb 的主文件。
    而 dtb 一般就是烧录到某个分区中的二进制编码文件了。  
    而 dtc 就是将 dts 编译成 dtb 的编译工具了。
</p><p>
    另外应该 DT 节点中字段的定义几乎完全取决于驱动程序（除了 <code>compatible</code> ），因此写驱动程序时，驱动程序的作者还应该提供一份 DT 的编写规则描述文档。
    官方 Linux 的驱动的 DT 描述再 <code>Documentation/devicetree/bindings/</code> 目录下。
</p>

<div class="head head_2">DTS 的编译和反编译</div>
<p>
    从上文可知，编译 dtb 的工具为 dtc， dtc 的源代码位于 <code>./scripts/dtc</code> 中，dtc 工具回在编译内核的前期编译出来，编译后生成的 dtc 同样位于 <code>scripts/dtc/</code> 目录。
</p><p>
    使用 dtc 的时候需要指定输入格式以及输出格式，比如你可以用下面的方法编译一个 dts 文件： <code>dtc  -I dts -O dtb -o /tmp/xxx.dtb kernel-5.10/arch/arm64/boot/dts/xxx/xxx.dts</code>， 
    其中 <code>-I</code> 指定输入格式， <code>-O</code> 指定输出格式， 而 <code>-o</code> 指定输出文件。
</p><p>
    当然，你也可以通过上面的方法将一个 dtb 文件反编译成一个 dts 文件： <code>dtc -I dtb -O dts -o /tmp/xxx.dts /tmp/xxx.dtb</code>。
    因为很多时候一个 dts 文件会包含很多的 dtsi 文件，而且配置之间还可以覆盖，因此当你想要确定 dts 中某一个配置是否正确的时候，可以反编译出来查看。
</p>

<div class="head head_2">DTB 如何加载？</div>
<p>
    dt 被加载之后，在系统的 <code>/sys/firmware/devicetree</code> 目录下有所有 dtb 中的配置。
</p>

<div class="head head_2">dts 中的设备如何匹配到设备驱动程序</div>
<p>
    dts 中描述的每个节点都必须包含 <code>compatible</code> 属性，该属性适用于匹配匹配驱动的。比如：
</p>
<pre>    
&i2c1 {
    status = "okay";
    clock-frequency = &lt;400000&gt;;
    dw9714: dw9714@0c {
            <code>compatible</code> = <code>"dongwoon,dw9714"</code>;
            reg = &lt;0x0c&gt;;
            rockchip,vcm-start-current = &lt;29&gt;;
            rockchip,vcm-rated-current = &lt;65&gt;;
            rockchip,vcm-step-mode = &lt;4&gt;;
            rockchip,camera-module-index = &lt;1&gt;;
            rockchip,camera-module-facing = "front";
            xsd-gpios=&lt;&gpio2 RK_PD3 GPIO_ACTIVE_HIGH&gt;;
    };
</pre>
<p>
    而与之对应的驱动中则会存在与之对应的 <code>of_match_table</code>， 如下所示：
</p>
<pre>
// ./drivers/media/i2c/dw9714.c
static const struct of_device_id dw9714_of_table[] = {
    { .compatible = <code>"dongwoon,dw9714"</code> },
    { { 0 } }
};

static struct i2c_driver dw9714_i2c_driver = {
    .driver = {
            .name = DW9714_NAME,
            .pm = &dw9714_pm_ops,
            .<code>of_match_table</code> = dw9714_of_table,
    },
    .probe = &dw9714_probe,
    .remove = &dw9714_remove,
    .id_table = dw9714_id_table,
};

module_i2c_driver(dw9714_i2c_driver);
</pre>
<p>
    这里首先会牵扯到驱动加载的过程，首先，分析大部分的 <code>xxx_register</code> 函数，都会发现最总这些驱动都调用了 <code>drivers/base/driver.c： int driver_register(struct device_driver *drv)</code> 来注册驱动。
    而设备和驱动的绑定也就是在这个阶段进行的。其流程如下所示：
</p>

<pre>
// 注册驱动
// drivers/base/driver.c
int driver_register(struct device_driver *drv){
    ...
    ret = <code>bus_add_driver</code>(drv);
    ...
}

// drivers/base/bus.c
int bus_add_driver(struct device_driver *drv){
    ...
    if (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) {
        error = <code>driver_attach</code>(drv);
        ...
    }
    ...
}

// 便利设备列表中的每一个设备，并调用 __driver_attach 试图进行绑定
// drivers/base/dd.c
int driver_attach(struct device_driver *drv){
    return bus_for_each_dev(drv-&gt;bus, NULL, drv, <code>__driver_attach</code>);
}

// drivers/base/bus.c
int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data, int (*fn)(struct device *, void *));

// drivers/base/dd.c
static int __driver_attach(struct device *dev, void *data){
    ...
    ret = <code>driver_match_device</code>(drv, dev);
    // 处理 ret 错误信息
    ...
    // 如果没错，将会执行到该步骤
    // 该函数会将 driver 和 device 进行关联
    device_driver_attach(drv, dev);
    ...
}

// 调用总线的 match 方法，查找设备并进行绑定
// drivers/base/base.h
static inline int driver_match_device(struct device_driver *drv, struct device *dev){
    return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;
}
</pre>
<p>
    以 platform 驱动为例：动匹配设备的过程发生在 <code>drivers/base/platform.c： static int platform_match(struct device *dev, struct device_driver *drv)</code> 函数中。
    如下所示：
</p>
<pre>
// drivers/base/platform.c
static int platform_match(struct device *dev, struct device_driver *drv){
    ...
    if (<code>of_driver_match_device</code>(dev, drv))
        return 1;
    ...
}

// include/linux/of_device.h
static inline int of_driver_match_device(struct device *dev, const struct device_driver *drv){
    return <code>of_match_device</code>(drv-&gt;of_match_table, dev) != NULL;
}

// drivers/of/device.c
const struct of_device_id *of_match_device(const struct of_device_id *matches, const struct device *dev){
    if ((!matches) || (!dev-&gt;of_node))
        return NULL;
    return <code>of_match_node</code>(matches, dev-&gt;of_node);
}

// drivers/of/base.c
const struct of_device_id *of_match_node(const struct of_device_id *matches, const struct device_node *node){
    ...
    raw_spin_lock_irqsave(&devtree_lock, flags);
    match = <code>__of_match_node</code>(matches, node);
    raw_spin_unlock_irqrestore(&devtree_lock, flags);
    ...
}

// drivers/of/base.c
static const struct of_device_id *__of_match_node(const struct of_device_id *matches, const struct device_node *node){
    const struct of_device_id *best_match = NULL;
    int score, best_score = 0;

    if (!matches)
        return NULL;

    for (; matches-&gt;name[0] || matches-&gt;type[0] || matches-&gt;compatible[0]; matches++) {
        score = <code>__of_device_is_compatible</code>(node, matches-&gt;compatible, matches-&gt;type, matches-&gt;name);
        if (score > best_score) {
            best_match = matches;
            best_score = score;
        }
    }
    return best_match;
}

// drivers/of/base.c
/**
 * __of_device_is_compatible() - Check if the node matches given constraints
 * @device: pointer to node
 * @compat: required compatible string, NULL or "" for any match
 * @type: required device_type value, NULL or "" for any match
 * @name: required node name, NULL or "" for any match
 *
 * Checks if the given @compat, @type and @name strings match the
 * properties of the given @device. A constraints can be skipped by
 * passing NULL or an empty string as the constraint.
 *
 * Returns 0 for no match, and a positive integer on match. The return
 * value is a relative score with larger values indicating better
 * matches. The score is weighted for the most specific compatible value
 * to get the highest score. Matching type is next, followed by matching
 * name. Practically speaking, this results in the following priority
 * order for matches:
 *
 * 1. specific compatible && type && name
 * 2. specific compatible && type
 * 3. specific compatible && name
 * 4. specific compatible
 * 5. general compatible && type && name
 * 6. general compatible && type
 * 7. general compatible && name
 * 8. general compatible
 * 9. type && name
 * 10. type
 * 11. name
 */
static int <code>__of_device_is_compatible</code>(const struct device_node *device,
                                     const char *compat, const char *type, const char *name)
{
    struct property     *prop;
    const char          *cp;
    int                 index = 0;
    int                 score = 0;

    /* Compatible match has highest priority */
    if (compat && compat[0]) {
        prop = __of_find_property(device, "compatible", NULL);
        for (cp = of_prop_next_string(prop, NULL); cp;
            cp = of_prop_next_string(prop, cp), index++) {
            if (of_compat_cmp(cp, compat, strlen(compat)) == 0) {
                score = INT_MAX/2 - (index << 2);
                break;
            }
        }
        if (!score)
            return 0;
    }

    /* Matching type is better than matching name */
    if (type && type[0]) {
        if (!device-&gt;type || of_node_cmp(type, device-&gt;type))
            return 0;
        score += 2;
    }

    /* Matching name is a bit better than not */
    if (name && name[0]) {
        if (!device-&gt;name || of_node_cmp(name, device-&gt;name))
            return 0;
        score++;
    }

    return score;
}
</pre>
<p>

</p>

<div class="head head_2">DTS 存在 Linux 镜像的哪个位置</div>
<div class="head head_2">DTS 与 bootloader 的关系</div>
<div class="head head_2">DTS Linux 如何使用 DTS 中的配置</div>
<div class="head head_2">DTS 如何加载一个 DTS</div>

</div>











<div class="breadboard">
<div class="head head_1">网络相关</div>

<div class="head head_2">硬件</div>
<div class="head head_3">POE 供电方式</div>
<p>
    10MBASE-T 和 100MBASE-T 只用到了两队双绞线，而五类（+）双绞线有四对，因此我们可以使用另外两对来进行供电，或者通过数据线来供电。
    而 1000MBASE-T 的方案也简单，其中 modeA 是利用 1，2，3，6 传输，modeB 是利用 4，5，7，8 进行电力传输。不过需要特别注意供电端的纹波和恢复时间，取电端的滤波和功耗控制等问题。
    如下所示：
</p><p>
    PS： 使用数据线的方案，因为传输的是直流和数字信号，数字信号可以通过耦合电感取出，只原直流信号的纹波幅度不影响复合的数字信号，则不会对数据传输造成影响。
</p>
<div class="img_center">
    <img src="https://images.cnblogs.com/cnblogs_com/mojies/2171355/o_220905060131_ETH_POE.png" alt="">
</div>

<div class="head head_2">知识点</div>
<p>
    Netfilter
    IPSec
    ttl
    SCTP
    DCCP
    LTE
</p>
<ul>
<li><strong>ETH Protocol ID 在内核中的定义</strong>
    <br> 位置 <code>include/uapi/linux/if_ether.h</code>
    <br> 常用的一些定义有：
    <pre>
#define ETH_P_LOOP      0x0060          /* Ethernet Loopback packet     */
#define ETH_P_IP        0x0800          /* Internet Protocol packet     */
#define ETH_P_ARP       0x0806          /* Address Resolution packet    */
#define ETH_P_RARP      0x8035          /* Reverse Addr Res packet      */
#define ETH_P_8021Q     0x8100          /* 802.1Q VLAN Extended Header  */
#define ETH_P_IPX       0x8137          /* IPX over DIX                 */
#define ETH_P_IPV6      0x86DD          /* IPv6 over bluebook           */
    </pre>
</li>
<li><strong>WakeOnLine</strong>
    <br> WOL / LAN 是以太网的一个通过网络消息唤醒设备的机制
    <br> 消息通常由同一局域网的网络设备发起。当然也可以使用子网的定向广播或者 WoL 网关发起。
    <br> WoL 物理层通过识别 magic package 来判断是否有其他设备再唤醒本设备。包结构通常为 ( 6 * 0xFF + 16 * 唤醒机器的 MAC 地址 ) 总共 102 个字节。数据包通常以广播的方式发送出来。
    <br> WoL Magic 包发送有以下限制：
    <ul>
    <li>需要目标计算机的 MAC 地址（也可能需要 secure ON 的密码）</li>
    <li>不提供唤醒确认（被唤醒机器不提供应答）</li>
    <li>可能无法再本地网络之外工作</li>
    <li>需要目标计算机上的 LAN 硬件支持</li>
    <li>大多数 802.11 无线接口在低功耗状态下不维持链路并且无法接收魔术包</li>
    </ul>
    <br> 有时也可以通过 SDB （子网定向广播）将广播信号传播到子网的设备中。但也需要网关支持才行（可能会被过滤掉）。

    <br> Wake-on-LAN (WoL or WOL) is an Ethernet or Token Ring computer networking standard that allows a computer to be turned on or awakened by a network message.
    <br> The message is usually sent to the target computer by a program executed on a device connected to the same local area network.
        It is also possible to initiate the message from another network by using subnet directed broadcasts or a WoL gateway service.
    <br> Equivalent terms include wake on WAN, remote wake-up, power on by LAN, power up by LAN, resume by LAN, resume on LAN and wake up on LAN.
         If the computer being awakened is communicating via Wi-Fi, a supplementary standard called Wake on Wireless LAN (WoWLAN) must be employed.
    <br> The WoL and WoWLAN standards are often supplemented by vendors to provide protocol-transparent on-demand services, for example in the Apple Bonjour wake-on-demand (Sleep Proxy) feature.
    <br> <strong>Magic packet</strong> The magic packet is a frame that is most often sent as a broadcast and that contains anywhere within its payload 6 bytes of all 255 (FF FF FF FF FF FF in hexadecimal), 
        followed by sixteen repetitions of the target computer's 48-bit MAC address, for a total of 102 bytes.

</li>
</ul>


<div class="head head_2">proc 下和网络相关的一些配置</div>
<ul>
<li><strong>/proc/sys/net/ipv4/ip_forward</strong>
    <br> 设置 1 使能 ip_forward
    <br> Forward Packets between interfaces
    <br> 将此属性配置为 1 将导致所有的 <code>net.ipv4.conf.INTERFACE.forwarding</code> 都变成 1
</li>
<li><strong>net.ipv4.conf.INTERFACE.accept_local</strong>
    <br>
</li>
</ul>
https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt
https://sysctl-explorer.net/net/ipv4/
https://blog.csdn.net/wesleyflagon/article/details/80272696



<div class="head head_3">Termis</div>
<ul>
<li><strong>MTU</strong>
    <br> 一个网络包的最大长度，以太网中一般为 1500 字节；
</li>
<li><strong>MSS</strong>
    <br> 去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；
    <br> IPV4 中 MSS 的大小为 MTU 的大小减去 40 bytes
</li>
</ul>





<div class="head head_2">iptables</div>
<div class="head head_3">iptables 如何实现的</div>

<div class="head head_3">iptables 的四个表</div>
<ul>
<li><strong>filter</strong>
    <br> This is the default table (if no -t option is passed). It contains the built-in chains INPUT (for packets destined to local sockets), FORWARD (for packets being routed through the box), and OUTPUT (for locally-generated packets).
    <br> 负责过滤数据包，确定是否放行该数据包（过滤）。包含三个规则链 INPUT、FORWARD、OUTPUT。
</li>
<li><strong>nat</strong>
    <br> This table is consulted when a packet that creates a new connection is encountered.  It consists of four built-ins: PREROUTING (for altering packets as soon as they come in), INPUT (for altering packets destined for local sockets), OUTPUT  (for altering locally-generated packets before routing), and POSTROUTING (for altering packets as they are about to go out).  IPv6 NAT support is available since kernel 3.7.
    <br> 
</li>
<li><strong>mangle</strong>
    <br> This  table  is used for specialized packet alteration.  Until kernel 2.4.17 it had two built-in chains: PREROUTING (for altering incoming packets before routing) and OUTPUT (for altering locally-generated packets before routing).  Since kernel 2.4.18, three other built-in chains are also supported: INPUT (for packets coming into the box itself), FORWARD (for altering packets being routed through the box), and POSTROUTING (for altering packets as they are about to go out).
    <br> 
</li>
<li><strong>raw</strong>
    <br> This table is used mainly for configuring exemptions from connection tracking in combination with the NOTRACK target.  It registers at the netfilter hooks with higher priority and is thus called before ip_conntrack, or any other IP tables.   It provides the following built-in chains: PREROUTING (for packets arriving via any network interface) OUTPUT (for packets generated by local processes)
    <br> 
</li>

<li><strong>security</strong>
    <br> This  table  is  used  for Mandatory Access Control (MAC) networking rules, such as those enabled by the SECMARK and CONNSECMARK targets.  Mandatory Access Control is implemented by Linux Security Modules such as SELinux.  The security table is called after the filter table, allowing any Discretionary Access Control (DAC) rules in the filter table to take effect before MAC rules.  This table provides the following built-in chains: INPUT (for packets coming into the box itself), OUTPUT (for altering locally-generated packets before routing), and FORWARD (for altering packets being routed through the box).
    <br> 
</li>
</ul>

<div class="head head_3">iptables 的五个内建 chain</div>
<p>
    五个内建的 chain 为： PREROUTING / POSTROUTING / FORWARD / INPUT / OUTPUT, 他们的关系如下图所示：
</p>
<img src="https://images.cnblogs.com/cnblogs_com/mojies/2171355/o_220606041259_iptables_chain_ralationship.png" alt="" class="img_center" width="600px">

<div class="head head_3">iptables 基本操作命令</div>
<ul>
<li><strong>查看当前防火墙规则</strong>
    <br> <code>iptables -nvL</code> or <code>iptables -L</code>
</li>
<li><strong>添加 Chain</strong>
    <br> <code>iptables -N CHAIN_NAME</code>
</li>
<li><strong>删除 chain</strong>
    <br> <code>iptables -X CHAIN_NAME</code>
</li>
<li><strong>重命名 chain</strong>
    <br> <code>iptables -E OLD_CHAIN_NAME NEW_CHAIN_NAME</code>
</li>
<li><strong>对 chain 规则做出修改（增删改查）</strong>
    <br> <code>iptables [-t table] {-A|-C|-D} OLD_CHAIN_NAME rule-specification</code>, <code>-A</code> 增加一条规则m, <code>-C</code> 检查规则是否存在, <code>-D</code> 删除某条规则
    <br> <code>ip6tables [-t table] {-A|-C|-D} OLD_CHAIN_NAME rule-specification</code>, 与上一致
    <br> <code>iptables [-t table] -I OLD_CHAIN_NAME [rulenum] rule-specification</code>, 插入一条规则
    <br> <code>iptables [-t table] -R OLD_CHAIN_NAME rulenum rule-specification</code>, 替换一条规则
    <br> <code>iptables [-t table] -D OLD_CHAIN_NAME rulenum</code>, 删除一条规则
    <br> <code>iptables [-t table] -S [OLD_CHAIN_NAME [rulenum]]</code>, 打印 chain 中的规则
    <br> <code>iptables [-t table] {-F|-L|-Z} [OLD_CHAIN_NAME [rulenum]] [options...]</code>, <code>-F</code> 清除 chain 中所有 rule, <code>-L</code> 列出 chain 中所有 rule, <code>-Z</code> 清除 chain 的包计数
    <br> <code>iptables [-t table] -P OLD_CHAIN_NAME target</code> 给 chain 指定默认行为
</li>
<li><strong>将 chain 应用于 chain</strong>
    <br> <code>iptables -A INPUT -p tcp -dport 80 -j CHAIN_NAME</code>
</li>
</ul>

<div class="head head_3">iptables 基本操作参数</div>
<ul>
<li><strong>--ipv4</strong> / <code>-4</code>

</li>
<li><strong>--ipv6</strong> / <code>-6</code>

</li>
<li><strong>-p</strong> / <code>--protocol</code>
    <br> 
    <br> The  protocol of the rule or of the packet to check.  The specified protocol can be one of tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh or the special keyword "all", or it can be a numeric value, representing one of these protocols or a differ‐
    ent one.  A protocol name from /etc/protocols is also allowed.  A "!" argument before the protocol inverts the test.  The number zero is equivalent to all. "all" will match with all protocols and is taken as default  when  this  option  is  omitted.
    Note  that,  in  ip6tables,  IPv6  extension headers except esp are not allowed.  esp and ipv6-nonext can be used with Kernel version 2.6.11 or later.  The number zero is equivalent to all, which means that you cannot test the protocol field for the
    value 0 directly. To match on a HBH header, even if it were the last, you cannot use -p 0, but always need -m hbh.
</li>
<li><strong>-s</strong> / <code>--source</code>
    <br> Source specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel.  Please note that specifying any name
    to  be  resolved with a remote query such as DNS is a really bad idea.  The mask can be either an ipv4 network mask (for iptables) or a plain number, specifying the number of 1's at the left side of the network mask.  Thus, an iptables mask of 24 is
    equivalent to 255.255.255.0.  A "!" argument before the address specification inverts the sense of the address. The flag --src is an alias for this option.  Multiple addresses can be specified, but this will expand to  multiple  rules  (when  adding
    with -A), or will cause multiple rules to be deleted (with -D).
</li>
<li><strong>-d</strong> / <code>--destination</code>
    <br> Destination specification.  See the description of the -s (source) flag for a detailed description of the syntax.  The flag --dst is an alias for this option.
</li>
<li><strong>-m</strong> / <code>--match</code>
    
</li>
<li><strong>-j</strong> / <code>--jump</code>

</li>
<li><strong>-g</strong> / <code>--goto</code>

</li>
<li><strong>-i</strong> / <code>--in-interface</code>
    <br> 接收数据包的 interface 名称（仅适用于进入 INPUT、FORWARD 和 PREROUTING 链的数据包）。
        当接口名前存在字符 “!” 的时候，将匹配除此接口的的所有数据。 如果接口名称以 “+” 结尾，那么任何以此名称开头的接口都将匹配。 如果省略此选项，则任何接口名称都将匹配。
</li>
<li><strong>-o</strong> / <code>--out-interface</code>
    <br> 发送数据包的 interface 名称（仅适用于进入 FORWARD, OUTPUT 和 POSTROUTING 链的数据包）。
        当接口名前存在字符 “!” 的时候，将匹配除此接口的的所有数据。 如果接口名称以 “+” 结尾，那么任何以此名称开头的接口都将匹配。 如果省略此选项，则任何接口名称都将匹配。
</li>
<li><strong>-f</strong> / <code>--fragment</code>
    <br> 
</li>
<li><strong>-c</strong> / <code>--set-counters</code>
    <br> 
</li>
</ul>

<div class="head head_3">参考资料</div>
<ul>
<li><a href="https://blog.csdn.net/weixin_51468875/article/details/114023012">Iptables防火墙策略详解</a></li>
<li>LINUX: man iptables</li>
<li><a href="https://wangchujiang.com/linux-command/c/iptables.html">iptables</a></li>
<li><a href=""></a></li>
</ul>


</div>
    









<div class="breadboard">
<div class="head head_1">测试</div>
<div class="head head_2">为什么要测试？</div>
<p>
    借之前听到的某个人说的一句话：“这是保证——你写的代码是你想要的结果——的最有效办法！”，谁说的，我不记得了，但是这是我非常赞成的一个理由。
</p>

</div>








<div class="breadboard">
<div class="head head_1">图像</div>
<ul>
<li><strong>RGB 和 Ycrcb 转换</strong>
    <br> 转换公式一定要依据ITU的标准, 常看到的是 <code>ITU.BT-601</code> 和 <code>ITU.BT-709</code> 。
    <br> <a href="https://www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.601-7-201103-I!!PDF-E.pdf">ITU.BT-601</a>
    <br> <a href="https://www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.709-6-201506-I!!PDF-E.pdf">ITU.BT-709</a>

</li>
</ul>

</div>









<div class="breadboard">
<div class="head head_1">硬件</div>
<ul>
<li><strong>半导体集成电路第三代双倍数据速率同步动态随机存储器（DDR3 SDRAM）测试方法</strong>
    <br> <a href="https://www.cesa.cn/UpFileManage/bpgsManage/2017-10-24%20180021.pdf">链接地址</a>
    <br> 里面介绍了 TIS / TIH / TDS / TDH 这些参数的意义
</li>
<li><strong>Digi-Key</strong>
    <br> <a href="https://www.digikey.hk/en/products">Digi-Key 一个搜索硬件 IC 和模块的网站</a>

</li>
<li><strong>检测电路</strong>
    <br> 上下拉，开漏，推挽
    <br> JTAG
    <br> MIPI
    <br> I2S 主从
    <br> 外置晶振
    <br> 

</li>
</ul>

</div>





<div class="breadboard">
<div class="head head_1">常用系统调用</div>
<p>
    Linux 的系统调用可通过 <code>man syscalls</code> 查看。
    如果大家想详细的了解系统调用的具体细节，建议还是查看 man 手册，这里仅仅是我自己为了系统的完善我对于 linux 架构的理解，而做的一些笔记，
    一下将主要从两个方面介绍，一个方面是系统调用的运行逻辑，即系统调用的上下文是怎样的？
    另一方面是将常见的，以及我自己不怎么常用的系统调用做一番详细的解释。
</p>

<div class="head head_2">当你进行 Linux syscalls 中函数的调用时，发生了什么事情？</div>
<div class="head head_2">常用系统调用</div>
</div>    




<div class="breadboard">
<div class="head head_1">性能分析工具</div>
<div class="head head_2">vmstat</div>
<div class="head head_2">mpstat</div>
<div class="head head_2">iostat</div>
<div class="head head_2">netstat</div>
<div class="head head_2">sar</div>
<div class="head head_2">top</div>
<div class="head head_2">atop</div>
<div class="head head_2">pmap</div>
<div class="head head_2">tcpdump</div>
<div class="head head_2">blktrace</div>
<div class="head head_2">perf</div>
<div class="head head_2">pstack</div>
<div class="head head_2">pstrace</div>
<div class="head head_2">strace</div>
<div class="head head_2">Oprofile</div>
</div>


<div class="breadboard">
<div class="head head_1">工具</div>
<ul>
<li><strong>免费的 HexEdit</strong>
    <br> <a href="https://mh-nexus.de/en/hxd/">HexD</a>

</li>
<li><strong>glmark2</strong>
    <br> 图像测试工具
</li>
<li><strong>Android 端性能测试工具</strong>
    <br> <strong>AID64</strong>
    <br> <strong>Geekbench</strong>
    <br> <strong>OpenCL</strong>
    <br> <strong>Vulkan</strong>
    <br> <strong>CPDT Benchmark</strong>
    <br> <strong>Wild life Extreme Unlimited</strong>
    <br> <strong>PerfDog</strong>
    <br> <strong>inotifywatch</strong>： 监控某个目录的文件是否被访问了 <code>inotifywatch -a open /DIR_NAME</code>, 源码地址 <a href="https://github.com/inotify-tools/inotify-tools">inotify-tools</a>

</li>
</ul>

</div>    







<div class="breadboard">
<div class="head head_1">其他</div>
<ul>
<li><strong>介绍 ASOC 架构的文章</strong>
    <br> <a href="https://blog.csdn.net/yangjizhen1533?type=blog">Linux 音频驱动(一 -&gt; 六)</a>

</li>
<li><strong>Ross Anderson 大牛的主页</strong>
    <br> <a href="https://www.cl.cam.ac.uk/~rja14/">https://www.cl.cam.ac.uk/~rja14/</a>

</li>
<li><strong>HTML 数学公式代码生成器</strong>
    <br> <a href="https://webdemo.myscript.com/views/math/index.html#">https://webdemo.myscript.com/views/math/index.html#</a>
    <br> <a href="https://www.mathmlcentral.com/Tools/ToMathML.jsp">https://www.mathmlcentral.com/Tools/ToMathML.jsp</a>
</li>
<li><strong>Latex</strong>
    <br> <a href="https://xjay.net/201902/latex-syntax-for-math-equation/">LaTeX 数学公式语法</a>

</li>
<li><strong>搜书网站</strong>
    <br> <a href="http://library.lol/">http://library.lol/</a>
    <br> <a href="http://libgen.rs/">http://libgen.rs/</a>
    <br> <a href="https://zh.3lib.net/">zlibrary</a>

</li>
<li><strong>jeanboydev 总结的一份 Android 系统开发分析</strong>
    <br> <a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode">https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode</a>

</li>
<li><code>katex 运用</code>
    <br>
    <span class="latex_str" >
        \overline{PSNR}=
            \sum^K_{k=1}min\left[
                 20\log 10\left(
                    \dfrac{255}{ \sqrt{
                        \dfrac{1}{M*N}
                        \sum^{M-1}_{i=0}
                        \sum^{N-1}_{j=0}
                        [Y_{origin}(i,j) - Y_{code}(i,j)]^{2} } }
                \right); 50
            \right]
    </span>
    

</li>
<li><strong>平替 Window jounal 的笔记工具</strong>
    <br> <a href="https://github.com/xournalpp/xournalpp/releases/tag/v1.1.1">https://github.com/xournalpp/xournalpp/releases/tag/v1.1.1</a>

</li>
<li><strong>buildroot CMake 添加头依赖</strong>
    <br> buildroot 中的安装包都会安装到 <code>buildroot/output/PLAT/host/TOOLCHAIN_NAME/sysroot/usr/include</code>, 如果实在找不到可以在 PLT 目录查找以下你想要的头文件，
        该目录也可以通过 <code>${CMAKE_SYSROOT}/usr/include</code> 定位到。
    <br> 因此在你的工程中你可以使用 <code>include_directories("${CMAKE_SYSROOT}/usr/include")</code> 引用该目录下的所有安装头文件。
</li>
<li><strong>Git 命令</strong>
    <br> git 命令行，查找某个人在某个目录提交的所有关联文件（如今还存在的）的命令
    <br> <code>git whatchanged  --author=${USERNAME} ${SEARCH_DIR} | grep "^:[0-9]" | awk '{print $6}' | sort| uniq | xargs -I {} sh -c "test -f {} && ls -lh {} " | awk '{print $5, "\t",$9}'</code>

</li>
<li><strong>C++ 静态检查：<code>clang</code></strong>
    <br> <a href="https://clang.llvm.org/get_started.html">clang 官网</a>
    <br> 为当前目录下的 CPP 文件执行 clang 语法检查 <code>find -name "*cpp" | xargs -I {} clang -fsyntax-only {}</code>
</li>
<li><strong>C++ 静态检查：<code>cppcheck</code></strong>
    <br> <a href="https://cppcheck.sourceforge.io/#premium">cppcheck 官网</a>
</li>
<li><strong>C++ 静态检查： <code>TscanCode</code></strong>
    <br> <a href="https://github.com/Tencent/TscanCode">Tscancode 仓库地址</a>

</li>
<li><strong>更多 CPP 检查工具网站</strong>
    <br> <a href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#Clang">Wikipedia -- List of tools for static code analysis</a>

</li>
<li><strong>下载 github 某一个仓库某一个目录的文件</strong>
    <br> <a href="https://minhaskamal.github.io/DownGit/#/home">https://minhaskamal.github.io/DownGit/#/home</a>
</li>
<li><strong>搜索 github 某一个仓库中的内容</strong>
    <br> <a href="https://sourcegraph.com/search">https://sourcegraph.com/search</a>
    <br> 比如： https://sourcegraph.com/search?q=context:global+repo:%5Egithub%5C.com/danmar/cppcheck%24+txt&patternType=standard
</li>

</ul>
<li><strong>u-boot 启动流程</strong>
    <br> u-boot 的关联文件 <code>u-boot.lds</code> 可看出，启动函数即是 <code>_start</code> 函数，而该函数在 <code>start.s</code> 中，但你的工程里面大部分可能情况存在大量的 <code>start.S</code>,
    这时候你最重要的工作就是找到 start.s， 最简单的办法就是编译一次，看那个 <code>start.o</code> 被编译出来了
    <br> 随后你可能发现你的 <code>start.S</code> 里面非常多的宏，也不知道到底运行到哪里了，这时候最好的办法还是编译一次，然后使用 <code>objdump -S/-d start.o</code> 将之反编译，然后查看汇编文档，像我拿出来的汇编文档如下所示：
    <pre>
~/rk3588/u-boot develop
❯ ../prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-objdump -d arch/arm/cpu/armv8/start.o | sed 's/&lt;/\&amp;lt;/g' | sed 's/&gt;/\&amp;gt;/g'

arch/arm/cpu/armv8/start.o:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:   1400000a        b       28 &lt;reset&gt;
   4:   d503201f        nop

0000000000000008 &lt;_TEXT_BASE&gt;:
   8:   00200000        .word   0x00200000
   c:   00000000        .word   0x00000000

0000000000000010 &lt;_end_ofs&gt;:
        ...

0000000000000018 &lt;_bss_start_ofs&gt;:
        ...

0000000000000020 &lt;_bss_end_ofs&gt;:
        ...

0000000000000028 &lt;reset&gt;:
  28:   14000000        b       118 &lt;save_boot_params&gt;

000000000000002c &lt;save_boot_params_ret&gt;:
  2c:   10000000        adr     x0, 0 &lt;vectors&gt;
  30:   d5384241        mrs     x1, currentel
  34:   f100303f        cmp     x1, #0xc
  38:   540000a0        b.eq    4c &lt;save_boot_params_ret+0x20&gt;
  3c:   f100203f        cmp     x1, #0x8
  40:   54000160        b.eq    6c &lt;save_boot_params_ret+0x40&gt;
  44:   f100103f        cmp     x1, #0x4
  48:   540001a0        b.eq    7c &lt;save_boot_params_ret+0x50&gt;
  4c:   d51ec000        msr     vbar_el3, x0
  50:   d53e1100        mrs     x0, scr_el3
  54:   b2400c00        orr     x0, x0, #0xf
  58:   d51e1100        msr     scr_el3, x0
  5c:   d51e115f        msr     cptr_el3, xzr
  60:   58000600        ldr     x0, 120 &lt;save_boot_params+0x8&gt;
  64:   d51be000        msr     cntfrq_el0, x0
  68:   14000008        b       88 &lt;save_boot_params_ret+0x5c&gt;
  6c:   d51cc000        msr     vbar_el2, x0
  70:   d2867fe0        mov     x0, #0x33ff                     // #13311
  74:   d51c1140        msr     cptr_el2, x0
  78:   14000004        b       88 &lt;save_boot_params_ret+0x5c&gt;
  7c:   d518c000        msr     vbar_el1, x0
  80:   d2a00600        mov     x0, #0x300000                   // #3145728
  84:   d5181040        msr     cpacr_el1, x0
  88:   94000000        bl      94 &lt;apply_core_errata&gt;
  8c:   94000000        bl      b8 &lt;lowlevel_init&gt;

0000000000000090 &lt;master_cpu&gt;:
  90:   94000000        bl      0 &lt;_main&gt;

0000000000000094 &lt;apply_core_errata&gt;:
  94:   aa1e03fd        mov     x29, x30
  98:   d5380000        mrs     x0, midr_el1
  9c:   d344fc00        lsr     x0, x0, #4
  a0:   92402c00        and     x0, x0, #0xfff
  a4:   f1341c1f        cmp     x0, #0xd07
  a8:   54000060        b.eq    b4 &lt;apply_a57_core_errata&gt;
  ac:   aa1d03fe        mov     x30, x29
  b0:   d65f03c0        ret

00000000000000b4 &lt;apply_a57_core_errata&gt;:
  b4:   17fffffe        b       ac &lt;apply_core_errata+0x18&gt;

00000000000000b8 &lt;lowlevel_init&gt;:
  b8:   aa1e03fd        mov     x29, x30
  bc:   58000360        ldr     x0, 128 &lt;save_boot_params+0x10&gt;
  c0:   94000000        bl      0 &lt;gic_init_secure&gt;
  c4:   58000360        ldr     x0, 130 &lt;save_boot_params+0x18&gt;
  c8:   94000000        bl      0 &lt;gic_init_secure_percpu&gt;
  cc:   aa1d03fe        mov     x30, x29
  d0:   d65f03c0        ret

00000000000000d4 &lt;smp_kick_all_cpus&gt;:
  d4:   580002a0        ldr     x0, 128 &lt;save_boot_params+0x10&gt;
  d8:   14000000        b       0 &lt;gic_kick_secondary_cpus&gt;
  dc:   d65f03c0        ret

00000000000000e0 &lt;c_runtime_cpu_setup&gt;:
  e0:   10000000        adr     x0, 0 &lt;vectors&gt;
  e4:   d5384241        mrs     x1, currentel
  e8:   f100303f        cmp     x1, #0xc
  ec:   540000a0        b.eq    100 &lt;c_runtime_cpu_setup+0x20&gt;
  f0:   f100203f        cmp     x1, #0x8
  f4:   540000a0        b.eq    108 &lt;c_runtime_cpu_setup+0x28&gt;
  f8:   f100103f        cmp     x1, #0x4
  fc:   540000a0        b.eq    110 &lt;c_runtime_cpu_setup+0x30&gt;
 100:   d51ec000        msr     vbar_el3, x0
 104:   14000004        b       114 &lt;c_runtime_cpu_setup+0x34&gt;
 108:   d51cc000        msr     vbar_el2, x0
 10c:   14000002        b       114 &lt;c_runtime_cpu_setup+0x34&gt;
 110:   d518c000        msr     vbar_el1, x0
 114:   d65f03c0        ret

0000000000000118 &lt;save_boot_params&gt;:
 118:   14000000        b       2c &lt;save_boot_params_ret&gt;
 11c:   00000000        .inst   0x00000000 ; undefined
 120:   016e3600        .word   0x016e3600
 124:   00000000        .word   0x00000000
 128:   fe600000        .word   0xfe600000
 12c:   00000000        .word   0x00000000
 130:   fe680000        .word   0xfe680000
 134:   00000000        .word   0x00000000
    </pre>
    <br> 

</li>
</div>










<table><tr>
<td><img width="190" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_AliPay1.jpg" alt=""></td>
<td><img width="200" src="http://images.cnblogs.com/cnblogs_com/mojies/998573/o_WeChatPa1.jpg" alt=""></td>
</tr></table>
<div class="div_2" id="AuthorizationWarning">
<div class="Text_ZZ">原创文章，版权所有，转载请获得作者本人允许并注明出处</div>
<div class="Text_LB">我是留白；我是留白；我是留白；（重要的事情说三遍）</div>
</div>
<div class="foot_panel" id="foot_panel">
    <div id="foot_panel_top" >
        <a href="#main_index" class="NoExternal">TOP</a>
    </div>
    <div id="foot_panel_bottom" >
        <a href="#AuthorizationWarning" class="NoExternal">BOT</a>
    </div>
</div>
</body>

<script src="js/PrePost.js"></script>



</html>
